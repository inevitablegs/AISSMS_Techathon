Directory structure:
└── Final/
    ├── tempCodeRunnerFile.python
    ├── backend/
    │   ├── a.py
    │   ├── manage.py
    │   ├── req
    │   ├── accounts/
    │   │   ├── __init__.py
    │   │   ├── admin.py
    │   │   ├── apps.py
    │   │   ├── models.py
    │   │   ├── serializers.py
    │   │   ├── tests.py
    │   │   ├── urls.py
    │   │   ├── views.py
    │   │   └── migrations/
    │   │       ├── 0001_initial.py
    │   │       ├── 0002_concept_created_by.py
    │   │       ├── 0003_learningsession_knowledge_level_and_more.py
    │   │       └── __init__.py
    │   ├── core/
    │   │   ├── __init__.py
    │   │   ├── asgi.py
    │   │   ├── settings.py
    │   │   ├── urls.py
    │   │   └── wsgi.py
    │   └── learning_engine/
    │       ├── __init__.py
    │       ├── adaptive_flow.py
    │       ├── knowledge_tracing.py
    │       ├── models.py
    │       ├── question_generator.py
    │       └── utils.py
    └── frontend/
        ├── README.md
        ├── eslint.config.js
        ├── index.html
        ├── package.json
        ├── postcss.config.js
        ├── tailwind.config.js
        ├── vite.config.js
        └── src/
            ├── App.css
            ├── App.jsx
            ├── axiosConfig.js
            ├── index.css
            ├── main.jsx
            ├── components/
            │   ├── Dashboard.jsx
            │   ├── Home.jsx
            │   ├── Login.jsx
            │   ├── ProtectedRoute.jsx
            │   ├── Register.jsx
            │   └── Learning/
            │       ├── AtomComplete.jsx
            │       ├── AtomList.jsx
            │       ├── LearningProgress.jsx
            │       ├── LearningRoute.jsx
            │       ├── QuestionsFromTeaching.jsx
            │       ├── StartAnyConceptSession.jsx
            │       ├── StartAnyConceptSessionRoute.jsx
            │       ├── TeachingFirstFlow.jsx
            │       └── TeachingModule.jsx
            └── context/
                ├── AuthContext.jsx
                └── LearningContext.jsx

================================================
FILE: tempCodeRunnerFile.python
================================================
# backend/test_question_generator.py

import os
import sys
import django

# Setup Django environment
sys.path.append(os.path.dirname(os.path.abspath(__file__)))
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'core.settings')
django.setup()

from learning_engine.question_generator import QuestionGenerator
from django.conf import settings

def test_generator():
    print("=" * 50)
    print("Testing QuestionGenerator")
    print("=" * 50)
    
    print(f"GROQ_API_KEY present: {'Yes' if settings.GROQ_API_KEY else 'No'}")
    print(f"GOOGLE_API_KEY present: {'Yes' if settings.GOOGLE_API_KEY else 'No'}")
    
    generator = QuestionGenerator()
    print(f"Groq client initialized: {'Yes' if generator.groq_client else 'No'}")
    print(f"Gemini model initialized: {'Yes' if generator.gemini_model else 'No'}")
    
    if not generator.groq_client and not generator.gemini_model:
        print("\n❌ ERROR: No AI clients available! Check your API keys.")
        return
    
    print("\n" + "=" * 50)
    print("Test 1: Generate atoms")
    print("=" * 50)
    atoms = generator.generate_atoms("Microprocessor", "Memory Organization")
    print(f"Generated atoms: {atoms}")
    
    if atoms:
        print("\n" + "=" * 50)
        print("Test 2: Generate questions for first atom")
        print("=" * 50)
        questions = generator.generate_questions(
            subject="Microprocessor",
            concept="Memory Organization",
            atom=atoms[0],
            need_easy=2,
            need_medium=2,
            knowledge_level='intermediate'
        )
        print(f"Generated {len(questions)} questions")
        for i, q in enumerate(questions):
            print(f"\nQ{i+1}: {q.get('question', 'No question')}")
            print(f"   Difficulty: {q.get('difficulty')}")
            print(f"   Cognitive: {q.get('cognitive_operation')}")
            print(f"   Time: {q.get('estimated_time')}s")
    
    print("\n" + "=" * 50)
    print("Test 3: Generate complete concept")
    print("=" * 50)
    result = generator.generate_complete_concept("Microprocessor", "Memory Organization")
    print(f"Generated concept with {len(result.get('atoms', {}))} atoms")
    for atom_name, atom_data in result['atoms'].items():
        print(f"  - {atom_name}: {len(atom_data['questions'])} questions")

if __name__ == "__main__":
    test_generator()


================================================
FILE: backend/a.py
================================================
# backend/test_question_generator.py

import os
import sys
import django

# Setup Django environment
sys.path.append(os.path.dirname(os.path.abspath(__file__)))
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'core.settings')
django.setup()

from learning_engine.question_generator import QuestionGenerator
from django.conf import settings

def test_generator():
    print("=" * 50)
    print("Testing QuestionGenerator")
    print("=" * 50)
    
    print(f"GROQ_API_KEY present: {'Yes' if settings.GROQ_API_KEY else 'No'}")
    print(f"GOOGLE_API_KEY present: {'Yes' if settings.GOOGLE_API_KEY else 'No'}")
    
    generator = QuestionGenerator()
    print(f"Groq client initialized: {'Yes' if generator.groq_client else 'No'}")
    print(f"Gemini model initialized: {'Yes' if generator.gemini_model else 'No'}")
    
    if not generator.groq_client and not generator.gemini_model:
        print("\n❌ ERROR: No AI clients available! Check your API keys.")
        return
    
    print("\n" + "=" * 50)
    print("Test 1: Generate atoms")
    print("=" * 50)
    atoms = generator.generate_atoms("Microprocessor", "Memory Organization")
    print(f"Generated atoms: {atoms}")
    
    if atoms:
        print("\n" + "=" * 50)
        print("Test 2: Generate questions for first atom")
        print("=" * 50)
        questions = generator.generate_questions(
            subject="Microprocessor",
            concept="Memory Organization",
            atom=atoms[0],
            need_easy=2,
            need_medium=2,
            knowledge_level='intermediate'
        )
        print(f"Generated {len(questions)} questions")
        for i, q in enumerate(questions):
            print(f"\nQ{i+1}: {q.get('question', 'No question')}")
            print(f"   Difficulty: {q.get('difficulty')}")
            print(f"   Cognitive: {q.get('cognitive_operation')}")
            print(f"   Time: {q.get('estimated_time')}s")
    
    print("\n" + "=" * 50)
    print("Test 3: Generate complete concept")
    print("=" * 50)
    result = generator.generate_complete_concept("Microprocessor", "Memory Organization")
    print(f"Generated concept with {len(result.get('atoms', {}))} atoms")
    for atom_name, atom_data in result['atoms'].items():
        print(f"  - {atom_name}: {len(atom_data['questions'])} questions")

if __name__ == "__main__":
    test_generator()


================================================
FILE: backend/manage.py
================================================
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'core.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()



================================================
FILE: backend/req
================================================
pip install django djangorestframework
pip install djangorestframework-simplejwt
pip install django-cors-headers



================================================
FILE: backend/accounts/__init__.py
================================================
[Empty file]


================================================
FILE: backend/accounts/admin.py
================================================
from django.contrib import admin

# Register your models here.



================================================
FILE: backend/accounts/apps.py
================================================
from django.apps import AppConfig


class AccountsConfig(AppConfig):
    name = 'accounts'



================================================
FILE: backend/accounts/models.py
================================================
from django.db import models
from django.contrib.auth.models import User
import json

class LearningProfile(models.Model):
    """Student's learning profile and progress"""
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='learning_profile')
    overall_theta = models.FloatField(default=0.0)  # IRT ability parameter
    current_subject = models.CharField(max_length=100, blank=True)
    current_concept = models.CharField(max_length=100, blank=True)
    learning_streak = models.IntegerField(default=0)
    total_time_spent = models.IntegerField(default=0)  # in minutes
    last_active = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'learning_profile'

class Concept(models.Model):
    """Learning concepts and atoms"""
    DIFFICULTY_CHOICES = [
        ('easy', 'Easy'),
        ('medium', 'Medium'),
        ('hard', 'Hard'),
    ]
    
    name = models.CharField(max_length=200)
    subject = models.CharField(max_length=100)
    created_by = models.ForeignKey(
        User,
        null=True,
        blank=True,
        on_delete=models.SET_NULL,
        related_name='created_concepts'
    )
    description = models.TextField(blank=True)
    prerequisites = models.ManyToManyField('self', symmetrical=False, blank=True)
    difficulty = models.CharField(max_length=10, choices=DIFFICULTY_CHOICES, default='medium')
    order = models.IntegerField(default=0)
    
    class Meta:
        ordering = ['subject', 'order']
        unique_together = ['name', 'subject', 'created_by']

class TeachingAtom(models.Model):
    """Atomic learning units"""
    PHASE_CHOICES = [
        ('diagnostic', 'Diagnostic'),
        ('teaching', 'Teaching'),
        ('practice', 'Practice'),
        ('reinforcement', 'Reinforcement'),
        ('mastery_check', 'Mastery Check'),
        ('complete', 'Complete'),
    ]
    
    name = models.CharField(max_length=200)
    concept = models.ForeignKey(Concept, on_delete=models.CASCADE, related_name='atoms')
    explanation = models.TextField(blank=True)
    analogy = models.TextField(blank=True)
    examples = models.JSONField(default=list)
    order = models.IntegerField(default=0)
    
    class Meta:
        ordering = ['concept', 'order']

class Question(models.Model):
    """Practice questions"""
    DIFFICULTY_CHOICES = [
        ('easy', 'Easy'),
        ('medium', 'Medium'),
        ('hard', 'Hard'),
    ]
    
    COGNITIVE_CHOICES = [
        ('recall', 'Recall'),
        ('apply', 'Apply'),
        ('analyze', 'Analyze'),
    ]
    
    atom = models.ForeignKey(TeachingAtom, on_delete=models.CASCADE, related_name='questions')
    difficulty = models.CharField(max_length=10, choices=DIFFICULTY_CHOICES)
    cognitive_operation = models.CharField(max_length=10, choices=COGNITIVE_CHOICES)
    estimated_time = models.IntegerField(default=60)  # in seconds
    question_text = models.TextField()
    options = models.JSONField(default=list)
    correct_index = models.IntegerField()
    
    def to_dict(self):
        return {
            'id': self.id,
            'difficulty': self.difficulty,
            'cognitive_operation': self.cognitive_operation,
            'estimated_time': self.estimated_time,
            'question': self.question_text,
            'options': self.options,
            'correct_index': self.correct_index,
        }

class StudentProgress(models.Model):
    """Track student progress on atoms"""
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='progress')
    atom = models.ForeignKey(TeachingAtom, on_delete=models.CASCADE)
    mastery_score = models.FloatField(default=0.3)
    phase = models.CharField(max_length=20, choices=TeachingAtom.PHASE_CHOICES, default='diagnostic')
    streak = models.IntegerField(default=0)
    hint_usage = models.IntegerField(default=0)
    error_history = models.JSONField(default=list)
    retention_verified = models.BooleanField(default=False)
    last_practiced = models.DateTimeField(auto_now=True)
    times_practiced = models.IntegerField(default=0)
    
    class Meta:
        unique_together = ['user', 'atom']


    
class KnowledgeLevel(models.TextChoices):
    ZERO = 'zero', 'Zero Knowledge'
    BEGINNER = 'beginner', 'Beginner'
    INTERMEDIATE = 'intermediate', 'Intermediate'
    ADVANCED = 'advanced', 'Advanced'


class LearningSession(models.Model):
    """Track learning sessions"""
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='learning_sessions')
    concept = models.ForeignKey(Concept, on_delete=models.CASCADE)
    start_time = models.DateTimeField(auto_now_add=True)
    end_time = models.DateTimeField(null=True, blank=True)
    questions_answered = models.IntegerField(default=0)
    correct_answers = models.IntegerField(default=0)
    hints_used = models.IntegerField(default=0)
    session_data = models.JSONField(default=dict)
    knowledge_level = models.CharField(
        max_length=20,
        choices=KnowledgeLevel.choices,
        default=KnowledgeLevel.ZERO
    )
    user_feedback = models.JSONField(default=dict)  
    






================================================
FILE: backend/accounts/serializers.py
================================================
from django.contrib.auth.models import User
from django.contrib.auth.password_validation import validate_password
from rest_framework import serializers
from rest_framework.validators import UniqueValidator

class RegisterSerializer(serializers.ModelSerializer):
    email = serializers.EmailField(
        required=True,
        validators=[UniqueValidator(queryset=User.objects.all())]
    )
    password = serializers.CharField(
        write_only=True, 
        required=True, 
        validators=[validate_password]
    )
    password2 = serializers.CharField(write_only=True, required=True)

    class Meta:
        model = User
        fields = ('username', 'password', 'password2', 'email', 'first_name', 'last_name')
        extra_kwargs = {
            'first_name': {'required': True},
            'last_name': {'required': True}
        }

    def validate(self, attrs):
        if attrs['password'] != attrs['password2']:
            raise serializers.ValidationError(
                {"password": "Password fields didn't match."}
            )
        return attrs

    def create(self, validated_data):
        user = User.objects.create(
            username=validated_data['username'],
            email=validated_data['email'],
            first_name=validated_data['first_name'],
            last_name=validated_data['last_name']
        )
        user.set_password(validated_data['password'])
        user.save()
        
        # Create learning profile for the user
        from .models import LearningProfile
        LearningProfile.objects.create(user=user)
        
        return user

class UserSerializer(serializers.ModelSerializer):
    class Meta:
        model = User
        fields = ('id', 'username', 'email', 'first_name', 'last_name')
        
        
        
from .models import (
    LearningProfile, Concept, TeachingAtom, 
    Question, StudentProgress, LearningSession
)

class ConceptSerializer(serializers.ModelSerializer):
    class Meta:
        model = Concept
        fields = ['id', 'name', 'subject', 'description', 'difficulty', 'order']

class TeachingAtomSerializer(serializers.ModelSerializer):
    class Meta:
        model = TeachingAtom
        fields = ['id', 'name', 'explanation', 'analogy', 'examples', 'order']

class QuestionSerializer(serializers.ModelSerializer):
    class Meta:
        model = Question
        fields = ['id', 'difficulty', 'cognitive_operation', 'estimated_time', 
                 'question_text', 'options', 'correct_index']

class StudentProgressSerializer(serializers.ModelSerializer):
    atom_name = serializers.CharField(source='atom.name', read_only=True)
    concept_name = serializers.CharField(source='atom.concept.name', read_only=True)
    
    class Meta:
        model = StudentProgress
        fields = ['id', 'atom_name', 'concept_name', 'mastery_score', 'phase', 
                 'streak', 'hint_usage', 'retention_verified']

class LearningSessionSerializer(serializers.ModelSerializer):
    class Meta:
        model = LearningSession
        fields = ['id', 'concept', 'start_time', 'end_time', 'questions_answered',
                 'correct_answers', 'hints_used']


================================================
FILE: backend/accounts/tests.py
================================================
from django.test import TestCase

# Create your tests here.



================================================
FILE: backend/accounts/urls.py
================================================
from django.urls import path
from .views import (
    # Auth views
    RegisterView, LoginView, DashboardView,
    
    # Core learning views (keep these)
    ConceptListView, GetTeachingContentView, GetPracticeQuestionsView,
    SubmitPracticeAnswerView, GetHintView, GetLearningProgressView,
    
    # Concept generation
    GenerateConceptView, GetAtomsView,
    
    # NEW TEACHING-FIRST FLOW VIEWS (keep these)
    StartTeachingFirstSessionView, GetAtomListView, 
    GenerateQuestionsFromTeachingView, SubmitAtomQuestionAnswerView, 
    CompleteAtomView
)

urlpatterns = [
    # Auth endpoints
    path('api/register/', RegisterView.as_view(), name='register'),
    path('api/login/', LoginView.as_view(), name='login'),
    path('api/dashboard/', DashboardView.as_view(), name='dashboard'),
    
    # Core learning endpoints
    path('api/concepts/', ConceptListView.as_view(), name='concepts'),
    path('api/teaching/<int:atom_id>/', GetTeachingContentView.as_view(), name='teaching_content'),
    path('api/practice/<int:atom_id>/', GetPracticeQuestionsView.as_view(), name='practice_questions'),
    path('api/submit-answer/', SubmitPracticeAnswerView.as_view(), name='submit_answer'),
    path('api/get-hint/', GetHintView.as_view(), name='get_hint'),
    path('api/progress/', GetLearningProgressView.as_view(), name='learning_progress'),
    
    # Concept generation
    path('api/generate-concept/', GenerateConceptView.as_view(), name='generate_concept'),
    path('api/concepts/<int:concept_id>/atoms/', GetAtomsView.as_view(), name='get_atoms'),
    
    # TEACHING-FIRST FLOW ENDPOINTS
    path('api/start-teaching-session/', StartTeachingFirstSessionView.as_view(), name='start_teaching_session'),
    path('api/concepts/<int:concept_id>/atoms-list/', GetAtomListView.as_view(), name='atoms_list'),
    path('api/generate-questions-from-teaching/', GenerateQuestionsFromTeachingView.as_view(), name='generate_questions_from_teaching'),
    path('api/submit-atom-answer/', SubmitAtomQuestionAnswerView.as_view(), name='submit_atom_answer'),
    path('api/complete-atom/', CompleteAtomView.as_view(), name='complete_atom'),
]


================================================
FILE: backend/accounts/views.py
================================================
Error reading file with 'cp1252': 'charmap' codec can't decode byte 0x8d in position 43192: character maps to <undefined>


================================================
FILE: backend/accounts/migrations/0001_initial.py
================================================
# Generated by Django 6.0.2 on 2026-02-16 10:28

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='Concept',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=200)),
                ('subject', models.CharField(max_length=100)),
                ('description', models.TextField(blank=True)),
                ('difficulty', models.CharField(choices=[('easy', 'Easy'), ('medium', 'Medium'), ('hard', 'Hard')], default='medium', max_length=10)),
                ('order', models.IntegerField(default=0)),
                ('prerequisites', models.ManyToManyField(blank=True, to='accounts.concept')),
            ],
            options={
                'ordering': ['subject', 'order'],
                'unique_together': {('name', 'subject')},
            },
        ),
        migrations.CreateModel(
            name='LearningProfile',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('overall_theta', models.FloatField(default=0.0)),
                ('current_subject', models.CharField(blank=True, max_length=100)),
                ('current_concept', models.CharField(blank=True, max_length=100)),
                ('learning_streak', models.IntegerField(default=0)),
                ('total_time_spent', models.IntegerField(default=0)),
                ('last_active', models.DateTimeField(auto_now=True)),
                ('user', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, related_name='learning_profile', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'db_table': 'learning_profile',
            },
        ),
        migrations.CreateModel(
            name='LearningSession',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('start_time', models.DateTimeField(auto_now_add=True)),
                ('end_time', models.DateTimeField(blank=True, null=True)),
                ('questions_answered', models.IntegerField(default=0)),
                ('correct_answers', models.IntegerField(default=0)),
                ('hints_used', models.IntegerField(default=0)),
                ('session_data', models.JSONField(default=dict)),
                ('concept', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='accounts.concept')),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='learning_sessions', to=settings.AUTH_USER_MODEL)),
            ],
        ),
        migrations.CreateModel(
            name='TeachingAtom',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=200)),
                ('explanation', models.TextField(blank=True)),
                ('analogy', models.TextField(blank=True)),
                ('examples', models.JSONField(default=list)),
                ('order', models.IntegerField(default=0)),
                ('concept', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='atoms', to='accounts.concept')),
            ],
            options={
                'ordering': ['concept', 'order'],
            },
        ),
        migrations.CreateModel(
            name='Question',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('difficulty', models.CharField(choices=[('easy', 'Easy'), ('medium', 'Medium'), ('hard', 'Hard')], max_length=10)),
                ('cognitive_operation', models.CharField(choices=[('recall', 'Recall'), ('apply', 'Apply'), ('analyze', 'Analyze')], max_length=10)),
                ('estimated_time', models.IntegerField(default=60)),
                ('question_text', models.TextField()),
                ('options', models.JSONField(default=list)),
                ('correct_index', models.IntegerField()),
                ('atom', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='questions', to='accounts.teachingatom')),
            ],
        ),
        migrations.CreateModel(
            name='StudentProgress',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('mastery_score', models.FloatField(default=0.3)),
                ('phase', models.CharField(choices=[('diagnostic', 'Diagnostic'), ('teaching', 'Teaching'), ('practice', 'Practice'), ('reinforcement', 'Reinforcement'), ('mastery_check', 'Mastery Check'), ('complete', 'Complete')], default='diagnostic', max_length=20)),
                ('streak', models.IntegerField(default=0)),
                ('hint_usage', models.IntegerField(default=0)),
                ('error_history', models.JSONField(default=list)),
                ('retention_verified', models.BooleanField(default=False)),
                ('last_practiced', models.DateTimeField(auto_now=True)),
                ('times_practiced', models.IntegerField(default=0)),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='progress', to=settings.AUTH_USER_MODEL)),
                ('atom', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='accounts.teachingatom')),
            ],
            options={
                'unique_together': {('user', 'atom')},
            },
        ),
    ]



================================================
FILE: backend/accounts/migrations/0002_concept_created_by.py
================================================
# Generated by GitHub Copilot on 2026-02-17

from django.conf import settings
from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):

    dependencies = [
        ('accounts', '0001_initial'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.AddField(
            model_name='concept',
            name='created_by',
            field=models.ForeignKey(
                blank=True,
                null=True,
                on_delete=django.db.models.deletion.SET_NULL,
                related_name='created_concepts',
                to=settings.AUTH_USER_MODEL,
            ),
        ),
        migrations.AlterUniqueTogether(
            name='concept',
            unique_together={('name', 'subject', 'created_by')},
        ),
    ]



================================================
FILE: backend/accounts/migrations/0003_learningsession_knowledge_level_and_more.py
================================================
# Generated by Django 6.0.2 on 2026-02-17 12:58

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('accounts', '0002_concept_created_by'),
    ]

    operations = [
        migrations.AddField(
            model_name='learningsession',
            name='knowledge_level',
            field=models.CharField(choices=[('zero', 'Zero Knowledge'), ('beginner', 'Beginner'), ('intermediate', 'Intermediate'), ('advanced', 'Advanced')], default='zero', max_length=20),
        ),
        migrations.AddField(
            model_name='learningsession',
            name='user_feedback',
            field=models.JSONField(default=dict),
        ),
    ]



================================================
FILE: backend/accounts/migrations/__init__.py
================================================
[Empty file]


================================================
FILE: backend/core/__init__.py
================================================
import os
import sys

# Add the backend directory to path
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
if BASE_DIR not in sys.path:
    sys.path.append(BASE_DIR)


================================================
FILE: backend/core/asgi.py
================================================
"""
ASGI config for core project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/6.0/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'core.settings')

application = get_asgi_application()



================================================
FILE: backend/core/settings.py
================================================
import os
from datetime import timedelta
from pathlib import Path

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/6.0/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-gq5gu@@4-^r(35**5w-v6l-qkkr@aut890$z=lx^e_%1$q+nb%'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = ["*"]


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    
    # Third party apps
    'rest_framework',
    'rest_framework_simplejwt',
    'corsheaders',
    
    # Local apps
    'accounts',
    'learning_engine',

]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'corsheaders.middleware.CorsMiddleware',  # Add this
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'core.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'core.wsgi.application'


# Database
# https://docs.djangoproject.com/en/6.0/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}


# Password validation
# https://docs.djangoproject.com/en/6.0/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/6.0/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/6.0/howto/static-files/

STATIC_URL = 'static/'


DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# CORS settings
CORS_ALLOWED_ORIGINS = [
    "http://localhost:3000",
    "http://127.0.0.1:3000",
    "http://localhost:5173",
    "http://127.0.0.1:5173",
    "http://localhost:5174",
    "http://127.0.0.1:5174",
]

CORS_ALLOW_CREDENTIALS = True

# REST Framework settings
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ),
    'DEFAULT_PERMISSION_CLASSES': (
        'rest_framework.permissions.IsAuthenticated',
    ),
}

# JWT settings
SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(minutes=60),
    'REFRESH_TOKEN_LIFETIME': timedelta(days=1),
    'ROTATE_REFRESH_TOKENS': False,
    'BLACKLIST_AFTER_ROTATION': True,
    'UPDATE_LAST_LOGIN': False,

    'ALGORITHM': 'HS256',
    'SIGNING_KEY': SECRET_KEY,
    'VERIFYING_KEY': None,
    'AUDIENCE': None,
    'ISSUER': None,

    'AUTH_HEADER_TYPES': ('Bearer',),
    'AUTH_HEADER_NAME': 'HTTP_AUTHORIZATION',
    'USER_ID_FIELD': 'id',
    'USER_ID_CLAIM': 'user_id',

    'AUTH_TOKEN_CLASSES': ('rest_framework_simplejwt.tokens.AccessToken',),
    'TOKEN_TYPE_CLAIM': 'token_type',

    'JTI_CLAIM': 'jti',

    'SLIDING_TOKEN_REFRESH_EXP_CLAIM': 'refresh_exp',
    'SLIDING_TOKEN_LIFETIME': timedelta(minutes=5),
    'SLIDING_TOKEN_REFRESH_LIFETIME': timedelta(days=1),
}


LEARNING_ENGINE = {
    'MAX_PER_DIFFICULTY': 4,
    'MASTERY_THRESHOLD': 0.7,
    'BKT_SLIP': 0.1,
    'BKT_GUESS': 0.2,
    'BKT_LEARN': 0.15,
}

# API Keys (set these in environment variables)
GOOGLE_API_KEY = os.environ.get('GOOGLE_API_KEY', '')
GROQ_API_KEY = os.environ.get('GROQ_API_KEY', '')


LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'format': '{levelname} {asctime} {module} {process:d} {thread:d} {message}',
            'style': '{',
        },
        'simple': {
            'format': '{levelname} {asctime} {message}',
            'style': '{',
        },
    },
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
            'formatter': 'simple',
        },
        'file': {
            'class': 'logging.FileHandler',
            'filename': os.path.join(BASE_DIR, 'debug.log'),
            'formatter': 'verbose',
        },
    },
    'root': {
        'handlers': ['console', 'file'],
        'level': 'INFO',
    },
    'loggers': {
        'django': {
            'handlers': ['console', 'file'],
            'level': 'INFO',
            'propagate': False,
        },
        'accounts': {
            'handlers': ['console', 'file'],
            'level': 'DEBUG',
            'propagate': False,
        },
        'learning_engine': {
            'handlers': ['console', 'file'],
            'level': 'DEBUG',
            'propagate': False,
        },
    },
}


================================================
FILE: backend/core/urls.py
================================================
from django.contrib import admin
from django.urls import path, include
from rest_framework_simplejwt.views import TokenRefreshView

urlpatterns = [
    path('admin/', admin.site.urls),
    path('auth/', include('accounts.urls')),  # This should be correct
    path('api/token/refresh/', TokenRefreshView.as_view(), name='token_refresh'),
]


================================================
FILE: backend/core/wsgi.py
================================================
"""
WSGI config for core project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/6.0/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'core.settings')

application = get_wsgi_application()



================================================
FILE: backend/learning_engine/__init__.py
================================================
from .adaptive_flow import AdaptiveLearningEngine
from .knowledge_tracing import bkt_update, irt_probability, update_theta, classify_behavior, update_mastery_from_behavior, classify_error_type
from .question_generator import QuestionGenerator
from .models import TeachingAtomState, LearningPhase, ErrorType, PacingDecision

__all__ = [
    'AdaptiveLearningEngine',
    'bkt_update',
    'irt_probability',
    'update_theta',
    'classify_behavior',
    'update_mastery_from_behavior',
    'classify_error_type',
    'QuestionGenerator',
    'TeachingAtomState',
    'LearningPhase',
    'ErrorType',
    'PacingDecision',
]


================================================
FILE: backend/learning_engine/adaptive_flow.py
================================================
# backend/learning_engine/adaptive_flow.py - Enhanced version

import json
import random
from typing import Dict, List, Optional, Tuple, Any
from django.conf import settings
from groq import Groq
from .models import TeachingAtomState, LearningPhase

class AdaptiveLearningEngine:
    """Enhanced adaptive learning engine with knowledge levels"""
    
    def __init__(self):
        self.groq_client = None
        groq_key = getattr(settings, 'GROQ_API_KEY', '')
        if groq_key:
            self.groq_client = Groq(api_key=groq_key)
    
    def generate_teaching_content(self, atom_name: str, subject: str, 
                                  concept: str, knowledge_level: str) -> Dict[str, str]:
        """
        Generate teaching content for an atom based on knowledge level
        """
        if not self.groq_client:
            return self._get_fallback_content(atom_name, concept, knowledge_level)
        
        level_descriptions = {
            'zero': "Complete beginner - needs fundamental concepts explained from scratch",
            'beginner': "Has basic understanding but needs clear explanations and examples",
            'intermediate': "Knows the basics - needs deeper insights and applications",
            'advanced': "Strong understanding - needs advanced concepts and edge cases"
        }
        
        prompt = f"""
        You are creating a personalized teaching module for a single atomic concept.
        
        Subject: {subject}
        Concept: {concept}
        Atomic Concept: {atom_name}
        Student Knowledge Level: {level_descriptions.get(knowledge_level, 'intermediate')}
        
        Generate:
        1. A clear explanation tailored to their knowledge level (2-4 sentences)
        2. A concrete example relevant to their level
        3. An analogy from everyday life that matches their understanding
        4. A common misconception to watch out for
        5. A practical application or "why this matters"
        
        Rules:
        - ONE idea only
        - No jargon without explanation
        - Make it memorable and relevant
        - If advanced, include edge cases or limitations
        
        Return STRICT JSON:
        {{
            "explanation": "Clear explanation here",
            "example": "Concrete example here",
            "analogy": "Everyday analogy here",
            "misconception": "Common mistake students make",
            "practical_application": "Why this matters in real life"
        }}
        """
        
        try:
            response = self.groq_client.chat.completions.create(
                model="llama-3.3-70b-versatile",
                messages=[{"role": "user", "content": prompt}],
                temperature=0.3,
                max_tokens=800,
            )
            
            raw_text = response.choices[0].message.content
            if "```" in raw_text:
                raw_text = raw_text.split("```")[1]
                if raw_text.startswith("json"):
                    raw_text = raw_text[4:]
            
            return json.loads(raw_text.strip())
        except Exception as e:
            print(f"Warning: Could not generate teaching content: {e}")
            return self._get_fallback_content(atom_name, concept, knowledge_level)
    
    def _get_fallback_content(self, atom_name: str, concept: str, level: str) -> Dict:
        """Fallback content based on knowledge level"""
        if level == 'advanced':
            return {
                "explanation": f"{atom_name} represents an advanced aspect of {concept} with complex interactions and edge cases.",
                "example": f"Advanced example: In production systems, {atom_name} manifests through...",
                "analogy": f"Think of {atom_name} like a sophisticated system where multiple components interact.",
                "misconception": f"Even experts sometimes confuse {atom_name} with similar advanced concepts.",
                "practical_application": f"Understanding {atom_name} helps in optimizing system performance."
            }
        elif level == 'intermediate':
            return {
                "explanation": f"{atom_name} is a key component of {concept} that builds on foundational knowledge.",
                "example": f"Example: When working with {concept}, {atom_name} helps you...",
                "analogy": f"Think of {atom_name} like a well-organized tool in your toolkit.",
                "misconception": f"Don't confuse {atom_name} with its related concepts.",
                "practical_application": f"Mastering {atom_name} improves your problem-solving efficiency."
            }
        else:  # zero or beginner
            return {
                "explanation": f"{atom_name} is a fundamental building block of {concept}. It's like learning a basic rule.",
                "example": f"Simple example: Just like learning the alphabet before writing words, {atom_name} comes first.",
                "analogy": f"Think of {atom_name} like learning to crawl before you walk.",
                "misconception": f"Beginners often think {atom_name} is harder than it really is.",
                "practical_application": f"Understanding {atom_name} opens the door to mastering {concept}."
            }
    
    def determine_pacing(self, diagnostic_results: Dict, knowledge_level: str) -> str:
        """
        Determine learning pace based on diagnostic results and initial knowledge level
        """
        accuracy = diagnostic_results.get('accuracy', 0)
        
        # Adjust thresholds based on knowledge level
        if knowledge_level == 'advanced':
            if accuracy < 0.6:
                return 'slow_down'
            elif accuracy < 0.8:
                return 'stay'
            else:
                return 'speed_up'
        elif knowledge_level == 'intermediate':
            if accuracy < 0.5:
                return 'slow_down'
            elif accuracy < 0.75:
                return 'stay'
            else:
                return 'speed_up'
        else:  # zero or beginner
            if accuracy < 0.4:
                return 'sharp_slowdown'
            elif accuracy < 0.7:
                return 'slow_down'
            else:
                return 'speed_up'
    
    def get_contextual_analogy(self, atom_name: str, concept: str) -> Dict:
        """
        Get contextual analogy to reduce abstraction fatigue
        """
        analogies = {
            "address space": {
                "analogy": "Think of address space like house numbers on a street. Each house needs a unique number.",
                "scenario": "16-bit addresses = streets numbered 0000 to FFFF - 65,536 possible houses!"
            },
            "memory hierarchy": {
                "analogy": "Cache = kitchen counter (fast). RAM = refrigerator (slower, bigger). Storage = grocery store (slowest).",
                "scenario": "When cooking, keep frequently used spices on the counter."
            },
            "cache": {
                "analogy": "CPU = Player, Cache = Bat in hand, RAM = Kit bag",
                "scenario": "Keep your favorite bat in hand for quick access."
            },
            "rom": {
                "analogy": "ROM = cookbook printed in ink - recipes don't change, always there.",
                "scenario": "BIOS = restaurant's signature recipes stored permanently."
            },
            "memory mapping": {
                "analogy": "Memory mapping = assigning shelves to departments. Manager (CPU) just uses shelf numbers.",
                "scenario": "Shelf 0000-7FFF = cookbook department (ROM), 8000-FFFF = ingredients (RAM)."
            }
        }
        
        # Try to find a matching analogy
        atom_lower = atom_name.lower()
        for key, value in analogies.items():
            if key in atom_lower or key in concept.lower():
                return value
        
        # Default
        return {
            "analogy": f"Think of {atom_name} like organizing your desk. Things you use often are within reach.",
            "scenario": f"The more you practice, the more natural this becomes."
        }
    
    def check_mastery_threshold(self, atom_state: TeachingAtomState,
                               questions_answered: List[Dict]) -> Tuple[bool, float]:
        """
        Check if atom has reached mastery threshold
        """
        if not questions_answered:
            return False, atom_state.mastery_score
        
        # Calculate recent accuracy
        recent_questions = questions_answered[-3:] if len(questions_answered) > 3 else questions_answered
        recent_correct = sum(1 for q in recent_questions if q.get('correct', False))
        recent_accuracy = recent_correct / len(recent_questions) if recent_questions else 0
        
        # Check conditions
        mastery_conditions = [
            atom_state.mastery_score >= 0.7,
            recent_accuracy >= 0.8,
            atom_state.streak >= 2
        ]
        
        mastery_achieved = all(mastery_conditions)
        
        if mastery_achieved:
            atom_state.phase = LearningPhase.MASTERY_CHECK
        
        return mastery_achieved, atom_state.mastery_score


================================================
FILE: backend/learning_engine/knowledge_tracing.py
================================================
import math
from typing import Dict, Any, Optional

def bkt_update(p_know: float, correct: bool, p_slip: float = 0.1, 
               p_guess: float = 0.2, p_learn: float = 0.15) -> float:
    """
    Bayesian Knowledge Tracing update
    
    Args:
        p_know: Current probability student knows the skill
        correct: Whether answer was correct
        p_slip: Probability of slip (wrong despite knowing)
        p_guess: Probability of guess (correct despite not knowing)
        p_learn: Probability of learning after opportunity
    
    Returns:
        Updated probability of knowledge
    """
    if correct:
        numerator = p_know * (1 - p_slip)
        denominator = numerator + (1 - p_know) * p_guess
    else:
        numerator = p_know * p_slip
        denominator = numerator + (1 - p_know) * (1 - p_guess)
    
    posterior = numerator / denominator if denominator != 0 else p_know
    
    # Learning transition
    updated = posterior + (1 - posterior) * p_learn
    
    return min(1.0, max(0.0, updated))

def irt_probability(theta: float, b: float, a: float = 1.0) -> float:
    """
    Item Response Theory 2PL model
    
    Args:
        theta: Student ability
        b: Item difficulty
        a: Item discrimination
    
    Returns:
        Probability of correct response
    """
    return 1 / (1 + math.exp(-a * (theta - b)))

def update_theta(theta: float, correct: bool, b: float, 
                 a: float = 1.0, lr: float = 0.4) -> float:
    """
    Update theta using gradient of log-likelihood
    
    Args:
        theta: Current ability estimate
        correct: Whether answer was correct
        b: Item difficulty
        a: Item discrimination
        lr: Learning rate
    
    Returns:
        Updated ability estimate
    """
    predicted = irt_probability(theta, b, a)
    actual = 1.0 if correct else 0.0
    
    # Simple gradient update
    theta = theta + lr * (actual - predicted)
    
    return theta

def classify_behavior(correct: bool, time_taken: float, 
                      estimated_time: int) -> str:
    """
    Classify student behavior based on correctness and time
    
    Args:
        correct: Whether answer was correct
        time_taken: Actual time taken in seconds
        estimated_time: Expected time in seconds
    
    Returns:
        Behavior classification
    """
    if estimated_time <= 0:
        return "normal_correct" if correct else "confused"
        
    ratio = time_taken / estimated_time
    
    if correct:
        if ratio < 0.7:
            return "strong_mastery"
        elif ratio > 1.3:
            return "weak_mastery"
        else:
            return "normal_correct"
    else:
        if ratio < 0.7:
            return "guessing"
        else:
            return "confused"

def update_mastery_from_behavior(score: float, behavior: str) -> float:
    """
    Update mastery score based on behavior classification
    
    Args:
        score: Current mastery score
        behavior: Behavior classification
    
    Returns:
        Updated mastery score
    """
    weights = {
        "strong_mastery": 2.0,
        "normal_correct": 1.0,
        "weak_mastery": 0.5,
        "guessing": -1.0,
        "confused": -0.5,
    }
    
    # Convert to 0-1 range update
    update = weights.get(behavior, 0) * 0.05
    return min(1.0, max(0.0, score + update))

def classify_error_type(question: Dict[str, Any], answer: int, 
                       time_taken: float, atom_name: str) -> Optional[str]:
    """
    Classify error type based on question, answer, and timing
    
    Args:
        question: Question dictionary
        answer: Selected answer index
        time_taken: Time taken in seconds
        atom_name: Name of the teaching atom
    
    Returns:
        Error type string or None if correct
    """
    correct = (answer == question.get('correct_index'))
    estimated = question.get('estimated_time', 60)
    time_ratio = time_taken / estimated if estimated > 0 else 1.0
    
    if not correct:
        # Fast wrong = guessing
        if time_ratio < 0.5:
            return "guessing"
        
        # Slow wrong on easy question = conceptual
        if question.get('difficulty') == 'easy' and time_ratio > 1.3:
            return "conceptual"
        
        # Check for structural errors
        q_text = question.get('question', '').lower()
        if any(term in q_text for term in ['mapping', 'between', 'versus', 'vs', 'relationship']):
            return "structural"
        
        # Check if it's a factual error
        if question.get('difficulty') == 'easy':
            return "factual"
        
        # Default
        return "procedural"
    
    # Even correct answers can indicate issues
    if correct and time_ratio < 0.3:
        return "attentional"
    
    return None


# backend/learning_engine/knowledge_tracing.py

def classify_error_type(question, answer, time_taken, atom_name):
    """Classify error type based on question, answer, and timing"""
    if answer == -1:  # No answer
        return "no_answer"
    
    estimated = question.get('estimated_time', 60)
    time_ratio = time_taken / estimated if estimated > 0 else 1.0
    
    # Fast wrong = guessing
    if time_ratio < 0.5:
        return "guessing"
    
    # Slow wrong on easy question = conceptual
    if question.get('difficulty') == 'easy' and time_ratio > 1.3:
        return "conceptual"
    
    # Check for structural errors based on question content
    q_text = question.get('question', '').lower()
    if any(term in q_text for term in ['compare', 'contrast', 'difference', 'relationship']):
        return "structural"
    
    # Check if it's a factual error
    if question.get('difficulty') == 'easy':
        return "factual"
    
    # Default
    return "procedural"

def bkt_update(p_know, correct, p_slip=0.1, p_guess=0.2, p_learn=0.15):
    """Bayesian Knowledge Tracing update"""
    if correct:
        numerator = p_know * (1 - p_slip)
        denominator = numerator + (1 - p_know) * p_guess
    else:
        numerator = p_know * p_slip
        denominator = numerator + (1 - p_know) * (1 - p_guess)
    
    posterior = numerator / denominator if denominator != 0 else p_know
    
    # Learning transition
    updated = posterior + (1 - posterior) * p_learn
    
    return min(1.0, max(0.0, updated))

def update_theta(theta, correct, b=0.0, a=1.0, lr=0.4):
    """Update IRT theta parameter"""
    import math
    
    # IRT probability
    def irt_prob(theta, b, a):
        return 1 / (1 + math.exp(-a * (theta - b)))
    
    predicted = irt_prob(theta, b, a)
    actual = 1.0 if correct else 0.0
    
    # Gradient update
    theta = theta + lr * (actual - predicted)
    
    return theta


================================================
FILE: backend/learning_engine/models.py
================================================
from dataclasses import dataclass
from typing import List, Dict, Optional
from enum import Enum

class LearningPhase(str, Enum):
    DIAGNOSTIC = "diagnostic"
    TEACHING = "teaching"
    PRACTICE = "practice"
    REINFORCEMENT = "reinforcement"
    MASTERY_CHECK = "mastery_check"
    COMPLETE = "complete"

class ErrorType(str, Enum):
    CONCEPTUAL = "conceptual"
    PROCEDURAL = "procedural"
    FACTUAL = "factual"
    GUESSING = "guessing"
    STRUCTURAL = "structural"
    ATTENTIONAL = "attentional"

class PacingDecision(str, Enum):
    SPEED_UP = "speed_up"
    SLOW_DOWN = "slow_down"
    SHARP_SLOWDOWN = "sharp_slowdown"
    STAY = "stay"
    REINFORCE = "reinforce"
    ADVANCE = "advance"
    RETREAT = "retreat"

@dataclass
class TeachingAtomState:
    """Represents a teaching atom's state in memory"""
    id: int
    name: str
    mastery_score: float = 0.3
    phase: LearningPhase = LearningPhase.DIAGNOSTIC
    streak: int = 0
    hint_usage: int = 0
    error_history: List[str] = None
    retention_verified: bool = False
    
    def __post_init__(self):
        if self.error_history is None:
            self.error_history = []
    
    def to_dict(self):
        return {
            'id': self.id,
            'name': self.name,
            'mastery_score': self.mastery_score,
            'phase': self.phase.value if hasattr(self.phase, 'value') else self.phase,
            'streak': self.streak,
            'hint_usage': self.hint_usage,
            'retention_verified': self.retention_verified,
            'error_history': self.error_history[-5:]
        }


================================================
FILE: backend/learning_engine/question_generator.py
================================================
# backend/learning_engine/question_generator.py - Complete fixed version

import json
import os
from typing import Dict, List, Optional
from groq import Groq
import google.generativeai as genai
from django.conf import settings

class QuestionGenerator:
    """Generate questions and atoms for learning using AI"""
    
    def __init__(self):
        # Initialize Groq client
        groq_key = getattr(settings, 'GROQ_API_KEY', '')
        self.groq_client = Groq(api_key=groq_key) if groq_key else None
        
        # Initialize Gemini client
        gemini_key = getattr(settings, 'GOOGLE_API_KEY', '')
        if gemini_key:
            genai.configure(api_key=gemini_key)
            self.gemini_model = genai.GenerativeModel('gemini-1.5-flash')
        else:
            self.gemini_model = None
    
    def generate_atoms(self, subject: str, concept: str) -> List[str]:
        """
        Generate atomic concepts using Gemini
        
        Args:
            subject: Subject name (e.g., 'Microprocessor')
            concept: Concept name (e.g., 'Memory Organization')
        
        Returns:
            List of atomic concept names
        """
        if not self.gemini_model:
            print("Gemini model not available, using fallback atoms")
            return self._get_fallback_atoms(subject, concept)
        
        prompt = f"""
        You are generating atomic sub-concepts for curriculum design.

        Subject: {subject}
        Concept: {concept}

        You must follow ALL rules strictly.

        STRICT RULES:
        1. Generate EXACTLY between 4 and 6 atoms.
        2. Each atom must be:
           - A noun or noun phrase only.
           - Maximum 4 words.
           - No verbs.
           - No full sentences.
        3. All atoms must belong to the SAME abstraction level.
        4. Do NOT generate:
           - Parentâ€“child pairs
           - General-to-specific relationships
           - Negation pairs (pre/non, with/without, static/dynamic)
           - Overlapping concepts
           - Duplicates
        5. Each atom must be independently assessable.
        6. Do NOT include the concept name itself.
        7. No explanations.
        8. No numbering.
        9. No markdown.
        10. Output STRICT JSON only.

        Output format:
        {{
            "atoms": [
                "Atom 1",
                "Atom 2",
                "Atom 3",
                "Atom 4"
            ]
        }}

        If rules cannot be satisfied, return:
        {{"atoms": []}}
        """
        
        try:
            response = self.gemini_model.generate_content(prompt)
            
            # Extract JSON from response
            text = response.text
            if "```" in text:
                text = text.split("```")[1]
                if text.startswith("json"):
                    text = text[4:]
            
            result = json.loads(text.strip())
            atoms = result.get("atoms", [])
            
            # Validate atom count
            if len(atoms) < 4 or len(atoms) > 6:
                print(f"Invalid atom count: {len(atoms)}, using fallback")
                return self._get_fallback_atoms(subject, concept)
            
            return atoms
            
        except Exception as e:
            print(f"Error generating atoms: {e}")
            return self._get_fallback_atoms(subject, concept)
    
    def generate_questions(self, subject: str, concept: str, atom: str,
                          need_easy: int, need_medium: int, knowledge_level: str = 'intermediate') -> List[Dict]:
        """
        Generate questions for an atom based on knowledge level
        
        Args:
            subject: Subject name
            concept: Concept name
            atom: Atomic concept name
            need_easy: Number of easy questions needed
            need_medium: Number of medium questions needed
            knowledge_level: Student's knowledge level (zero, beginner, intermediate, advanced)
        
        Returns:
            List of question dictionaries
        """
        print(f"Generating questions for atom: {atom}, easy: {need_easy}, medium: {need_medium}, level: {knowledge_level}")
        
        if not self.groq_client or (need_easy == 0 and need_medium == 0):
            print("Groq client not available or no questions needed, using fallback")
            return self._get_fallback_questions(atom, need_easy, need_medium, knowledge_level)
        
        total_needed = need_easy + need_medium
        
        # Adjust based on knowledge level
        level_adjustments = {
            'zero': {
                'cognitive': ['recall'],
                'time_factor': 1.5,
                'complexity': 'very simple, foundational',
                'hint_level': 'detailed'
            },
            'beginner': {
                'cognitive': ['recall', 'apply'],
                'time_factor': 1.2,
                'complexity': 'straightforward',
                'hint_level': 'clear'
            },
            'intermediate': {
                'cognitive': ['recall', 'apply', 'analyze'],
                'time_factor': 1.0,
                'complexity': 'moderate',
                'hint_level': 'moderate'
            },
            'advanced': {
                'cognitive': ['apply', 'analyze'],
                'time_factor': 0.8,
                'complexity': 'challenging',
                'hint_level': 'subtle'
            }
        }
        
        adj = level_adjustments.get(knowledge_level, level_adjustments['intermediate'])
        
        req_lines = []
        if need_easy:
            req_lines.append(f"- {need_easy} easy question(s)")
        if need_medium:
            req_lines.append(f"- {need_medium} medium question(s)")
        
        prompt = f"""
        You are generating multiple-choice assessment questions.
        
        Subject: {subject}
        Concept: {concept}
        Atomic Concept: {atom}
        Student Level: {knowledge_level.upper()}
        
        Generate EXACTLY {total_needed} questions with these characteristics:
        - Complexity: {adj['complexity']}
        - Cognitive levels: {', '.join(adj['cognitive'])}
        - Hint level: {adj['hint_level']}
        
        Question Distribution:
        {chr(10).join(req_lines)}
        - No hard questions
        
        Each question must:
        - Have exactly 4 options
        - Be clearly worded and self-contained
        - Test understanding, not trickery
        - Include the atomic concept explicitly
        - Maximum 25 words per question text
        
        Each question MUST include:
        - "difficulty": easy | medium
        - "cognitive_operation": recall | apply | analyze
        - "estimated_time": integer (seconds) - recall: 20-40, apply: 40-90, analyze: 90-150
        - "question": string
        - "options": array of exactly 4 strings
        - "correct_index": integer (0-3)
        
        OUTPUT STRICT JSON ONLY:
        
        {{
            "questions": [
                {{
                    "difficulty": "easy",
                    "cognitive_operation": "recall",
                    "estimated_time": 30,
                    "question": "Question text here?",
                    "options": [
                        "Option A",
                        "Option B",
                        "Option C",
                        "Option D"
                    ],
                    "correct_index": 1
                }}
            ]
        }}
        
        If constraints cannot be satisfied, return:
        {{"questions": []}}
        """
        
        try:
            response = self.groq_client.chat.completions.create(
                model="llama-3.3-70b-versatile",
                messages=[{"role": "user", "content": prompt}],
                temperature=0.3,
                max_tokens=1024,
            )
            
            raw_text = response.choices[0].message.content
            # Extract JSON
            if "```" in raw_text:
                raw_text = raw_text.split("```")[1]
                if raw_text.startswith("json"):
                    raw_text = raw_text[4:]
            
            result = json.loads(raw_text.strip())
            questions = result.get("questions", [])
            
            # Adjust estimated time based on knowledge level
            for q in questions:
                q['estimated_time'] = int(q.get('estimated_time', 60) * adj['time_factor'])
            
            print(f"Generated {len(questions)} questions")
            return questions
            
        except Exception as e:
            print(f"Error generating questions: {e}")
            return self._get_fallback_questions(atom, need_easy, need_medium, knowledge_level)
    
    def _get_fallback_atoms(self, subject: str, concept: str) -> List[str]:
        """Provide fallback atoms when AI generation fails"""
        # Common fallback atoms based on concept
        fallbacks = {
            "Memory Organization": [
                "Address Space",
                "Memory Hierarchy",
                "Cache Memory",
                "RAM vs ROM",
                "Memory Mapping"
            ],
            "Address Space": [
                "Address Lines",
                "Memory Locations",
                "Address Decoding",
                "Word Size",
                "Byte Addressing"
            ],
            "Cache Memory": [
                "Cache Levels",
                "Cache Hit/Miss",
                "Cache Mapping",
                "Replacement Policy",
                "Write Policy"
            ]
        }
        
        # Try to find matching fallback
        for key, atoms in fallbacks.items():
            if key.lower() in concept.lower():
                return atoms
        
        # Generic fallback
        return [
            f"{concept} Basics",
            f"{concept} Structure",
            f"{concept} Operations",
            f"{concept} Applications",
            f"{concept} Limitations"
        ]
    
    def _get_fallback_questions(self, atom: str, need_easy: int, need_medium: int, level: str = 'intermediate') -> List[Dict]:
        """Provide fallback questions when AI generation fails"""
        questions = []
        
        # Generate easy questions
        for i in range(need_easy):
            questions.append({
                "difficulty": "easy",
                "cognitive_operation": "recall",
                "estimated_time": 30,
                "question": f"What is the primary purpose of {atom}?",
                "options": [
                    f"To manage {atom} operations",
                    "To store data permanently",
                    "To execute instructions",
                    "To control peripherals"
                ],
                "correct_index": 0
            })
        
        # Generate medium questions
        for i in range(need_medium):
            questions.append({
                "difficulty": "medium",
                "cognitive_operation": "apply",
                "estimated_time": 60,
                "question": f"Which scenario best demonstrates the application of {atom}?",
                "options": [
                    f"When implementing {atom} in a real system",
                    "During basic operations",
                    "In simple calculations",
                    "At the start of processing"
                ],
                "correct_index": 0
            })
        
        return questions
    
    def generate_complete_concept(self, subject: str, concept: str) -> Dict:
        """
        Generate complete concept with atoms and questions
        
        Args:
            subject: Subject name
            concept: Concept name
        
        Returns:
            Dictionary with atoms and questions
        """
        print(f"Generating complete concept for {subject} - {concept}")
        
        # Generate atoms
        atoms = self.generate_atoms(subject, concept)
        print(f"Generated {len(atoms)} atoms: {atoms}")
        
        result = {
            "concept": concept,
            "subject": subject,
            "atoms": {}
        }
        
        # Generate questions for each atom
        for atom in atoms:
            print(f"Generating questions for atom: {atom}")
            # Generate 2 easy and 2 medium questions per atom
            questions = self.generate_questions(
                subject=subject,
                concept=concept,
                atom=atom,
                need_easy=2,
                need_medium=2,
                knowledge_level='intermediate'  # Default level
            )
            
            result["atoms"][atom] = {
                "name": atom,
                "questions": questions
            }
            
            print(f"Generated {len(questions)} questions for {atom}")
        
        return result
    
    
    
    def generate_questions_from_teaching(self, subject, concept, atom, teaching_content, 
                                        need_easy=1, need_medium=2, need_hard=0, 
                                        knowledge_level='intermediate'):
        """
        Generate questions based on the teaching content that was shown
        
        Args:
            subject: Subject name
            concept: Concept name
            atom: Atomic concept name
            teaching_content: Dict with explanation, analogy, examples
            need_easy: Number of easy questions
            need_medium: Number of medium questions
            need_hard: Number of hard questions
            knowledge_level: Student's knowledge level
        
        Returns:
            List of question dictionaries
        """
        print(f"Generating questions from teaching for atom: {atom}")
        
        if not self.groq_client:
            print("Groq client not available, using fallback")
            return self._get_fallback_questions_from_teaching(atom, need_easy, need_medium, need_hard)
        
        total_needed = need_easy + need_medium + need_hard
        
        # Extract teaching content
        explanation = teaching_content.get('explanation', '')
        analogy = teaching_content.get('analogy', '')
        examples = teaching_content.get('examples', [])
        
        examples_text = "\n".join([f"- {ex}" for ex in examples if ex])
        
        prompt = f"""
        You are generating assessment questions based on specific teaching content that was just shown to a student.
        
        Subject: {subject}
        Concept: {concept}
        Atomic Concept: {atom}
        Student Level: {knowledge_level.upper()}
        
        TEACHING CONTENT SHOWN TO STUDENT:
        
        Explanation:
        {explanation}
        
        Analogy:
        {analogy}
        
        Examples/Applications:
        {examples_text}
        
        TASK:
        Generate EXACTLY {total_needed} multiple-choice questions that test understanding of the teaching content above.
        
        Question Distribution:
        - Easy: {need_easy} question(s) - Direct recall from the explanation
        - Medium: {need_medium} question(s) - Apply the concept to new situations
        - Hard: {need_hard} question(s) - Analyze relationships or troubleshoot
        
        RULES:
        1. Each question must be answerable based SOLELY on the teaching content provided
        2. Test genuine understanding, not trickery
        3. Questions should build upon what was taught
        4. Include the analogy or examples where appropriate
        5. Each question must have exactly 4 options
        6. One clearly correct answer, three plausible distractors
        
        OUTPUT STRICT JSON ONLY:
        
        {{
            "questions": [
                {{
                    "difficulty": "easy",
                    "cognitive_operation": "recall",
                    "estimated_time": 30,
                    "question": "Based on the explanation, what is the main purpose of {atom}?",
                    "options": [
                        "Option A based on teaching",
                        "Option B based on teaching", 
                        "Option C based on teaching",
                        "Option D based on teaching"
                    ],
                    "correct_index": 0
                }}
            ]
        }}
        """
        
        try:
            response = self.groq_client.chat.completions.create(
                model="llama-3.3-70b-versatile",
                messages=[{"role": "user", "content": prompt}],
                temperature=0.3,
                max_tokens=1024,
            )
            
            raw_text = response.choices[0].message.content
            if "```" in raw_text:
                raw_text = raw_text.split("```")[1]
                if raw_text.startswith("json"):
                    raw_text = raw_text[4:]
            
            result = json.loads(raw_text.strip())
            questions = result.get("questions", [])
            
            print(f"Generated {len(questions)} questions from teaching")
            return questions
            
        except Exception as e:
            print(f"Error generating questions from teaching: {e}")
            return self._get_fallback_questions_from_teaching(atom, need_easy, need_medium, need_hard)

    def _get_fallback_questions_from_teaching(self, atom, need_easy, need_medium, need_hard):
        """Fallback questions based on teaching content"""
        questions = []
        
        # Easy questions
        for i in range(need_easy):
            questions.append({
                "difficulty": "easy",
                "cognitive_operation": "recall",
                "estimated_time": 30,
                "question": f"What is the main purpose of {atom}?",
                "options": [
                    f"To {atom.lower()} efficiently",
                    "To store data permanently",
                    "To execute instructions",
                    "To control peripherals"
                ],
                "correct_index": 0
            })
        
        # Medium questions
        for i in range(need_medium):
            questions.append({
                "difficulty": "medium",
                "cognitive_operation": "apply",
                "estimated_time": 60,
                "question": f"Which scenario best demonstrates the application of {atom}?",
                "options": [
                    f"When implementing {atom} in a real system",
                    "During basic operations",
                    "In simple calculations",
                    "At the start of processing"
                ],
                "correct_index": 0
            })
        
        # Hard questions
        for i in range(need_hard):
            questions.append({
                "difficulty": "hard",
                "cognitive_operation": "analyze",
                "estimated_time": 90,
                "question": f"What would happen if {atom} was implemented incorrectly?",
                "options": [
                    "System performance would degrade",
                    "Nothing would change",
                    "The system would run faster",
                    "Data would be more secure"
                ],
                "correct_index": 0
            })
        
        return questions


================================================
FILE: backend/learning_engine/utils.py
================================================
import json
from typing import Any, Dict, List

def extract_json(text: str) -> str:
    """Extract JSON from text that might contain markdown code blocks"""
    text = text.strip()
    if text.startswith("```"):
        # Remove fenced code block markers
        lines = [ln.rstrip() for ln in text.splitlines()]
        if lines and lines[0].startswith("```"):
            lines = lines[1:]
        if lines and lines[-1].startswith("```"):
            lines = lines[:-1]
        text = "\n".join(lines).strip()
        if text.lower().startswith("json"):
            text = text[4:].strip()
    return text

def normalize_difficulty(value: str) -> str:
    """Normalize difficulty string"""
    v = (value or "").strip().lower()
    if v in ("med", "mid"):
        return "medium"
    return v

def difficulty_count(questions: List[Dict[str, Any]], difficulty: str) -> int:
    """Count questions of a specific difficulty"""
    d = normalize_difficulty(difficulty)
    return sum(1 for q in questions if normalize_difficulty(q.get("difficulty", "")) == d)

def existing_texts(questions: List[Dict[str, Any]], difficulty: str) -> set:
    """Get set of question texts for a specific difficulty"""
    d = normalize_difficulty(difficulty)
    return {
        (q.get("question") or "").strip().lower()
        for q in questions
        if normalize_difficulty(q.get("difficulty", "")) == d
    }


================================================
FILE: frontend/README.md
================================================
# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) (or [oxc](https://oxc.rs) when used in [rolldown-vite](https://vite.dev/guide/rolldown)) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## React Compiler

The React Compiler is not enabled on this template because of its impact on dev & build performances. To add it, see [this documentation](https://react.dev/learn/react-compiler/installation).

## Expanding the ESLint configuration

If you are developing a production application, we recommend using TypeScript with type-aware lint rules enabled. Check out the [TS template](https://github.com/vitejs/vite/tree/main/packages/create-vite/template-react-ts) for information on how to integrate TypeScript and [`typescript-eslint`](https://typescript-eslint.io) in your project.



================================================
FILE: frontend/eslint.config.js
================================================
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{js,jsx}'],
    extends: [
      js.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    rules: {
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
      'react-hooks/set-state-in-effect': 'off',
      'react-refresh/only-export-components': 'off',
    },
  },
])



================================================
FILE: frontend/index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Student Portal</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>


================================================
FILE: frontend/package.json
================================================
{
  "name": "frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "axios": "^1.13.5",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "react-router-dom": "^7.13.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@types/react": "^19.2.7",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.1",
    "autoprefixer": "^10.4.24",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "postcss": "^8.4.32",
    "tailwindcss": "^3.3.6",
    "vite": "^8.0.0-beta.13"
  },
  "overrides": {
    "vite": "^8.0.0-beta.13"
  }
}



================================================
FILE: frontend/postcss.config.js
================================================
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}



================================================
FILE: frontend/tailwind.config.js
================================================
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}


================================================
FILE: frontend/vite.config.js
================================================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    port: 3000,
    open: true,
    proxy: {
      '/auth': {
        target: 'http://localhost:8000',
        changeOrigin: true,
      },
      '/api': {
        target: 'http://localhost:8000',
        changeOrigin: true,
      }
    }
  }
})


================================================
FILE: frontend/src/App.css
================================================
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}



================================================
FILE: frontend/src/App.jsx
================================================
// In App.jsx - Make sure your route is exactly like this:
import React from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import { AuthProvider } from './context/AuthContext';
import Home from './components/Home';
import Login from './components/Login';
import Register from './components/Register';
import Dashboard from './components/Dashboard';
import ProtectedRoute from './components/ProtectedRoute';
import LearningRoute from './components/Learning/LearningRoute';
import StartAnyConceptSessionRoute from './components/Learning/StartAnyConceptSessionRoute';

function App() {
    return (
        <Router>
            <AuthProvider>
                <Routes>
                    <Route path="/" element={<Home />} />
                    <Route path="/login" element={<Login />} />
                    <Route path="/register" element={<Register />} />
                    
                    <Route
                        path="/dashboard"
                        element={
                            <ProtectedRoute>
                                <Dashboard />
                            </ProtectedRoute>
                        }
                    />

                    {/* This is the important route - note the :conceptId parameter */}
                    <Route
                        path="/learn/:conceptId"
                        element={
                            <ProtectedRoute>
                                <LearningRoute />
                            </ProtectedRoute>
                        }
                    />

                    <Route
                        path="/learn/start"
                        element={
                            <ProtectedRoute>
                                <StartAnyConceptSessionRoute />
                            </ProtectedRoute>
                        }
                    />
                </Routes>
            </AuthProvider>
        </Router>
    );
}

export default App;


================================================
FILE: frontend/src/axiosConfig.js
================================================
import axios from 'axios';

const axiosInstance = axios.create({
    baseURL: 'http://localhost:8000',
    headers: {
        'Content-Type': 'application/json',
    },
});

// Add token to requests if it exists
axiosInstance.interceptors.request.use(
    (config) => {
        const token = localStorage.getItem('access_token');
        console.log("Axios Request:", {
            url: config.url,
            method: config.method,
            hasToken: !!token,
            token: token ? `${token.substring(0, 20)}...` : 'none'
        });
        
        if (token) {
            config.headers.Authorization = `Bearer ${token}`;
        }
        return config;
    },
    (error) => {
        return Promise.reject(error);
    }
);

// Add response interceptor to handle 401 errors
axiosInstance.interceptors.response.use(
    (response) => response,
    async (error) => {
        const originalRequest = error.config;
        
        console.log("Axios Response Error:", {
            status: error.response?.status,
            url: originalRequest?.url,
            message: error.response?.data?.error || error.message
        });
        
        // If error is 401 and we haven't tried to refresh token yet
        if (error.response?.status === 401 && !originalRequest._retry) {
            originalRequest._retry = true;
            
            try {
                const refreshToken = localStorage.getItem('refresh_token');
                if (refreshToken) {
                    const response = await axios.post('http://localhost:8000/api/token/refresh/', {
                        refresh: refreshToken
                    });
                    
                    if (response.data.access) {
                        localStorage.setItem('access_token', response.data.access);
                        originalRequest.headers.Authorization = `Bearer ${response.data.access}`;
                        return axiosInstance(originalRequest);
                    }
                }
            } catch (refreshError) {
                console.error("Token refresh failed:", refreshError);
                // Clear tokens and redirect to login
                localStorage.removeItem('access_token');
                localStorage.removeItem('refresh_token');
                window.location.href = '/login';
            }
        }
        
        return Promise.reject(error);
    }
);

export default axiosInstance;


================================================
FILE: frontend/src/index.css
================================================
@tailwind base;
@tailwind components;
@tailwind utilities;


@keyframes bounce {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-10px); }
}

.animate-bounce {
    animation: bounce 1s infinite;
}

@keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
}

.animate-pulse-slow {
    animation: pulse 2s infinite;
}

/* Progress bar animations */
.progress-bar-striped {
    background-image: linear-gradient(
        45deg,
        rgba(255, 255, 255, 0.15) 25%,
        transparent 25%,
        transparent 50%,
        rgba(255, 255, 255, 0.15) 50%,
        rgba(255, 255, 255, 0.15) 75%,
        transparent 75%,
        transparent
    );
    background-size: 1rem 1rem;
    animation: progress-bar-stripes 1s linear infinite;
}

@keyframes progress-bar-stripes {
    0% { background-position: 1rem 0; }
    100% { background-position: 0 0; }
}


================================================
FILE: frontend/src/main.jsx
================================================
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)


================================================
FILE: frontend/src/components/Dashboard.jsx
================================================
import React, { useCallback, useEffect, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';
import axios from '../axiosConfig';

const Dashboard = () => {
    const [dashboardData, setDashboardData] = useState(null);
    const [concepts, setConcepts] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState('');
    const [selectedSubject, setSelectedSubject] = useState('');
    const [subjects, setSubjects] = useState([]);
    
    const { user, logout } = useAuth();
    const navigate = useNavigate();

    const fetchDashboardData = useCallback(async () => {
        try {
            const response = await axios.get('/auth/api/dashboard/');
            setDashboardData(response.data);
        } catch (err) {
            setError('Failed to fetch dashboard data');
            
            if (err.response?.status === 401) {
                logout();
                navigate('/login');
            }
        }
    }, [logout, navigate]);

    const fetchConcepts = useCallback(async () => {
        try {
            const response = await axios.get('/auth/api/concepts/');
            setConcepts(response.data);
            
            // Extract unique subjects
            const uniqueSubjects = [...new Set(response.data.map(c => c.subject))];
            setSubjects(uniqueSubjects);
        } catch (err) {
            console.error('Failed to fetch concepts:', err);
        } finally {
            setLoading(false);
        }
    }, []);

    useEffect(() => {
        fetchDashboardData();
        fetchConcepts();
    }, [fetchDashboardData, fetchConcepts]);

    const handleLogout = () => {
        logout();
        navigate('/login');
    };

    const handleStartLearning = (conceptId) => {
        // Navigate to the teaching-first flow with concept ID
        navigate(`/learn/${conceptId}`);
    };

    const handleStartAnyConcept = () => {
        navigate('/learn/start');
    };

    const handleViewProgress = () => {
        navigate('/progress');
    };

    const filteredConcepts = selectedSubject
        ? concepts.filter(c => c.subject === selectedSubject)
        : concepts;

    if (loading) {
        return (
            <div className="min-h-screen flex items-center justify-center">
                <div className="text-xl text-gray-600">Loading...</div>
            </div>
        );
    }

    if (error) {
        return (
            <div className="min-h-screen flex items-center justify-center">
                <div className="text-xl text-red-600">{error}</div>
            </div>
        );
    }

    return (
        <div className="min-h-screen bg-gray-100">
            <nav className="bg-white shadow-lg">
                <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
                    <div className="flex justify-between h-16">
                        <div className="flex items-center">
                            <h1 className="text-xl font-semibold text-gray-800">
                                Student Dashboard
                            </h1>
                        </div>
                        <div className="flex items-center space-x-4">
                            <span className="text-gray-700">
                                Welcome, {user?.first_name}!
                            </span>
                            <button
                                onClick={handleLogout}
                                className="bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-4 rounded"
                            >
                                Logout
                            </button>
                        </div>
                    </div>
                </div>
            </nav>

            <main className="max-w-7xl mx-auto py-6 sm:px-6 lg:px-8">
                <div className="px-4 py-6 sm:px-0">
                    {/* Welcome Message */}
                    <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
                        <h2 className="text-2xl font-bold mb-2">
                            {dashboardData?.message || `Welcome back, ${user?.first_name}!`}
                        </h2>
                        <p className="text-gray-600">
                            Continue your learning journey with our adaptive teaching system.
                        </p>
                    </div>

                    {/* Stats Cards */}
                    <div className="grid grid-cols-1 gap-5 sm:grid-cols-2 lg:grid-cols-4 mb-6">
                        <div className="bg-white overflow-hidden shadow rounded-lg">
                            <div className="px-4 py-5 sm:p-6">
                                <dt className="text-sm font-medium text-gray-500 truncate">
                                    Total Courses
                                </dt>
                                <dd className="mt-1 text-3xl font-semibold text-gray-900">
                                    {concepts.length}
                                </dd>
                            </div>
                        </div>

                        <div className="bg-white overflow-hidden shadow rounded-lg">
                            <div className="px-4 py-5 sm:p-6">
                                <dt className="text-sm font-medium text-gray-500 truncate">
                                    Subjects
                                </dt>
                                <dd className="mt-1 text-3xl font-semibold text-gray-900">
                                    {subjects.length}
                                </dd>
                            </div>
                        </div>

                        <div className="bg-white overflow-hidden shadow rounded-lg">
                            <div className="px-4 py-5 sm:p-6">
                                <dt className="text-sm font-medium text-gray-500 truncate">
                                    Learning Streak
                                </dt>
                                <dd className="mt-1 text-3xl font-semibold text-gray-900">
                                    {dashboardData?.dashboard_data?.learning_streak || 0} ðŸ”¥
                                </dd>
                            </div>
                        </div>

                        <div className="bg-white overflow-hidden shadow rounded-lg">
                            <div className="px-4 py-5 sm:p-6">
                                <dt className="text-sm font-medium text-gray-500 truncate">
                                    Time Spent
                                </dt>
                                <dd className="mt-1 text-3xl font-semibold text-gray-900">
                                    {dashboardData?.dashboard_data?.total_time_spent || 0}m
                                </dd>
                            </div>
                        </div>
                    </div>

                    {/* Quick Actions */}
                    <div className="bg-white shadow overflow-hidden sm:rounded-lg mb-6">
                        <div className="px-4 py-5 sm:px-6">
                            <h3 className="text-lg leading-6 font-medium text-gray-900">
                                Quick Actions
                            </h3>
                        </div>
                        <div className="border-t border-gray-200 px-4 py-5 sm:px-6">
                            <div className="grid grid-cols-1 gap-4 sm:grid-cols-3">
                                <button
                                    onClick={handleStartAnyConcept}
                                    className="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg text-center transition"
                                >
                                    â–¶ Start New Session
                                </button>

                                <button
                                    onClick={handleViewProgress}
                                    className="bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-4 rounded-lg text-center transition"
                                >
                                    ðŸ“Š View Progress
                                </button>

                                <button
                                    onClick={() => window.location.reload()}
                                    className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg text-center transition"
                                >
                                    ðŸ”„ Refresh
                                </button>
                            </div>
                        </div>
                    </div>

                    {/* Concepts Section */}
                    <div className="bg-white shadow overflow-hidden sm:rounded-lg">
                        <div className="px-4 py-5 sm:px-6 flex justify-between items-center">
                            <div>
                                <h3 className="text-lg leading-6 font-medium text-gray-900">
                                    Available Concepts
                                </h3>
                                <p className="mt-1 text-sm text-gray-500">
                                    Select a concept to start learning with our teaching-first approach
                                </p>
                            </div>
                            
                            {/* Subject Filter */}
                            <div className="w-64">
                                <select
                                    value={selectedSubject}
                                    onChange={(e) => setSelectedSubject(e.target.value)}
                                    className="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md"
                                >
                                    <option value="">All Subjects</option>
                                    {subjects.map(subject => (
                                        <option key={subject} value={subject}>
                                            {subject}
                                        </option>
                                    ))}
                                </select>
                            </div>
                        </div>
                        
                        <div className="border-t border-gray-200">
                            {filteredConcepts.length === 0 ? (
                                <div className="text-center py-12">
                                    <p className="text-gray-500">No concepts available.</p>
                                    <p className="text-sm text-gray-400 mt-2">
                                        Try generating a new concept or check back later.
                                    </p>
                                </div>
                            ) : (
                                <ul className="divide-y divide-gray-200">
                                    {filteredConcepts.map((concept) => (
                                        <li key={concept.id} className="px-4 py-4 sm:px-6 hover:bg-gray-50">
                                            <div className="flex items-center justify-between">
                                                <div className="flex-1 min-w-0">
                                                    <p className="text-sm font-medium text-blue-600 truncate">
                                                        {concept.name}
                                                    </p>
                                                    <div className="mt-2 flex items-center text-sm text-gray-500">
                                                        <span className="truncate">{concept.subject}</span>
                                                        <span className="mx-2">â€¢</span>
                                                        <span className="capitalize">Difficulty: {concept.difficulty}</span>
                                                        {concept.description && (
                                                            <>
                                                                <span className="mx-2">â€¢</span>
                                                                <span className="truncate">{concept.description}</span>
                                                            </>
                                                        )}
                                                    </div>
                                                </div>
                                                <div className="ml-4 flex-shrink-0">
                                                    <button
                                                        onClick={() => handleStartLearning(concept.id)}
                                                        className="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
                                                    >
                                                        Start Learning
                                                    </button>
                                                </div>
                                            </div>
                                        </li>
                                    ))}
                                </ul>
                            )}
                        </div>
                    </div>

                    {/* User Information */}
                    <div className="mt-6 bg-white shadow overflow-hidden sm:rounded-lg">
                        <div className="px-4 py-5 sm:px-6">
                            <h3 className="text-lg leading-6 font-medium text-gray-900">
                                Your Information
                            </h3>
                        </div>
                        <div className="border-t border-gray-200 px-4 py-5 sm:px-6">
                            <dl className="grid grid-cols-1 gap-x-4 gap-y-8 sm:grid-cols-2">
                                <div className="sm:col-span-1">
                                    <dt className="text-sm font-medium text-gray-500">
                                        Username
                                    </dt>
                                    <dd className="mt-1 text-sm text-gray-900">
                                        {user?.username}
                                    </dd>
                                </div>
                                <div className="sm:col-span-1">
                                    <dt className="text-sm font-medium text-gray-500">
                                        Email
                                    </dt>
                                    <dd className="mt-1 text-sm text-gray-900">
                                        {user?.email}
                                    </dd>
                                </div>
                                <div className="sm:col-span-1">
                                    <dt className="text-sm font-medium text-gray-500">
                                        Full Name
                                    </dt>
                                    <dd className="mt-1 text-sm text-gray-900">
                                        {user?.first_name} {user?.last_name}
                                    </dd>
                                </div>
                                <div className="sm:col-span-1">
                                    <dt className="text-sm font-medium text-gray-500">
                                        Member Since
                                    </dt>
                                    <dd className="mt-1 text-sm text-gray-900">
                                        {new Date().toLocaleDateString()} {/* You might want to get this from user data */}
                                    </dd>
                                </div>
                            </dl>
                        </div>
                    </div>

                    {/* Learning Tips */}
                    <div className="mt-6 bg-blue-50 border-l-4 border-blue-400 p-4 rounded">
                        <div className="flex">
                            <div className="flex-shrink-0">
                                <svg className="h-5 w-5 text-blue-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                                    <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clipRule="evenodd" />
                                </svg>
                            </div>
                            <div className="ml-3">
                                <p className="text-sm text-blue-700">
                                    <strong>Learning Tip:</strong> Our teaching-first approach shows you concepts first, 
                                    then generates questions based on what you learned. Take your time with each concept!
                                </p>
                            </div>
                        </div>
                    </div>
                </div>
            </main>
        </div>
    );
};

export default Dashboard;


================================================
FILE: frontend/src/components/Home.jsx
================================================
Error reading file with 'cp1252': 'charmap' codec can't decode byte 0x9d in position 3592: character maps to <undefined>


================================================
FILE: frontend/src/components/Login.jsx
================================================
import React, { useState } from 'react';
import { useNavigate, Link } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';

const Login = () => {
    const [formData, setFormData] = useState({
        username: '',
        password: ''
    });
    const [error, setError] = useState('');
    const [loading, setLoading] = useState(false);
    
    const { login } = useAuth();
    const navigate = useNavigate();

    const handleChange = (e) => {
        setFormData({
            ...formData,
            [e.target.name]: e.target.value
        });
    };

    const handleSubmit = async (e) => {
        e.preventDefault();
        setError('');
        setLoading(true);

        const result = await login(formData.username, formData.password);
        
        if (result.success) {
            navigate('/dashboard');
        } else {
            setError(result.error);
        }
        
        setLoading(false);
    };

    return (
        <div className="min-h-screen flex items-center justify-center bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
            <div className="max-w-md w-full space-y-8">
                <div>
                    <h2 className="mt-6 text-center text-3xl font-extrabold text-gray-900">
                        Sign in to your account
                    </h2>
                    <p className="mt-2 text-center text-sm text-gray-600">
                        Or{' '}
                        <Link to="/register" className="font-medium text-blue-600 hover:text-blue-500">
                            create a new account
                        </Link>
                    </p>
                </div>
                
                {error && (
                    <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative" role="alert">
                        <span className="block sm:inline">{error}</span>
                    </div>
                )}
                
                <form className="mt-8 space-y-6" onSubmit={handleSubmit}>
                    <div className="rounded-md shadow-sm -space-y-px">
                        <div>
                            <label htmlFor="username" className="sr-only">Username or Email</label>
                            <input
                                id="username"
                                name="username"
                                type="text"
                                required
                                className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-t-md focus:outline-none focus:ring-blue-500 focus:border-blue-500 focus:z-10 sm:text-sm"
                                placeholder="Username or Email"
                                value={formData.username}
                                onChange={handleChange}
                            />
                        </div>
                        <div>
                            <label htmlFor="password" className="sr-only">Password</label>
                            <input
                                id="password"
                                name="password"
                                type="password"
                                required
                                className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-b-md focus:outline-none focus:ring-blue-500 focus:border-blue-500 focus:z-10 sm:text-sm"
                                placeholder="Password"
                                value={formData.password}
                                onChange={handleChange}
                            />
                        </div>
                    </div>

                    <div>
                        <button
                            type="submit"
                            disabled={loading}
                            className="group relative w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50"
                        >
                            {loading ? 'Signing in...' : 'Sign in'}
                        </button>
                    </div>
                </form>
            </div>
        </div>
    );
};

export default Login;


================================================
FILE: frontend/src/components/ProtectedRoute.jsx
================================================
import React from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';

const ProtectedRoute = ({ children }) => {
    const { user, loading } = useAuth();
    const location = useLocation();

    console.log("ProtectedRoute - Auth state:", { user: !!user, loading });

    if (loading) {
        return (
            <div className="min-h-screen flex items-center justify-center">
                <div className="text-xl text-gray-600">Loading...</div>
            </div>
        );
    }

    if (!user) {
        // Save the location they were trying to go to
        return <Navigate to="/login" state={{ from: location.pathname }} replace />;
    }

    return children;
};

export default ProtectedRoute;


================================================
FILE: frontend/src/components/Register.jsx
================================================
import React, { useState } from 'react';
import { useNavigate, Link } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';

const Register = () => {
    const [formData, setFormData] = useState({
        username: '',
        email: '',
        first_name: '',
        last_name: '',
        password: '',
        password2: ''
    });
    const [errors, setErrors] = useState({});
    const [loading, setLoading] = useState(false);
    
    const { register } = useAuth();
    const navigate = useNavigate();

    const handleChange = (e) => {
        setFormData({
            ...formData,
            [e.target.name]: e.target.value
        });
    };

    const handleSubmit = async (e) => {
        e.preventDefault();
        setErrors({});
        setLoading(true);

        const result = await register(formData);
        
        if (result.success) {
            navigate('/login', { state: { message: 'Registration successful! Please login.' } });
        } else {
            setErrors(result.error);
        }
        
        setLoading(false);
    };

    return (
        <div className="min-h-screen flex items-center justify-center bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
            <div className="max-w-md w-full space-y-8">
                <div>
                    <h2 className="mt-6 text-center text-3xl font-extrabold text-gray-900">
                        Create your account
                    </h2>
                    <p className="mt-2 text-center text-sm text-gray-600">
                        Or{' '}
                        <Link to="/login" className="font-medium text-blue-600 hover:text-blue-500">
                            sign in to existing account
                        </Link>
                    </p>
                </div>
                
                <form className="mt-8 space-y-6" onSubmit={handleSubmit}>
                    <div className="space-y-4">
                        <div>
                            <label htmlFor="username" className="block text-sm font-medium text-gray-700">
                                Username *
                            </label>
                            <input
                                id="username"
                                name="username"
                                type="text"
                                required
                                className="mt-1 appearance-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-md focus:outline-none focus:ring-blue-500 focus:border-blue-500 focus:z-10 sm:text-sm"
                                value={formData.username}
                                onChange={handleChange}
                            />
                            {errors.username && (
                                <p className="mt-1 text-sm text-red-600">{errors.username[0]}</p>
                            )}
                        </div>

                        <div>
                            <label htmlFor="email" className="block text-sm font-medium text-gray-700">
                                Email *
                            </label>
                            <input
                                id="email"
                                name="email"
                                type="email"
                                required
                                className="mt-1 appearance-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-md focus:outline-none focus:ring-blue-500 focus:border-blue-500 focus:z-10 sm:text-sm"
                                value={formData.email}
                                onChange={handleChange}
                            />
                            {errors.email && (
                                <p className="mt-1 text-sm text-red-600">{errors.email[0]}</p>
                            )}
                        </div>

                        <div className="grid grid-cols-2 gap-4">
                            <div>
                                <label htmlFor="first_name" className="block text-sm font-medium text-gray-700">
                                    First Name *
                                </label>
                                <input
                                    id="first_name"
                                    name="first_name"
                                    type="text"
                                    required
                                    className="mt-1 appearance-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-md focus:outline-none focus:ring-blue-500 focus:border-blue-500 focus:z-10 sm:text-sm"
                                    value={formData.first_name}
                                    onChange={handleChange}
                                />
                            </div>

                            <div>
                                <label htmlFor="last_name" className="block text-sm font-medium text-gray-700">
                                    Last Name *
                                </label>
                                <input
                                    id="last_name"
                                    name="last_name"
                                    type="text"
                                    required
                                    className="mt-1 appearance-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-md focus:outline-none focus:ring-blue-500 focus:border-blue-500 focus:z-10 sm:text-sm"
                                    value={formData.last_name}
                                    onChange={handleChange}
                                />
                            </div>
                        </div>

                        <div>
                            <label htmlFor="password" className="block text-sm font-medium text-gray-700">
                                Password *
                            </label>
                            <input
                                id="password"
                                name="password"
                                type="password"
                                required
                                className="mt-1 appearance-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-md focus:outline-none focus:ring-blue-500 focus:border-blue-500 focus:z-10 sm:text-sm"
                                value={formData.password}
                                onChange={handleChange}
                            />
                            {errors.password && (
                                <p className="mt-1 text-sm text-red-600">{errors.password[0]}</p>
                            )}
                        </div>

                        <div>
                            <label htmlFor="password2" className="block text-sm font-medium text-gray-700">
                                Confirm Password *
                            </label>
                            <input
                                id="password2"
                                name="password2"
                                type="password"
                                required
                                className="mt-1 appearance-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-md focus:outline-none focus:ring-blue-500 focus:border-blue-500 focus:z-10 sm:text-sm"
                                value={formData.password2}
                                onChange={handleChange}
                            />
                        </div>
                    </div>

                    {errors.non_field_errors && (
                        <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative">
                            <span className="block sm:inline">{errors.non_field_errors[0]}</span>
                        </div>
                    )}

                    <div>
                        <button
                            type="submit"
                            disabled={loading}
                            className="group relative w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50"
                        >
                            {loading ? 'Creating account...' : 'Create account'}
                        </button>
                    </div>
                </form>
            </div>
        </div>
    );
};

export default Register;


================================================
FILE: frontend/src/components/Learning/AtomComplete.jsx
================================================
Error reading file with 'cp1252': 'charmap' codec can't decode byte 0x8f in position 6682: character maps to <undefined>


================================================
FILE: frontend/src/components/Learning/AtomList.jsx
================================================
import React from 'react';

const AtomList = ({ atoms, onStartAtom, conceptName, completedCount }) => {
    const getPhaseIcon = (phase) => {
        const icons = {
            'complete': '✅',
            'teaching': '📚',
            'diagnostic': '📝',
            'reinforcement': '🔄',
            'not_started': '⭕'
        };
        return icons[phase] || '📌';
    };

    const getPhaseColor = (phase) => {
        const colors = {
            'complete': 'text-green-600',
            'teaching': 'text-blue-600',
            'diagnostic': 'text-purple-600',
            'reinforcement': 'text-orange-600',
            'not_started': 'text-gray-400'
        };
        return colors[phase] || 'text-gray-600';
    };

    return (
        <div className="bg-white rounded-lg shadow-lg p-8">
            <h2 className="text-2xl font-bold mb-2">{conceptName}</h2>
            <p className="text-gray-600 mb-6">
                Completed {completedCount} of {atoms.length} concepts
            </p>

            <div className="space-y-3 mb-8">
                {atoms.map((atom, index) => (
                    <div
                        key={atom.id}
                        className={`flex items-center justify-between p-4 rounded-lg border ${
                            atom.phase === 'not_started'
                                ? 'border-gray-200 bg-gray-50'
                                : atom.phase === 'complete'
                                ? 'border-green-200 bg-green-50'
                                : 'border-blue-200 bg-blue-50'
                        }`}
                    >
                        <div className="flex items-center">
                            <span className="text-2xl mr-4">{getPhaseIcon(atom.phase)}</span>
                            <div>
                                <p className="font-medium text-lg">{atom.name}</p>
                                <p className={`text-sm ${getPhaseColor(atom.phase)}`}>
                                    {atom.phase === 'complete' && '✓ Mastered'}
                                    {atom.phase === 'teaching' && '📖 Learning in progress'}
                                    {atom.phase === 'diagnostic' && '📝 Questions ready'}
                                    {atom.phase === 'not_started' && '⏳ Not started'}
                                </p>
                            </div>
                        </div>
                        
                        {atom.phase === 'not_started' && (
                            <button
                                onClick={() => onStartAtom(atom)}
                                className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
                            >
                                Start Learning
                            </button>
                        )}
                        
                        {atom.phase === 'teaching' && (
                            <span className="text-blue-600 font-medium">In Progress</span>
                        )}
                        
                        {atom.phase === 'diagnostic' && (
                            <button
                                onClick={() => onStartAtom(atom)}
                                className="px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700"
                            >
                                Continue
                            </button>
                        )}
                        
                        {atom.phase === 'complete' && (
                            <span className="text-green-600 font-medium">✓ Completed</span>
                        )}
                    </div>
                ))}
            </div>
        </div>
    );
};

export default AtomList;


================================================
FILE: frontend/src/components/Learning/LearningProgress.jsx
================================================
import React, { useEffect } from 'react';
import { useLearning } from '../../context/LearningContext';

const LearningProgress = ({ onContinue }) => {
    const { learningProgress, loadLearningProgress, loading } = useLearning();

    useEffect(() => {
        loadLearningProgress();
    }, [loadLearningProgress]);

    const getPhaseIcon = (phase) => {
        const icons = {
            complete: '✅',
            mastery_check: '🔄',
            practice: '📝',
            teaching: '📚',
            reinforcement: '⚠️',
            diagnostic: '⏳'
        };
        return icons[phase] || '📌';
    };

    const getPhaseColor = (phase) => {
        const colors = {
            complete: 'text-green-600',
            mastery_check: 'text-blue-600',
            practice: 'text-purple-600',
            teaching: 'text-orange-600',
            reinforcement: 'text-red-600',
            diagnostic: 'text-gray-600'
        };
        return colors[phase] || 'text-gray-600';
    };

    if (loading && !learningProgress) {
        return (
            <div className="text-center py-12">
                <p className="text-gray-600">Loading progress...</p>
            </div>
        );
    }

    if (!learningProgress) {
        return (
            <div className="text-center py-12">
                <p className="text-red-600">Failed to load progress.</p>
            </div>
        );
    }

    return (
        <div className="max-w-4xl mx-auto">
            <h2 className="text-3xl font-bold mb-8">Your Learning Progress</h2>

            <div className="bg-white rounded-lg shadow-lg p-8 mb-8">
                <div className="grid grid-cols-2 gap-8 mb-8">
                    <div className="text-center">
                        <p className="text-gray-600 mb-2">Overall Mastery</p>
                        <div className="relative pt-1">
                            <div className="flex mb-2 items-center justify-between">
                                <div>
                                    <span className="text-xs font-semibold inline-block py-1 px-2 uppercase rounded-full text-green-600 bg-green-200">
                                        Progress
                                    </span>
                                </div>
                                <div className="text-right">
                                    <span className="text-xs font-semibold inline-block text-green-600">
                                        {Math.round(learningProgress.overall_mastery * 100)}%
                                    </span>
                                </div>
                            </div>
                            <div className="overflow-hidden h-2 mb-4 text-xs flex rounded bg-green-200">
                                <div
                                    style={{ width: `${learningProgress.overall_mastery * 100}%` }}
                                    className="shadow-none flex flex-col text-center whitespace-nowrap text-white justify-center bg-green-500"
                                ></div>
                            </div>
                        </div>
                    </div>
                    
                    <div className="text-center">
                        <p className="text-gray-600 mb-2">Learning Streak</p>
                        <p className="text-3xl font-bold text-orange-500">
                            {learningProgress.learning_streak || 0} 🔥
                        </p>
                    </div>
                </div>

                <div className="grid grid-cols-3 gap-4 mb-8">
                    <div className="bg-blue-50 p-4 rounded-lg text-center">
                        <p className="text-2xl font-bold text-blue-600">
                            {learningProgress.total_atoms || 0}
                        </p>
                        <p className="text-sm text-gray-600">Total Atoms</p>
                    </div>
                    
                    <div className="bg-green-50 p-4 rounded-lg text-center">
                        <p className="text-2xl font-bold text-green-600">
                            {learningProgress.concepts?.reduce((acc, c) => acc + c.mastered_count, 0) || 0}
                        </p>
                        <p className="text-sm text-gray-600">Mastered</p>
                    </div>
                    
                    <div className="bg-purple-50 p-4 rounded-lg text-center">
                        <p className="text-2xl font-bold text-purple-600">
                            {learningProgress.concepts?.length || 0}
                        </p>
                        <p className="text-sm text-gray-600">Concepts</p>
                    </div>
                </div>
            </div>

            <h3 className="text-xl font-bold mb-4">Concepts</h3>
            
            {learningProgress.concepts?.map((concept, idx) => (
                <div key={idx} className="bg-white rounded-lg shadow-lg p-6 mb-4">
                    <div className="flex justify-between items-center mb-4">
                        <h4 className="text-lg font-semibold">{concept.name}</h4>
                        <span className="text-sm text-gray-500">
                            {concept.mastered_count}/{concept.total_count} mastered
                        </span>
                    </div>

                    <div className="space-y-3">
                        {concept.atoms.map((atom, atomIdx) => (
                            <div key={atomIdx} className="flex items-center justify-between p-3 bg-gray-50 rounded-lg">
                                <div className="flex items-center">
                                    <span className="text-xl mr-3">{getPhaseIcon(atom.phase)}</span>
                                    <div>
                                        <p className="font-medium">{atom.name}</p>
                                        <p className="text-xs text-gray-500">
                                            Mastery: {Math.round(atom.mastery * 100)}%
                                            {atom.streak > 0 && ` • Streak: ${atom.streak}`}
                                            {atom.hint_usage > 0 && ` • Hints: ${atom.hint_usage}`}
                                        </p>
                                    </div>
                                </div>
                                <span className={`text-sm font-medium ${getPhaseColor(atom.phase)}`}>
                                    {atom.phase.replace('_', ' ')}
                                </span>
                            </div>
                        ))}
                    </div>
                </div>
            ))}

            <div className="flex justify-center mt-8">
                <button
                    onClick={onContinue}
                    className="bg-blue-600 text-white px-8 py-3 rounded-lg font-semibold hover:bg-blue-700"
                >
                    Continue Learning
                </button>
            </div>

            <div className="mt-6 text-sm text-gray-500 text-center">
                <p>ℹ️ Keep practicing to maintain retention and build streaks!</p>
            </div>
        </div>
    );
};

export default LearningProgress;


================================================
FILE: frontend/src/components/Learning/LearningRoute.jsx
================================================
import React from 'react';
import { useParams, useLocation, useNavigate } from 'react-router-dom';
import { LearningProvider } from '../../context/LearningContext';
import TeachingFirstFlow from './TeachingFirstFlow';

const LearningRoute = () => {
    const params = useParams();
    const location = useLocation();
    const navigate = useNavigate();
    
    // Log everything
    console.log("=== LearningRoute Debug ===");
    console.log("Full params object:", params);
    console.log("Location pathname:", location.pathname);
    console.log("Location search:", location.search);
    console.log("Location state:", location.state);
    console.log("conceptId from params:", params.conceptId);
    
    // Try to get conceptId from different sources
    let conceptId = params.conceptId;
    
    // If not in params, try to get from state
    if (!conceptId && location.state?.conceptId) {
        conceptId = location.state.conceptId;
        console.log("Got conceptId from state:", conceptId);
    }
    
    // If still no conceptId, try to extract from pathname
    if (!conceptId) {
        const pathParts = location.pathname.split('/');
        const lastPart = pathParts[pathParts.length - 1];
        if (lastPart && lastPart !== 'learn' && !isNaN(parseInt(lastPart))) {
            conceptId = lastPart;
            console.log("Extracted conceptId from pathname:", conceptId);
        }
    }
    
    console.log("Final conceptId:", conceptId);
    
    if (conceptId) {
        return (
            <LearningProvider>
                <TeachingFirstFlow conceptId={parseInt(conceptId)} />
            </LearningProvider>
        );
    }

    return (
        <LearningProvider>
            <div className="text-center py-12">
                <p className="text-red-600">No concept selected. Please go back and try again.</p>
                <p className="text-gray-500 mt-2">URL: {location.pathname}</p>
                <p className="text-gray-500">Params: {JSON.stringify(params)}</p>
                <button 
                    onClick={() => navigate('/dashboard')}
                    className="mt-4 px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
                >
                    Go to Dashboard
                </button>
            </div>
        </LearningProvider>
    );
};

export default LearningRoute;


================================================
FILE: frontend/src/components/Learning/QuestionsFromTeaching.jsx
================================================
Error reading file with 'cp1252': 'charmap' codec can't decode byte 0x9d in position 1995: character maps to <undefined>


================================================
FILE: frontend/src/components/Learning/StartAnyConceptSession.jsx
================================================
Error reading file with 'cp1252': 'charmap' codec can't decode byte 0x90 in position 11320: character maps to <undefined>


================================================
FILE: frontend/src/components/Learning/StartAnyConceptSessionRoute.jsx
================================================
import React from 'react';
import { LearningProvider } from '../../context/LearningContext';
import StartAnyConceptSession from './StartAnyConceptSession';

const StartAnyConceptSessionRoute = () => {
    return (
        <LearningProvider>
            <StartAnyConceptSession />
        </LearningProvider>
    );
};

export default StartAnyConceptSessionRoute;



================================================
FILE: frontend/src/components/Learning/TeachingFirstFlow.jsx
================================================
Error reading file with 'cp1252': 'charmap' codec can't decode byte 0x90 in position 8808: character maps to <undefined>


================================================
FILE: frontend/src/components/Learning/TeachingModule.jsx
================================================
Error reading file with 'cp1252': 'charmap' codec can't decode byte 0x8f in position 3115: character maps to <undefined>


================================================
FILE: frontend/src/context/AuthContext.jsx
================================================
import React, { createContext, useState, useContext, useEffect } from 'react';
import axios from '../axiosConfig';
import { useNavigate } from 'react-router-dom';

const AuthContext = createContext(null);

export const AuthProvider = ({ children }) => {
    const [user, setUser] = useState(null);
    const [loading, setLoading] = useState(true);
    const navigate = useNavigate();

    // Check for existing token on mount
    useEffect(() => {
        const token = localStorage.getItem('access_token');
        if (token) {
            // Verify token by fetching user data
            fetchUser();
        } else {
            setLoading(false);
        }
    }, []);

    const fetchUser = async () => {
        try {
            const response = await axios.get('/auth/api/dashboard/');
            setUser(response.data.user);
        } catch (error) {
            console.error("Failed to fetch user:", error);
            localStorage.removeItem('access_token');
            localStorage.removeItem('refresh_token');
        } finally {
            setLoading(false);
        }
    };

    const login = async (username, password) => {
        try {
            const response = await axios.post('/auth/api/login/', {
                username,
                password
            });
            
            const { access, refresh, user } = response.data;
            
            localStorage.setItem('access_token', access);
            localStorage.setItem('refresh_token', refresh);
            setUser(user);
            
            return { success: true };
        } catch (error) {
            return { 
                success: false, 
                error: error.response?.data?.error || 'Login failed' 
            };
        }
    };

    const register = async (userData) => {
        try {
            const response = await axios.post('/auth/api/register/', userData);
            return { success: true, data: response.data };
        } catch (error) {
            return { 
                success: false, 
                error: error.response?.data || 'Registration failed' 
            };
        }
    };

    const logout = () => {
        localStorage.removeItem('access_token');
        localStorage.removeItem('refresh_token');
        setUser(null);
        navigate('/login');
    };

    const value = {
        user,
        login,
        register,
        logout,
        loading
    };

    return (
        <AuthContext.Provider value={value}>
            {children}
        </AuthContext.Provider>
    );
};

export const useAuth = () => {
    const context = useContext(AuthContext);
    if (!context) {
        throw new Error('useAuth must be used within an AuthProvider');
    }
    return context;
};


================================================
FILE: frontend/src/context/LearningContext.jsx
================================================
import React, { createContext, useCallback, useMemo, useState, useContext } from 'react';
import axios from '../axiosConfig';

const LearningContext = createContext(null);

export const LearningProvider = ({ children }) => {
    const [currentSession, setCurrentSession] = useState(null);
    const [diagnosticResults, setDiagnosticResults] = useState(null);
    const [currentAtom, setCurrentAtom] = useState(null);
    const [learningProgress, setLearningProgress] = useState(null);
    const [loading, setLoading] = useState(false);
    const [knowledgeLevel, setKnowledgeLevel] = useState('intermediate');
    const [learningPace, setLearningPace] = useState('normal');
    const [masteryData, setMasteryData] = useState({});

    const normalizePositiveInt = (value) => {
        const num = typeof value === 'string' ? Number(value) : value;
        if (!Number.isInteger(num) || num <= 0) return null;
        return num;
    };

    // NEW TEACHING-FIRST FLOW METHODS

    const generateConcept = useCallback(async (subject, concept, knowledgeLevel = 'intermediate') => {
    setLoading(true);
    try {
        const response = await axios.post('/auth/api/generate-concept/', {
            subject: subject,
            concept: concept,
            knowledge_level: knowledgeLevel
        });
        return { success: true, data: response.data };
    } catch (error) {
        return {
            success: false,
            error: error.response?.data?.error || 'Failed to generate concept'
        };
    } finally {
        setLoading(false);
    }
}, []);

    // In LearningContext.jsx, add logging to each API call
const startTeachingSession = useCallback(async (conceptId, level = 'intermediate') => {
    setLoading(true);
    setKnowledgeLevel(level);
    try {
        console.log("Making API call to start-teaching-session with:", { conceptId, level });
        
        // Check token before making request
        const token = localStorage.getItem('access_token');
        console.log("Token present:", !!token);
        
        const response = await axios.post('/auth/api/start-teaching-session/', {
            concept_id: conceptId,
            knowledge_level: level
        });
        
        console.log("API Response - startTeachingSession:", response.data);
        setCurrentSession(response.data);
        return { success: true, data: response.data };
    } catch (error) {
        console.error("API Error - startTeachingSession:", {
            status: error.response?.status,
            data: error.response?.data,
            message: error.message
        });
        
        // If 401, token might be expired
        if (error.response?.status === 401) {
            // Clear tokens and redirect will happen via interceptor
            console.log("Received 401 - token may be expired");
        }
        
        return {
            success: false,
            error: error.response?.data?.error || 'Failed to start session'
        };
    } finally {
        setLoading(false);
    }
}, []);

    const getAtomList = useCallback(async (conceptId) => {
        try {
            const response = await axios.get(`/auth/api/concepts/${conceptId}/atoms-list/`);
            return { success: true, data: response.data };
        } catch (error) {
            return {
                success: false,
                error: error.response?.data?.error || 'Failed to get atoms'
            };
        }
    }, []);

    const getTeachingContent = useCallback(async (atomId) => {
        const normalizedAtomId = normalizePositiveInt(atomId);
        if (normalizedAtomId === null) {
            return { success: false, error: 'Invalid atom id. Please restart the session step.' };
        }

        setLoading(true);
        try {
            const response = await axios.get(`/auth/api/teaching/${normalizedAtomId}/`);
            setCurrentAtom({
                id: normalizedAtomId,
                ...response.data
            });
            return { success: true, data: response.data };
        } catch (error) {
            return {
                success: false,
                error: error.response?.data?.error || 'Failed to get teaching content'
            };
        } finally {
            setLoading(false);
        }
    }, []);

    const generateQuestionsFromTeaching = useCallback(async (sessionId, atomId) => {
        setLoading(true);
        try {
            const response = await axios.post('/auth/api/generate-questions-from-teaching/', {
                session_id: sessionId,
                atom_id: atomId
            });
            return { success: true, data: response.data };
        } catch (error) {
            return {
                success: false,
                error: error.response?.data?.error || 'Failed to generate questions'
            };
        } finally {
            setLoading(false);
        }
    }, []);

    const submitAtomAnswer = useCallback(async (sessionId, atomId, questionIndex, selected, timeTaken) => {
        try {
            const response = await axios.post('/auth/api/submit-atom-answer/', {
                session_id: sessionId,
                atom_id: atomId,
                question_index: questionIndex,
                selected: selected,
                time_taken: timeTaken
            });
            return { success: true, data: response.data };
        } catch (error) {
            return {
                success: false,
                error: error.response?.data?.error || 'Failed to submit answer'
            };
        }
    }, []);

    // In LearningContext.jsx
const completeAtom = useCallback(async (sessionId, atomId, continueLearning) => {
    try {
        console.log("Calling completeAtom with:", { sessionId, atomId, continueLearning });
        
        const response = await axios.post('/auth/api/complete-atom/', {
            session_id: sessionId,
            atom_id: atomId,
            continue_learning: continueLearning
        });
        
        console.log("completeAtom response:", response.data);
        return { success: true, data: response.data };
    } catch (error) {
        console.error("completeAtom error:", error.response?.data || error.message);
        return {
            success: false,
            error: error.response?.data?.error || 'Failed to complete atom'
        };
    }
}, []);

    // Practice methods (keep these for reinforcement)
    const getPracticeQuestions = useCallback(async (atomId, difficulty = 'easy', count = 3) => {
        setLoading(true);
        try {
            const response = await axios.get(
                `/auth/api/practice/${atomId}/?difficulty=${difficulty}&count=${count}`
            );
            return { success: true, data: response.data };
        } catch (error) {
            return {
                success: false,
                error: error.response?.data?.error || 'Failed to get practice questions'
            };
        } finally {
            setLoading(false);
        }
    }, []);

    const submitPracticeAnswer = useCallback(async (questionId, selected, timeTaken, hintUsed = false) => {
        try {
            const response = await axios.post('/auth/api/submit-answer/', {
                question_id: questionId,
                selected: selected,
                time_taken: timeTaken,
                hint_used: hintUsed
            });
            return { success: true, data: response.data };
        } catch (error) {
            return {
                success: false,
                error: error.response?.data?.error || 'Failed to submit answer'
            };
        }
    }, []);

    const getHint = useCallback(async (questionId, errorCount = 0) => {
        try {
            const response = await axios.post('/auth/api/get-hint/', {
                question_id: questionId,
                error_count: errorCount
            });
            return { success: true, data: response.data };
        } catch (error) {
            return {
                success: false,
                error: error.response?.data?.error || 'Failed to get hint'
            };
        }
    }, []);

    const loadLearningProgress = useCallback(async () => {
        setLoading(true);
        try {
            const response = await axios.get('/auth/api/progress/');
            setLearningProgress(response.data);
            return { success: true, data: response.data };
        } catch (error) {
            return {
                success: false,
                error: error.response?.data?.error || 'Failed to load progress'
            };
        } finally {
            setLoading(false);
        }
    }, []);

    const getMasteryRecommendation = useCallback((atomId) => {
        const data = masteryData[atomId];
        if (!data) return { action: 'proceed', confidence: 'high' };
        
        if (data.status === 'needs_attention' && data.attempts > 2) {
            return { action: 'review', confidence: 'low' };
        }
        
        return { action: 'proceed', confidence: 'medium' };
    }, [masteryData]);

    const value = useMemo(() => ({
        // State
        currentSession,
        diagnosticResults,
        currentAtom,
        learningProgress,
        loading,
        knowledgeLevel,
        learningPace,
        masteryData,
        
        // Setters
        setKnowledgeLevel,
        
        // Teaching-first flow methods
        generateConcept,
        startTeachingSession,
        getAtomList,
        getTeachingContent,
        generateQuestionsFromTeaching,
        submitAtomAnswer,
        completeAtom,
        
        // Practice methods
        getPracticeQuestions,
        submitPracticeAnswer,
        getHint,
        loadLearningProgress,
        getMasteryRecommendation
    }), [
        // State dependencies
        currentSession,
        diagnosticResults,
        currentAtom,
        learningProgress,
        loading,
        knowledgeLevel,
        learningPace,
        masteryData,
        
        // Method dependencies
        generateConcept,    
        startTeachingSession,
        getAtomList,
        getTeachingContent,
        generateQuestionsFromTeaching,
        submitAtomAnswer,
        completeAtom,
        getPracticeQuestions,
        submitPracticeAnswer,
        getHint,
        loadLearningProgress,
        getMasteryRecommendation
    ]);

    return (
        <LearningContext.Provider value={value}>
            {children}
        </LearningContext.Provider>
    );
};

export const useLearning = () => {
    const context = useContext(LearningContext);
    if (!context) {
        throw new Error('useLearning must be used within a LearningProvider');
    }
    return context;
};

