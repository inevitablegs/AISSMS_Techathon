Directory structure:
└── Final/
    ├── tempCodeRunnerFile.python
    ├── backend/
    │   ├── a.py
    │   ├── manage.py
    │   ├── req
    │   ├── accounts/
    │   │   ├── __init__.py
    │   │   ├── admin.py
    │   │   ├── apps.py
    │   │   ├── models.py
    │   │   ├── serializers.py
    │   │   ├── tests.py
    │   │   ├── urls.py
    │   │   ├── views.py
    │   │   └── migrations/
    │   │       ├── 0001_initial.py
    │   │       ├── 0002_concept_created_by.py
    │   │       ├── 0003_learningsession_knowledge_level_and_more.py
    │   │       ├── 0004_add_error_history_default.py
    │   │       └── __init__.py
    │   ├── core/
    │   │   ├── __init__.py
    │   │   ├── asgi.py
    │   │   ├── settings.py
    │   │   ├── urls.py
    │   │   └── wsgi.py
    │   └── learning_engine/
    │       ├── __init__.py
    │       ├── adaptive_flow.py
    │       ├── knowledge_tracing.py
    │       ├── models.py
    │       ├── pacing_engine.py
    │       ├── question_generator.py
    │       └── utils.py
    └── frontend/
        ├── README.md
        ├── eslint.config.js
        ├── index.html
        ├── package.json
        ├── postcss.config.js
        ├── tailwind.config.js
        ├── vite.config.js
        └── src/
            ├── App.css
            ├── App.jsx
            ├── axiosConfig.js
            ├── index.css
            ├── main.jsx
            ├── components/
            │   ├── Dashboard.jsx
            │   ├── Home.jsx
            │   ├── Login.jsx
            │   ├── ProtectedRoute.jsx
            │   ├── Register.jsx
            │   └── Learning/
            │       ├── AtomComplete.jsx
            │       ├── AtomList.jsx
            │       ├── AtomReview.jsx
            │       ├── LearningProgress.jsx
            │       ├── LearningRoute.jsx
            │       ├── QuestionsFromTeaching.jsx
            │       ├── StartAnyConceptSession.jsx
            │       ├── StartAnyConceptSessionRoute.jsx
            │       ├── TeachingFirstFlow.jsx
            │       └── TeachingModule.jsx
            └── context/
                ├── AuthContext.jsx
                └── LearningContext.jsx

================================================
FILE: tempCodeRunnerFile.python
================================================
# backend/test_question_generator.py

import os
import sys
import django

# Setup Django environment
sys.path.append(os.path.dirname(os.path.abspath(__file__)))
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'core.settings')
django.setup()

from learning_engine.question_generator import QuestionGenerator
from django.conf import settings

def test_generator():
    print("=" * 50)
    print("Testing QuestionGenerator")
    print("=" * 50)
    
    print(f"GROQ_API_KEY present: {'Yes' if settings.GROQ_API_KEY else 'No'}")
    print(f"GOOGLE_API_KEY present: {'Yes' if settings.GOOGLE_API_KEY else 'No'}")
    
    generator = QuestionGenerator()
    print(f"Groq client initialized: {'Yes' if generator.groq_client else 'No'}")
    print(f"Gemini model initialized: {'Yes' if generator.gemini_model else 'No'}")
    
    if not generator.groq_client and not generator.gemini_model:
        print("\n❌ ERROR: No AI clients available! Check your API keys.")
        return
    
    print("\n" + "=" * 50)
    print("Test 1: Generate atoms")
    print("=" * 50)
    atoms = generator.generate_atoms("Microprocessor", "Memory Organization")
    print(f"Generated atoms: {atoms}")
    
    if atoms:
        print("\n" + "=" * 50)
        print("Test 2: Generate questions for first atom")
        print("=" * 50)
        questions = generator.generate_questions(
            subject="Microprocessor",
            concept="Memory Organization",
            atom=atoms[0],
            need_easy=2,
            need_medium=2,
            knowledge_level='intermediate'
        )
        print(f"Generated {len(questions)} questions")
        for i, q in enumerate(questions):
            print(f"\nQ{i+1}: {q.get('question', 'No question')}")
            print(f"   Difficulty: {q.get('difficulty')}")
            print(f"   Cognitive: {q.get('cognitive_operation')}")
            print(f"   Time: {q.get('estimated_time')}s")
    
    print("\n" + "=" * 50)
    print("Test 3: Generate complete concept")
    print("=" * 50)
    result = generator.generate_complete_concept("Microprocessor", "Memory Organization")
    print(f"Generated concept with {len(result.get('atoms', {}))} atoms")
    for atom_name, atom_data in result['atoms'].items():
        print(f"  - {atom_name}: {len(atom_data['questions'])} questions")

if __name__ == "__main__":
    test_generator()


================================================
FILE: backend/a.py
================================================
# backend/test_question_generator.py

import os
import sys
import django

# Setup Django environment
sys.path.append(os.path.dirname(os.path.abspath(__file__)))
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'core.settings')
django.setup()

from learning_engine.question_generator import QuestionGenerator
from django.conf import settings

def test_generator():
    print("=" * 50)
    print("Testing QuestionGenerator")
    print("=" * 50)
    
    print(f"GROQ_API_KEY present: {'Yes' if settings.GROQ_API_KEY else 'No'}")
    print(f"GOOGLE_API_KEY present: {'Yes' if settings.GOOGLE_API_KEY else 'No'}")
    
    generator = QuestionGenerator()
    print(f"Groq client initialized: {'Yes' if generator.groq_client else 'No'}")
    print(f"Gemini model initialized: {'Yes' if generator.gemini_model else 'No'}")
    
    if not generator.groq_client and not generator.gemini_model:
        print("\n❌ ERROR: No AI clients available! Check your API keys.")
        return
    
    print("\n" + "=" * 50)
    print("Test 1: Generate atoms")
    print("=" * 50)
    atoms = generator.generate_atoms("Microprocessor", "Memory Organization")
    print(f"Generated atoms: {atoms}")
    
    if atoms:
        print("\n" + "=" * 50)
        print("Test 2: Generate questions for first atom")
        print("=" * 50)
        questions = generator.generate_questions(
            subject="Microprocessor",
            concept="Memory Organization",
            atom=atoms[0],
            need_easy=2,
            need_medium=2,
            knowledge_level='intermediate'
        )
        print(f"Generated {len(questions)} questions")
        for i, q in enumerate(questions):
            print(f"\nQ{i+1}: {q.get('question', 'No question')}")
            print(f"   Difficulty: {q.get('difficulty')}")
            print(f"   Cognitive: {q.get('cognitive_operation')}")
            print(f"   Time: {q.get('estimated_time')}s")
    
    print("\n" + "=" * 50)
    print("Test 3: Generate complete concept")
    print("=" * 50)
    result = generator.generate_complete_concept("Microprocessor", "Memory Organization")
    print(f"Generated concept with {len(result.get('atoms', {}))} atoms")
    for atom_name, atom_data in result['atoms'].items():
        print(f"  - {atom_name}: {len(atom_data['questions'])} questions")

if __name__ == "__main__":
    test_generator()


================================================
FILE: backend/manage.py
================================================
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'core.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()



================================================
FILE: backend/req
================================================
pip install django djangorestframework
pip install djangorestframework-simplejwt
pip install django-cors-headers



================================================
FILE: backend/accounts/__init__.py
================================================
[Empty file]


================================================
FILE: backend/accounts/admin.py
================================================
from django.contrib import admin

# Register your models here.



================================================
FILE: backend/accounts/apps.py
================================================
from django.apps import AppConfig


class AccountsConfig(AppConfig):
    name = 'accounts'



================================================
FILE: backend/accounts/models.py
================================================
from django.db import models
from django.contrib.auth.models import User
import json

class LearningProfile(models.Model):
    """Student's learning profile and progress"""
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='learning_profile')
    overall_theta = models.FloatField(default=0.0)  # IRT ability parameter
    current_subject = models.CharField(max_length=100, blank=True)
    current_concept = models.CharField(max_length=100, blank=True)
    learning_streak = models.IntegerField(default=0)
    total_time_spent = models.IntegerField(default=0)  # in minutes
    last_active = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'learning_profile'

class Concept(models.Model):
    """Learning concepts and atoms"""
    DIFFICULTY_CHOICES = [
        ('easy', 'Easy'),
        ('medium', 'Medium'),
        ('hard', 'Hard'),
    ]
    
    name = models.CharField(max_length=200)
    subject = models.CharField(max_length=100)
    created_by = models.ForeignKey(
        User,
        null=True,
        blank=True,
        on_delete=models.SET_NULL,
        related_name='created_concepts'
    )
    description = models.TextField(blank=True)
    prerequisites = models.ManyToManyField('self', symmetrical=False, blank=True)
    difficulty = models.CharField(max_length=10, choices=DIFFICULTY_CHOICES, default='medium')
    order = models.IntegerField(default=0)
    
    class Meta:
        ordering = ['subject', 'order']
        unique_together = ['name', 'subject', 'created_by']

class TeachingAtom(models.Model):
    """Atomic learning units"""
    PHASE_CHOICES = [
        ('diagnostic', 'Diagnostic'),
        ('teaching', 'Teaching'),
        ('practice', 'Practice'),
        ('reinforcement', 'Reinforcement'),
        ('mastery_check', 'Mastery Check'),
        ('complete', 'Complete'),
    ]
    
    name = models.CharField(max_length=200)
    concept = models.ForeignKey(Concept, on_delete=models.CASCADE, related_name='atoms')
    explanation = models.TextField(blank=True)
    analogy = models.TextField(blank=True)
    examples = models.JSONField(default=list)
    order = models.IntegerField(default=0)
    
    class Meta:
        ordering = ['concept', 'order']

class Question(models.Model):
    """Practice questions"""
    DIFFICULTY_CHOICES = [
        ('easy', 'Easy'),
        ('medium', 'Medium'),
        ('hard', 'Hard'),
    ]
    
    COGNITIVE_CHOICES = [
        ('recall', 'Recall'),
        ('apply', 'Apply'),
        ('analyze', 'Analyze'),
    ]
    
    atom = models.ForeignKey(TeachingAtom, on_delete=models.CASCADE, related_name='questions')
    difficulty = models.CharField(max_length=10, choices=DIFFICULTY_CHOICES)
    cognitive_operation = models.CharField(max_length=10, choices=COGNITIVE_CHOICES)
    estimated_time = models.IntegerField(default=60)  # in seconds
    question_text = models.TextField()
    options = models.JSONField(default=list)
    correct_index = models.IntegerField()
    
    def to_dict(self):
        return {
            'id': self.id,
            'difficulty': self.difficulty,
            'cognitive_operation': self.cognitive_operation,
            'estimated_time': self.estimated_time,
            'question': self.question_text,
            'options': self.options,
            'correct_index': self.correct_index,
        }

class StudentProgress(models.Model):
    """Track student progress on atoms"""
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='progress')
    atom = models.ForeignKey(TeachingAtom, on_delete=models.CASCADE)
    mastery_score = models.FloatField(default=0.3)
    phase = models.CharField(max_length=20, choices=TeachingAtom.PHASE_CHOICES, default='diagnostic')
    streak = models.IntegerField(default=0)
    hint_usage = models.IntegerField(default=0)
    error_history = models.JSONField(default=list)
    retention_verified = models.BooleanField(default=False)
    last_practiced = models.DateTimeField(auto_now=True)
    times_practiced = models.IntegerField(default=0)
    
    class Meta:
        unique_together = ['user', 'atom']


    
class KnowledgeLevel(models.TextChoices):
    ZERO = 'zero', 'Zero Knowledge'
    BEGINNER = 'beginner', 'Beginner'
    INTERMEDIATE = 'intermediate', 'Intermediate'
    ADVANCED = 'advanced', 'Advanced'


class LearningSession(models.Model):
    """Track learning sessions"""
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='learning_sessions')
    concept = models.ForeignKey(Concept, on_delete=models.CASCADE)
    start_time = models.DateTimeField(auto_now_add=True)
    end_time = models.DateTimeField(null=True, blank=True)
    questions_answered = models.IntegerField(default=0)
    correct_answers = models.IntegerField(default=0)
    hints_used = models.IntegerField(default=0)
    session_data = models.JSONField(default=dict)
    knowledge_level = models.CharField(
        max_length=20,
        choices=KnowledgeLevel.choices,
        default=KnowledgeLevel.ZERO
    )
    user_feedback = models.JSONField(default=dict)  
    






================================================
FILE: backend/accounts/serializers.py
================================================
from django.contrib.auth.models import User
from django.contrib.auth.password_validation import validate_password
from rest_framework import serializers
from rest_framework.validators import UniqueValidator

class RegisterSerializer(serializers.ModelSerializer):
    email = serializers.EmailField(
        required=True,
        validators=[UniqueValidator(queryset=User.objects.all())]
    )
    password = serializers.CharField(
        write_only=True, 
        required=True, 
        validators=[validate_password]
    )
    password2 = serializers.CharField(write_only=True, required=True)

    class Meta:
        model = User
        fields = ('username', 'password', 'password2', 'email', 'first_name', 'last_name')
        extra_kwargs = {
            'first_name': {'required': True},
            'last_name': {'required': True}
        }

    def validate(self, attrs):
        if attrs['password'] != attrs['password2']:
            raise serializers.ValidationError(
                {"password": "Password fields didn't match."}
            )
        return attrs

    def create(self, validated_data):
        user = User.objects.create(
            username=validated_data['username'],
            email=validated_data['email'],
            first_name=validated_data['first_name'],
            last_name=validated_data['last_name']
        )
        user.set_password(validated_data['password'])
        user.save()
        
        # Create learning profile for the user
        from .models import LearningProfile
        LearningProfile.objects.create(user=user)
        
        return user

class UserSerializer(serializers.ModelSerializer):
    class Meta:
        model = User
        fields = ('id', 'username', 'email', 'first_name', 'last_name')
        
        
        
from .models import (
    LearningProfile, Concept, TeachingAtom, 
    Question, StudentProgress, LearningSession
)

class ConceptSerializer(serializers.ModelSerializer):
    class Meta:
        model = Concept
        fields = ['id', 'name', 'subject', 'description', 'difficulty', 'order']

class TeachingAtomSerializer(serializers.ModelSerializer):
    class Meta:
        model = TeachingAtom
        fields = ['id', 'name', 'explanation', 'analogy', 'examples', 'order']

class QuestionSerializer(serializers.ModelSerializer):
    class Meta:
        model = Question
        fields = ['id', 'difficulty', 'cognitive_operation', 'estimated_time', 
                 'question_text', 'options', 'correct_index']

class StudentProgressSerializer(serializers.ModelSerializer):
    atom_name = serializers.CharField(source='atom.name', read_only=True)
    concept_name = serializers.CharField(source='atom.concept.name', read_only=True)
    
    class Meta:
        model = StudentProgress
        fields = ['id', 'atom_name', 'concept_name', 'mastery_score', 'phase', 
                 'streak', 'hint_usage', 'retention_verified']

class LearningSessionSerializer(serializers.ModelSerializer):
    class Meta:
        model = LearningSession
        fields = ['id', 'concept', 'start_time', 'end_time', 'questions_answered',
                 'correct_answers', 'hints_used']


================================================
FILE: backend/accounts/tests.py
================================================
from django.test import TestCase

# Create your tests here.



================================================
FILE: backend/accounts/urls.py
================================================
from django.urls import path
from .views import (
    # Auth views
    RegisterView, LoginView, DashboardView,
    
    # Concept management
    ConceptListView, GenerateConceptView,
    
    # Teaching-first flow views
    StartTeachingSessionView, GetTeachingContentView,
    GenerateQuestionsFromTeachingView, SubmitAtomAnswerView,
    CompleteAtomView, GetLearningProgressView
)

urlpatterns = [
    # Auth endpoints
    path('api/register/', RegisterView.as_view(), name='register'),
    path('api/login/', LoginView.as_view(), name='login'),
    path('api/dashboard/', DashboardView.as_view(), name='dashboard'),
    
    # Concept management
    path('api/concepts/', ConceptListView.as_view(), name='concepts'),
    path('api/generate-concept/', GenerateConceptView.as_view(), name='generate_concept'),
    
    # Teaching-first flow endpoints
    path('api/start-teaching-session/', StartTeachingSessionView.as_view(), name='start_teaching_session'),
    path('api/teaching-content/', GetTeachingContentView.as_view(), name='teaching_content'),
    path('api/generate-questions-from-teaching/', GenerateQuestionsFromTeachingView.as_view(), name='generate_questions_from_teaching'),
    path('api/submit-atom-answer/', SubmitAtomAnswerView.as_view(), name='submit_atom_answer'),
    path('api/complete-atom/', CompleteAtomView.as_view(), name='complete_atom'),
    
    # Progress
    path('api/progress/', GetLearningProgressView.as_view(), name='learning_progress'),
]


================================================
FILE: backend/accounts/views.py
================================================
Error reading file with 'cp1252': 'charmap' codec can't decode byte 0x8f in position 41483: character maps to <undefined>


================================================
FILE: backend/accounts/migrations/0001_initial.py
================================================
# Generated by Django 6.0.2 on 2026-02-16 10:28

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='Concept',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=200)),
                ('subject', models.CharField(max_length=100)),
                ('description', models.TextField(blank=True)),
                ('difficulty', models.CharField(choices=[('easy', 'Easy'), ('medium', 'Medium'), ('hard', 'Hard')], default='medium', max_length=10)),
                ('order', models.IntegerField(default=0)),
                ('prerequisites', models.ManyToManyField(blank=True, to='accounts.concept')),
            ],
            options={
                'ordering': ['subject', 'order'],
                'unique_together': {('name', 'subject')},
            },
        ),
        migrations.CreateModel(
            name='LearningProfile',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('overall_theta', models.FloatField(default=0.0)),
                ('current_subject', models.CharField(blank=True, max_length=100)),
                ('current_concept', models.CharField(blank=True, max_length=100)),
                ('learning_streak', models.IntegerField(default=0)),
                ('total_time_spent', models.IntegerField(default=0)),
                ('last_active', models.DateTimeField(auto_now=True)),
                ('user', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, related_name='learning_profile', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'db_table': 'learning_profile',
            },
        ),
        migrations.CreateModel(
            name='LearningSession',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('start_time', models.DateTimeField(auto_now_add=True)),
                ('end_time', models.DateTimeField(blank=True, null=True)),
                ('questions_answered', models.IntegerField(default=0)),
                ('correct_answers', models.IntegerField(default=0)),
                ('hints_used', models.IntegerField(default=0)),
                ('session_data', models.JSONField(default=dict)),
                ('concept', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='accounts.concept')),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='learning_sessions', to=settings.AUTH_USER_MODEL)),
            ],
        ),
        migrations.CreateModel(
            name='TeachingAtom',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=200)),
                ('explanation', models.TextField(blank=True)),
                ('analogy', models.TextField(blank=True)),
                ('examples', models.JSONField(default=list)),
                ('order', models.IntegerField(default=0)),
                ('concept', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='atoms', to='accounts.concept')),
            ],
            options={
                'ordering': ['concept', 'order'],
            },
        ),
        migrations.CreateModel(
            name='Question',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('difficulty', models.CharField(choices=[('easy', 'Easy'), ('medium', 'Medium'), ('hard', 'Hard')], max_length=10)),
                ('cognitive_operation', models.CharField(choices=[('recall', 'Recall'), ('apply', 'Apply'), ('analyze', 'Analyze')], max_length=10)),
                ('estimated_time', models.IntegerField(default=60)),
                ('question_text', models.TextField()),
                ('options', models.JSONField(default=list)),
                ('correct_index', models.IntegerField()),
                ('atom', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='questions', to='accounts.teachingatom')),
            ],
        ),
        migrations.CreateModel(
            name='StudentProgress',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('mastery_score', models.FloatField(default=0.3)),
                ('phase', models.CharField(choices=[('diagnostic', 'Diagnostic'), ('teaching', 'Teaching'), ('practice', 'Practice'), ('reinforcement', 'Reinforcement'), ('mastery_check', 'Mastery Check'), ('complete', 'Complete')], default='diagnostic', max_length=20)),
                ('streak', models.IntegerField(default=0)),
                ('hint_usage', models.IntegerField(default=0)),
                ('error_history', models.JSONField(default=list)),
                ('retention_verified', models.BooleanField(default=False)),
                ('last_practiced', models.DateTimeField(auto_now=True)),
                ('times_practiced', models.IntegerField(default=0)),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='progress', to=settings.AUTH_USER_MODEL)),
                ('atom', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='accounts.teachingatom')),
            ],
            options={
                'unique_together': {('user', 'atom')},
            },
        ),
    ]



================================================
FILE: backend/accounts/migrations/0002_concept_created_by.py
================================================
# Generated by GitHub Copilot on 2026-02-17

from django.conf import settings
from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):

    dependencies = [
        ('accounts', '0001_initial'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.AddField(
            model_name='concept',
            name='created_by',
            field=models.ForeignKey(
                blank=True,
                null=True,
                on_delete=django.db.models.deletion.SET_NULL,
                related_name='created_concepts',
                to=settings.AUTH_USER_MODEL,
            ),
        ),
        migrations.AlterUniqueTogether(
            name='concept',
            unique_together={('name', 'subject', 'created_by')},
        ),
    ]



================================================
FILE: backend/accounts/migrations/0003_learningsession_knowledge_level_and_more.py
================================================
# Generated by Django 6.0.2 on 2026-02-17 12:58

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('accounts', '0002_concept_created_by'),
    ]

    operations = [
        migrations.AddField(
            model_name='learningsession',
            name='knowledge_level',
            field=models.CharField(choices=[('zero', 'Zero Knowledge'), ('beginner', 'Beginner'), ('intermediate', 'Intermediate'), ('advanced', 'Advanced')], default='zero', max_length=20),
        ),
        migrations.AddField(
            model_name='learningsession',
            name='user_feedback',
            field=models.JSONField(default=dict),
        ),
    ]



================================================
FILE: backend/accounts/migrations/0004_add_error_history_default.py
================================================
# In accounts/migrations/0004_add_error_history_default.py
from django.db import migrations, models

class Migration(migrations.Migration):
    dependencies = [
        ('accounts', '0003_learningsession_knowledge_level_and_more'),
    ]

    operations = [
        migrations.AlterField(
            model_name='studentprogress',
            name='error_history',
            field=models.JSONField(default=list),
        ),
    ]


================================================
FILE: backend/accounts/migrations/__init__.py
================================================
[Empty file]


================================================
FILE: backend/core/__init__.py
================================================
import os
import sys

# Add the backend directory to path
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
if BASE_DIR not in sys.path:
    sys.path.append(BASE_DIR)


================================================
FILE: backend/core/asgi.py
================================================
"""
ASGI config for core project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/6.0/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'core.settings')

application = get_asgi_application()



================================================
FILE: backend/core/settings.py
================================================
import os
from datetime import timedelta
from pathlib import Path

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/6.0/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-gq5gu@@4-^r(35**5w-v6l-qkkr@aut890$z=lx^e_%1$q+nb%'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = ["*"]


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    
    # Third party apps
    'rest_framework',
    'rest_framework_simplejwt',
    'corsheaders',
    
    # Local apps
    'accounts',
    'learning_engine',

]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'corsheaders.middleware.CorsMiddleware',  # Add this
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'core.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'core.wsgi.application'


# Database
# https://docs.djangoproject.com/en/6.0/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}


# Password validation
# https://docs.djangoproject.com/en/6.0/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/6.0/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/6.0/howto/static-files/

STATIC_URL = 'static/'


DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# CORS settings
CORS_ALLOWED_ORIGINS = [
    "http://localhost:3000",
    "http://127.0.0.1:3000",
    "http://localhost:5173",
    "http://127.0.0.1:5173",
    "http://localhost:5174",
    "http://127.0.0.1:5174",
]

CORS_ALLOW_CREDENTIALS = True

# REST Framework settings
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ),
    'DEFAULT_PERMISSION_CLASSES': (
        'rest_framework.permissions.IsAuthenticated',
    ),
}

# JWT settings
SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(minutes=60),
    'REFRESH_TOKEN_LIFETIME': timedelta(days=1),
    'ROTATE_REFRESH_TOKENS': False,
    'BLACKLIST_AFTER_ROTATION': True,
    'UPDATE_LAST_LOGIN': False,

    'ALGORITHM': 'HS256',
    'SIGNING_KEY': SECRET_KEY,
    'VERIFYING_KEY': None,
    'AUDIENCE': None,
    'ISSUER': None,

    'AUTH_HEADER_TYPES': ('Bearer',),
    'AUTH_HEADER_NAME': 'HTTP_AUTHORIZATION',
    'USER_ID_FIELD': 'id',
    'USER_ID_CLAIM': 'user_id',

    'AUTH_TOKEN_CLASSES': ('rest_framework_simplejwt.tokens.AccessToken',),
    'TOKEN_TYPE_CLAIM': 'token_type',

    'JTI_CLAIM': 'jti',

    'SLIDING_TOKEN_REFRESH_EXP_CLAIM': 'refresh_exp',
    'SLIDING_TOKEN_LIFETIME': timedelta(minutes=5),
    'SLIDING_TOKEN_REFRESH_LIFETIME': timedelta(days=1),
}


LEARNING_ENGINE = {
    'MAX_PER_DIFFICULTY': 4,
    'MASTERY_THRESHOLD': 0.7,
    'BKT_SLIP': 0.1,
    'BKT_GUESS': 0.2,
    'BKT_LEARN': 0.15,
}

# API Keys (set these in environment variables)
GOOGLE_API_KEY = os.environ.get('GOOGLE_API_KEY', '')
GROQ_API_KEY = os.environ.get('GROQ_API_KEY', '')


LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'format': '{levelname} {asctime} {module} {process:d} {thread:d} {message}',
            'style': '{',
        },
        'simple': {
            'format': '{levelname} {asctime} {message}',
            'style': '{',
        },
    },
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
            'formatter': 'simple',
        },
        'file': {
            'class': 'logging.FileHandler',
            'filename': os.path.join(BASE_DIR, 'debug.log'),
            'formatter': 'verbose',
        },
    },
    'root': {
        'handlers': ['console', 'file'],
        'level': 'INFO',
    },
    'loggers': {
        'django': {
            'handlers': ['console', 'file'],
            'level': 'INFO',
            'propagate': False,
        },
        'accounts': {
            'handlers': ['console', 'file'],
            'level': 'DEBUG',
            'propagate': False,
        },
        'learning_engine': {
            'handlers': ['console', 'file'],
            'level': 'DEBUG',
            'propagate': False,
        },
    },
}


================================================
FILE: backend/core/urls.py
================================================
from django.contrib import admin
from django.urls import path, include
from rest_framework_simplejwt.views import TokenRefreshView

urlpatterns = [
    path('admin/', admin.site.urls),
    path('auth/', include('accounts.urls')),  # This should be correct
    path('api/token/refresh/', TokenRefreshView.as_view(), name='token_refresh'),
]


================================================
FILE: backend/core/wsgi.py
================================================
"""
WSGI config for core project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/6.0/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'core.settings')

application = get_wsgi_application()



================================================
FILE: backend/learning_engine/__init__.py
================================================
from .adaptive_flow import AdaptiveLearningEngine
from .knowledge_tracing import bkt_update, irt_probability, update_theta, classify_behavior, update_mastery_from_behavior, classify_error_type
from .question_generator import QuestionGenerator
from .models import TeachingAtomState, LearningPhase, ErrorType, PacingDecision

__all__ = [
    'AdaptiveLearningEngine',
    'bkt_update',
    'irt_probability',
    'update_theta',
    'classify_behavior',
    'update_mastery_from_behavior',
    'classify_error_type',
    'QuestionGenerator',
    'TeachingAtomState',
    'LearningPhase',
    'ErrorType',
    'PacingDecision',
]


================================================
FILE: backend/learning_engine/adaptive_flow.py
================================================
# backend/learning_engine/adaptive_flow.py - Enhanced with pacing engine

import json
import random
from typing import Dict, List, Optional, Tuple, Any
from django.conf import settings
from groq import Groq
from .models import TeachingAtomState, LearningPhase
from .knowledge_tracing import calculate_updated_mastery, classify_error_type
from .pacing_engine import PacingEngine, PacingContext, PacingDecision, NextAction

class AdaptiveLearningEngine:
    """Enhanced adaptive learning engine with real-time mastery and strict pacing"""
    
    def __init__(self):
        self.groq_client = None
        groq_key = getattr(settings, 'GROQ_API_KEY', '')
        if groq_key:
            self.groq_client = Groq(api_key=groq_key)
        
        self.pacing_engine = PacingEngine()
    
    def process_answer(self, 
                      atom_state: TeachingAtomState,
                      theta: float,
                      question: Dict[str, Any],
                      selected_answer: int,
                      time_taken: float,
                      knowledge_level: str,
                      questions_history: List[Dict]) -> Dict[str, Any]:
        """
        Process a single answer with real-time mastery update and pacing decision
        
        Args:
            atom_state: Current atom state
            theta: Current ability estimate
            question: Question that was answered
            selected_answer: User's answer index
            time_taken: Time taken in seconds
            knowledge_level: Self-reported knowledge level
            questions_history: List of previous questions/answers
        
        Returns:
            Dict with updated state and next actions
        """
        # Determine correctness
        correct = (selected_answer == question.get('correct_index', -1))
        
        # Classify error type if wrong
        error_type = None
        if not correct:
            error_type = classify_error_type(
                question, selected_answer, time_taken, atom_state.name
            )
        
        # REAL-TIME MASTERY UPDATE (after EVERY answer)
        new_mastery, new_theta, metrics = calculate_updated_mastery(
            current_mastery=atom_state.mastery_score,
            current_theta=theta,
            question=question,
            correct=correct,
            time_taken=time_taken,
            error_type=error_type
        )
        
        # Update atom state
        atom_state.mastery_score = new_mastery
        
        if correct:
            atom_state.streak = atom_state.streak + 1 if atom_state.streak > 0 else 1
        else:
            atom_state.streak = atom_state.streak - 1 if atom_state.streak < 0 else -1
        
        if error_type:
            atom_state.error_history.append(error_type)
        
        # Calculate recent metrics for pacing
        recent_questions = questions_history[-5:] if questions_history else []
        recent_correct = sum(1 for q in recent_questions if q.get('correct', False))
        recent_accuracy = recent_correct / len(recent_questions) if recent_questions else (1.0 if correct else 0.0)
        
        # Get recent error types
        recent_errors = [e for e in atom_state.error_history[-5:] if e]
        
        # Create pacing context
        pacing_context = PacingContext(
            accuracy=recent_accuracy,
            mastery_score=new_mastery,
            streak=atom_state.streak,
            error_types=recent_errors,
            theta=new_theta,
            questions_answered=len(questions_history) + 1,
            knowledge_level=knowledge_level,
            phase=atom_state.phase.value if hasattr(atom_state.phase, 'value') else atom_state.phase
        )
        
        # Get pacing decision
        pacing_decision, next_action, reasoning = self.pacing_engine.decide_pacing(pacing_context)
        
        # Determine next difficulty based on ability and pacing
        next_difficulty = self.pacing_engine.get_next_difficulty(
            new_theta, pacing_decision, knowledge_level
        )
        
        # Check if atom is complete
        atom_complete = self._check_atom_complete(atom_state, pacing_context)
        
        # Prepare result
        result = {
            'correct': correct,
            'error_type': error_type,
            'updated_mastery': new_mastery,
            'updated_theta': new_theta,
            'metrics': metrics,
            'pacing_decision': pacing_decision.value if hasattr(pacing_decision, 'value') else pacing_decision,
            'next_action': next_action.value if hasattr(next_action, 'value') else next_action,
            'next_difficulty': next_difficulty,
            'reasoning': reasoning,
            'atom_complete': atom_complete,
            'streak': atom_state.streak
        }
        
        # Add specific recommendations
        if next_action == NextAction.RETEACH:
            result['recommendation'] = 'review_teaching'
            result['message'] = "Let's review the teaching material again."
        elif next_action == NextAction.ADVANCE_NEXT_ATOM:
            result['recommendation'] = 'advance'
            result['message'] = "Great job! Ready for the next concept."
        elif pacing_decision == PacingDecision.SHARP_SLOWDOWN:
            result['recommendation'] = 'easier_questions'
            result['message'] = "Let's try some easier questions to build confidence."
        elif pacing_decision == PacingDecision.SPEED_UP:
            result['recommendation'] = 'challenge'
            result['message'] = "You're doing great! Ready for a challenge?"
        
        return result
    
    def _check_atom_complete(self, atom_state: TeachingAtomState, 
                            context: PacingContext) -> bool:
        """
        Check if atom should be marked complete based on mastery, not question count
        """
        # Mastery threshold (can be adjusted)
        MASTERY_THRESHOLD = 0.7
        
        # Need minimum practice
        if context.questions_answered < 4:
            return False
        
        # Check mastery
        if atom_state.mastery_score < MASTERY_THRESHOLD:
            return False
        
        # Check recent performance
        if context.accuracy < 0.75:
            return False
        
        # Check streak
        if context.streak < 2:
            return False
        
        # Check for conceptual errors
        if any(e in ['conceptual', 'structural'] for e in context.error_types[-3:] if context.error_types):
            return False
        
        # All conditions met
        return True
    
    def select_next_questions(self, 
                             atom_state: TeachingAtomState,
                             theta: float,
                             pacing_decision: PacingDecision,
                             knowledge_level: str,
                             available_questions: Dict[str, List[Dict]]) -> List[Dict]:
        """
        Select next questions based on ability, not fixed counts
        """
        selected = []
        
        # Determine target difficulty based on theta
        if theta < -0.3:
            target_difficulty = 'easy'
        elif theta < 0.6:
            target_difficulty = 'medium'
        else:
            target_difficulty = 'hard'
        
        # Adjust based on pacing
        if pacing_decision == PacingDecision.SHARP_SLOWDOWN:
            # Focus on easy questions
            target_difficulty = 'easy'
            count = 3
        elif pacing_decision == PacingDecision.SLOW_DOWN:
            # Mix of easy and medium
            easy_count = 2
            medium_count = 1
        elif pacing_decision == PacingDecision.STAY:
            # Mix based on ability
            if target_difficulty == 'easy':
                easy_count, medium_count, hard_count = 2, 1, 0
            elif target_difficulty == 'medium':
                easy_count, medium_count, hard_count = 1, 2, 0
            else:  # hard
                easy_count, medium_count, hard_count = 0, 2, 1
        else:  # SPEED_UP
            # Challenge with harder questions
            if target_difficulty == 'easy':
                easy_count, medium_count, hard_count = 1, 2, 0
            elif target_difficulty == 'medium':
                easy_count, medium_count, hard_count = 0, 2, 1
            else:  # hard
                easy_count, medium_count, hard_count = 0, 1, 2
        
        # Select questions (up to available)
        for difficulty, count in [('easy', easy_count), ('medium', medium_count), ('hard', hard_count)]:
            if count > 0 and difficulty in available_questions:
                pool = available_questions[difficulty]
                # Select without replacement
                to_select = min(count, len(pool))
                if to_select > 0:
                    selected.extend(random.sample(pool, to_select))
        
        return selected
    
    def generate_teaching_content(self, atom_name: str, subject: str, 
                                  concept: str, knowledge_level: str,
                                  error_history: List[str] = None) -> Dict[str, str]:
        """
        Generate personalized teaching content based on knowledge level and error history
        """
        # If reteaching due to errors, focus on problem areas
        if error_history and len(error_history) > 0:
            recent_errors = error_history[-3:]
            error_focus = self._get_error_focus(recent_errors)
        else:
            error_focus = None
        
        if not self.groq_client:
            return self._get_fallback_content(atom_name, concept, knowledge_level, error_focus)
        
        level_descriptions = {
            'zero': "Complete beginner - needs fundamental concepts explained from scratch",
            'beginner': "Has basic understanding but needs clear explanations and examples",
            'intermediate': "Knows the basics - needs deeper insights and applications",
            'advanced': "Strong understanding - needs advanced concepts and edge cases"
        }
        
        error_context = ""
        if error_focus:
            error_context = f"""
            The student has struggled with these types of errors recently:
            {', '.join(error_focus)}
            
            Please address these specific difficulties in your explanation.
            """
        
        prompt = f"""
        You are creating a personalized teaching module for a single atomic concept.
        
        Subject: {subject}
        Concept: {concept}
        Atomic Concept: {atom_name}
        Student Knowledge Level: {level_descriptions.get(knowledge_level, 'intermediate')}
        
        {error_context}
        
        Generate:
        1. A clear explanation tailored to their knowledge level (2-4 sentences)
        2. A concrete example relevant to their level
        3. An analogy from everyday life that matches their understanding
        4. A common misconception to watch out for
        5. A practical application or "why this matters"
        
        Rules:
        - ONE idea only
        - No jargon without explanation
        - Make it memorable and relevant
        - If advanced, include edge cases or limitations
        - If reteaching, explain in a different way than before
        
        Return STRICT JSON:
        {{
            "explanation": "Clear explanation here",
            "example": "Concrete example here",
            "analogy": "Everyday analogy here",
            "misconception": "Common mistake students make",
            "practical_application": "Why this matters in real life"
        }}
        """
        
        try:
            response = self.groq_client.chat.completions.create(
                model="llama-3.3-70b-versatile",
                messages=[{"role": "user", "content": prompt}],
                temperature=0.3,
                max_tokens=800,
            )
            
            raw_text = response.choices[0].message.content
            if "```" in raw_text:
                raw_text = raw_text.split("```")[1]
                if raw_text.startswith("json"):
                    raw_text = raw_text[4:]
            
            return json.loads(raw_text.strip())
        except Exception as e:
            print(f"Warning: Could not generate teaching content: {e}")
            return self._get_fallback_content(atom_name, concept, knowledge_level, error_focus)
    
    def _get_error_focus(self, error_types: List[str]) -> List[str]:
        """Convert error types to focus areas for teaching"""
        focus_map = {
            'conceptual': 'fundamental concepts',
            'structural': 'relationships between ideas',
            'procedural': 'step-by-step processes',
            'factual': 'key facts and definitions',
            'guessing': 'building confidence with basics'
        }
        return [focus_map.get(e, e) for e in error_types if e in focus_map]
    
    def _get_fallback_content(self, atom_name: str, concept: str, level: str, 
                             error_focus: List[str] = None) -> Dict:
        """Enhanced fallback content"""
        focus_text = ""
        if error_focus:
            focus_text = f" focusing on {', '.join(error_focus)}"
        
        if level == 'advanced':
            return {
                "explanation": f"{atom_name} represents an advanced aspect of {concept} with complex interactions and edge cases{focus_text}.",
                "example": f"Advanced example: In production systems, {atom_name} manifests through...",
                "analogy": f"Think of {atom_name} like a sophisticated system where multiple components interact.",
                "misconception": f"Even experts sometimes confuse {atom_name} with similar advanced concepts.",
                "practical_application": f"Understanding {atom_name} helps in optimizing system performance."
            }
        elif level == 'intermediate':
            return {
                "explanation": f"{atom_name} is a key component of {concept} that builds on foundational knowledge{focus_text}.",
                "example": f"Example: When working with {concept}, {atom_name} helps you...",
                "analogy": f"Think of {atom_name} like a well-organized tool in your toolkit.",
                "misconception": f"Don't confuse {atom_name} with its related concepts.",
                "practical_application": f"Mastering {atom_name} improves your problem-solving efficiency."
            }
        else:  # zero or beginner
            return {
                "explanation": f"{atom_name} is a fundamental building block of {concept}. It's like learning a basic rule{focus_text}.",
                "example": f"Simple example: Just like learning the alphabet before writing words, {atom_name} comes first.",
                "analogy": f"Think of {atom_name} like learning to crawl before you walk.",
                "misconception": f"Beginners often think {atom_name} is harder than it really is.",
                "practical_application": f"Understanding {atom_name} opens the door to mastering {concept}."
            }


================================================
FILE: backend/learning_engine/knowledge_tracing.py
================================================
import math
from typing import Dict, Any, Optional

def bkt_update(p_know: float, correct: bool, p_slip: float = 0.1, 
               p_guess: float = 0.2, p_learn: float = 0.15) -> float:
    """
    Bayesian Knowledge Tracing update
    
    Args:
        p_know: Current probability student knows the skill
        correct: Whether answer was correct
        p_slip: Probability of slip (wrong despite knowing)
        p_guess: Probability of guess (correct despite not knowing)
        p_learn: Probability of learning after opportunity
    
    Returns:
        Updated probability of knowledge
    """
    if correct:
        numerator = p_know * (1 - p_slip)
        denominator = numerator + (1 - p_know) * p_guess
    else:
        numerator = p_know * p_slip
        denominator = numerator + (1 - p_know) * (1 - p_guess)
    
    posterior = numerator / denominator if denominator != 0 else p_know
    
    # Learning transition
    updated = posterior + (1 - posterior) * p_learn
    
    return min(1.0, max(0.0, updated))

def irt_probability(theta: float, b: float, a: float = 1.0) -> float:
    """
    Item Response Theory 2PL model
    
    Args:
        theta: Student ability
        b: Item difficulty
        a: Item discrimination
    
    Returns:
        Probability of correct response
    """
    return 1 / (1 + math.exp(-a * (theta - b)))

def update_theta(theta: float, correct: bool, b: float, 
                 a: float = 1.0, lr: float = 0.4) -> float:
    """
    Update theta using gradient of log-likelihood
    
    Args:
        theta: Current ability estimate
        correct: Whether answer was correct
        b: Item difficulty
        a: Item discrimination
        lr: Learning rate
    
    Returns:
        Updated ability estimate
    """
    predicted = irt_probability(theta, b, a)
    actual = 1.0 if correct else 0.0
    
    # Simple gradient update
    theta = theta + lr * (actual - predicted)
    
    return theta

def classify_behavior(correct: bool, time_taken: float, 
                      estimated_time: int) -> str:
    """
    Classify student behavior based on correctness and time
    
    Args:
        correct: Whether answer was correct
        time_taken: Actual time taken in seconds
        estimated_time: Expected time in seconds
    
    Returns:
        Behavior classification
    """
    if estimated_time <= 0:
        return "normal_correct" if correct else "confused"
        
    ratio = time_taken / estimated_time
    
    if correct:
        if ratio < 0.7:
            return "strong_mastery"
        elif ratio > 1.3:
            return "weak_mastery"
        else:
            return "normal_correct"
    else:
        if ratio < 0.7:
            return "guessing"
        else:
            return "confused"

def update_mastery_from_behavior(score: float, behavior: str) -> float:
    """
    Update mastery score based on behavior classification
    
    Args:
        score: Current mastery score
        behavior: Behavior classification
    
    Returns:
        Updated mastery score
    """
    weights = {
        "strong_mastery": 2.0,
        "normal_correct": 1.0,
        "weak_mastery": 0.5,
        "guessing": -1.0,
        "confused": -0.5,
    }
    
    # Convert to 0-1 range update
    update = weights.get(behavior, 0) * 0.05
    return min(1.0, max(0.0, score + update))

def classify_error_type(question: Dict[str, Any], answer: int, 
                       time_taken: float, atom_name: str) -> Optional[str]:
    """
    Classify error type based on question, answer, and timing
    
    Args:
        question: Question dictionary
        answer: Selected answer index
        time_taken: Time taken in seconds
        atom_name: Name of the teaching atom
    
    Returns:
        Error type string or None if correct
    """
    correct = (answer == question.get('correct_index'))
    estimated = question.get('estimated_time', 60)
    time_ratio = time_taken / estimated if estimated > 0 else 1.0
    
    if not correct:
        # Fast wrong = guessing
        if time_ratio < 0.5:
            return "guessing"
        
        # Slow wrong on easy question = conceptual
        if question.get('difficulty') == 'easy' and time_ratio > 1.3:
            return "conceptual"
        
        # Check for structural errors
        q_text = question.get('question', '').lower()
        if any(term in q_text for term in ['mapping', 'between', 'versus', 'vs', 'relationship']):
            return "structural"
        
        # Check if it's a factual error
        if question.get('difficulty') == 'easy':
            return "factual"
        
        # Default
        return "procedural"
    
    # Even correct answers can indicate issues
    if correct and time_ratio < 0.3:
        return "attentional"
    
    return None


# backend/learning_engine/knowledge_tracing.py

def classify_error_type(question, answer, time_taken, atom_name):
    """Classify error type based on question, answer, and timing"""
    if answer == -1:  # No answer
        return "no_answer"
    
    estimated = question.get('estimated_time', 60)
    time_ratio = time_taken / estimated if estimated > 0 else 1.0
    
    # Fast wrong = guessing
    if time_ratio < 0.5:
        return "guessing"
    
    # Slow wrong on easy question = conceptual
    if question.get('difficulty') == 'easy' and time_ratio > 1.3:
        return "conceptual"
    
    # Check for structural errors based on question content
    q_text = question.get('question', '').lower()
    if any(term in q_text for term in ['compare', 'contrast', 'difference', 'relationship']):
        return "structural"
    
    # Check if it's a factual error
    if question.get('difficulty') == 'easy':
        return "factual"
    
    # Default
    return "procedural"

def bkt_update(p_know, correct, p_slip=0.1, p_guess=0.2, p_learn=0.15):
    """Bayesian Knowledge Tracing update"""
    if correct:
        numerator = p_know * (1 - p_slip)
        denominator = numerator + (1 - p_know) * p_guess
    else:
        numerator = p_know * p_slip
        denominator = numerator + (1 - p_know) * (1 - p_guess)
    
    posterior = numerator / denominator if denominator != 0 else p_know
    
    # Learning transition
    updated = posterior + (1 - posterior) * p_learn
    
    return min(1.0, max(0.0, updated))

def update_theta(theta, correct, b=0.0, a=1.0, lr=0.4):
    """Update IRT theta parameter"""
    import math
    
    # IRT probability
    def irt_prob(theta, b, a):
        return 1 / (1 + math.exp(-a * (theta - b)))
    
    predicted = irt_prob(theta, b, a)
    actual = 1.0 if correct else 0.0
    
    # Gradient update
    theta = theta + lr * (actual - predicted)
    
    return theta



# backend/learning_engine/knowledge_tracing.py - Enhanced version

import math
import numpy as np
from typing import Dict, Any, Optional, Tuple

def calculate_updated_mastery(
    current_mastery: float,
    current_theta: float,
    question: Dict[str, Any],
    correct: bool,
    time_taken: float,
    error_type: Optional[str]
) -> Tuple[float, float, Dict[str, float]]:
    """
    Real-time mastery estimation after every answer
    
    Args:
        current_mastery: Current mastery score (0-1)
        current_theta: Current ability parameter
        question: Question dictionary with difficulty, estimated_time
        correct: Whether answer was correct
        time_taken: Time taken in seconds
        error_type: Classified error type or None if correct
    
    Returns:
        Tuple of (new_mastery, new_theta, metrics)
    """
    # Extract question parameters
    difficulty = question.get('difficulty', 'medium')
    estimated_time = question.get('estimated_time', 60)
    cognitive = question.get('cognitive_operation', 'recall')
    
    # Map difficulty to item parameter b (IRT difficulty)
    difficulty_map = {
        'easy': -1.0,
        'medium': 0.0,
        'hard': 1.0
    }
    b = difficulty_map.get(difficulty, 0.0)
    
    # Map cognitive to discrimination a (IRT discrimination)
    cognitive_map = {
        'recall': 0.8,
        'apply': 1.2,
        'analyze': 1.5
    }
    a = cognitive_map.get(cognitive, 1.0)
    
    # Calculate time ratio (normalized)
    time_ratio = time_taken / estimated_time if estimated_time > 0 else 1.0
    
    # 1. Update IRT theta (ability)
    new_theta = update_theta_weighted(
        current_theta, correct, b, a, 
        time_ratio, error_type
    )
    
    # 2. Update mastery based on multiple factors
    mastery_update = calculate_mastery_update(
        current_mastery, correct, time_ratio, 
        error_type, difficulty
    )
    
    new_mastery = min(1.0, max(0.0, current_mastery + mastery_update))
    
    # 3. Calculate performance metrics
    metrics = {
        'theta_change': new_theta - current_theta,
        'mastery_change': mastery_update,
        'confidence': calculate_confidence(correct, time_ratio, error_type),
        'learning_rate': mastery_update / 0.1,  # Normalized learning rate
        'performance_quality': calculate_performance_quality(correct, time_ratio, error_type)
    }
    
    return new_mastery, new_theta, metrics


def update_theta_weighted(
    theta: float,
    correct: bool,
    b: float,
    a: float,
    time_ratio: float,
    error_type: Optional[str],
    base_lr: float = 0.4
) -> float:
    """
    Update theta with time and error-type weighting
    """
    # IRT probability
    prob_correct = 1 / (1 + math.exp(-a * (theta - b)))
    
    # Actual outcome (continuous for weighted updates)
    actual = 1.0 if correct else 0.0
    
    # Calculate confidence weight based on time
    if correct:
        # Fast correct = high confidence
        confidence_weight = min(1.5, 1.0 / max(0.3, time_ratio))
    else:
        # Slow wrong = low confidence, fast wrong = guessing
        if time_ratio < 0.5:  # Guessing
            confidence_weight = 0.3
        elif time_ratio > 1.5:  # Struggling
            confidence_weight = 0.7
        else:
            confidence_weight = 0.5
    
    # Adjust learning rate based on error type
    error_multipliers = {
        'guessing': 0.3,      # Less update from guesses
        'attentional': 0.6,    # Moderate update
        'factual': 0.8,        # Stronger update
        'procedural': 0.9,     # Strong update
        'conceptual': 1.2,     # Very strong update (conceptual errors matter)
        'structural': 1.1,      # Strong update
        None: 1.0               # Normal for correct
    }
    
    error_mult = error_multipliers.get(error_type, 1.0)
    
    # Apply weighted update
    adjusted_lr = base_lr * confidence_weight * error_mult
    theta_update = adjusted_lr * (actual - prob_correct)
    
    return theta + theta_update


def calculate_mastery_update(
    current_mastery: float,
    correct: bool,
    time_ratio: float,
    error_type: Optional[str],
    difficulty: str
) -> float:
    """
    Calculate mastery update with nuanced factors
    """
    # Base update amount
    base_update = 0.05
    
    # Difficulty multiplier
    difficulty_multipliers = {
        'easy': 0.7,    # Less impact from easy questions
        'medium': 1.0,
        'hard': 1.3     # More impact from hard questions
    }
    diff_mult = difficulty_multipliers.get(difficulty, 1.0)
    
    if correct:
        # Time factor for correct answers
        if time_ratio < 0.7:  # Fast correct
            time_factor = 1.3
        elif time_ratio < 1.0:  # Normal
            time_factor = 1.0
        else:  # Slow but correct
            time_factor = 0.7
        
        # Mastery increases less as it approaches 1.0
        ceiling_factor = (1.0 - current_mastery) * 2
        
        update = base_update * diff_mult * time_factor * ceiling_factor
        
    else:  # Incorrect
        # Different impacts based on error type
        error_impacts = {
            'guessing': -0.02,      # Small penalty - just guessing
            'attentional': -0.03,    # Small penalty - careless
            'factual': -0.06,        # Moderate - missing facts
            'procedural': -0.08,     # Significant - don't know process
            'conceptual': -0.12,     # Severe - fundamental misunderstanding
            'structural': -0.10      # Severe - can't see relationships
        }
        
        update = error_impacts.get(error_type, -0.05)
        
        # Additional time factor for wrong answers
        if time_ratio > 1.5:  # Very slow wrong = struggling
            update *= 1.3
        elif time_ratio < 0.5:  # Fast wrong = guessing
            update *= 0.7
    
    return update


def calculate_confidence(correct: bool, time_ratio: float, error_type: Optional[str]) -> float:
    """
    Calculate confidence in the response (0-1)
    """
    if correct:
        # Higher confidence for fast correct answers
        confidence = min(1.0, 1.2 - time_ratio * 0.3)
    else:
        # Lower confidence for wrong answers, especially fast wrong
        if error_type == 'guessing':
            confidence = 0.1
        elif error_type == 'attentional':
            confidence = 0.3
        elif time_ratio < 0.5:
            confidence = 0.2
        elif time_ratio > 1.5:
            confidence = 0.5  # At least tried
        else:
            confidence = 0.4
    
    return max(0.1, min(1.0, confidence))


def calculate_performance_quality(correct: bool, time_ratio: float, error_type: Optional[str]) -> float:
    """
    Calculate overall performance quality (-1 to 1)
    """
    if correct:
        quality = 1.0 - abs(1.0 - time_ratio) * 0.5
    else:
        if error_type == 'guessing':
            quality = -0.8
        elif error_type == 'attentional':
            quality = -0.3
        elif error_type == 'conceptual':
            quality = -0.6
        else:
            quality = -0.4
    
    return max(-1.0, min(1.0, quality))


================================================
FILE: backend/learning_engine/models.py
================================================
from dataclasses import dataclass
from typing import List, Dict, Optional
from enum import Enum

class LearningPhase(str, Enum):
    DIAGNOSTIC = "diagnostic"
    TEACHING = "teaching"
    PRACTICE = "practice"
    REINFORCEMENT = "reinforcement"
    MASTERY_CHECK = "mastery_check"
    COMPLETE = "complete"

class ErrorType(str, Enum):
    CONCEPTUAL = "conceptual"
    PROCEDURAL = "procedural"
    FACTUAL = "factual"
    GUESSING = "guessing"
    STRUCTURAL = "structural"
    ATTENTIONAL = "attentional"

class PacingDecision(str, Enum):
    SPEED_UP = "speed_up"
    SLOW_DOWN = "slow_down"
    SHARP_SLOWDOWN = "sharp_slowdown"
    STAY = "stay"
    REINFORCE = "reinforce"
    ADVANCE = "advance"
    RETREAT = "retreat"

@dataclass
class TeachingAtomState:
    """Represents a teaching atom's state in memory"""
    id: int
    name: str
    mastery_score: float = 0.3
    phase: LearningPhase = LearningPhase.DIAGNOSTIC
    streak: int = 0
    hint_usage: int = 0
    error_history: List[str] = None
    retention_verified: bool = False
    
    def __post_init__(self):
        if self.error_history is None:
            self.error_history = []
    
    def to_dict(self):
        return {
            'id': self.id,
            'name': self.name,
            'mastery_score': self.mastery_score,
            'phase': self.phase.value if hasattr(self.phase, 'value') else self.phase,
            'streak': self.streak,
            'hint_usage': self.hint_usage,
            'retention_verified': self.retention_verified,
            'error_history': self.error_history[-5:]
        }


================================================
FILE: backend/learning_engine/pacing_engine.py
================================================
# backend/learning_engine/pacing_engine.py - NEW FILE

from typing import Dict, List, Optional, Tuple
from enum import Enum
from dataclasses import dataclass


class PacingDecision(str, Enum):
    SPEED_UP = "speed_up"
    STAY = "stay"
    SLOW_DOWN = "slow_down"
    SHARP_SLOWDOWN = "sharp_slowdown"


class NextAction(str, Enum):
    CONTINUE_PRACTICE = "continue_practice"
    RETEACH = "reteach"
    ADVANCE_NEXT_ATOM = "advance_next_atom"
    MASTERY_CHECK = "mastery_check"
    COMPLETE_ATOM = "complete_atom"


@dataclass
class PacingContext:
    """Context for pacing decisions"""
    accuracy: float  # Recent accuracy (0-1)
    mastery_score: float  # Current mastery (0-1)
    streak: int  # Current correct streak
    error_types: List[str]  # Recent error types
    theta: float  # Ability parameter
    questions_answered: int  # Total questions in this atom
    knowledge_level: str  # Initial self-reported level
    phase: str  # Current learning phase


class PacingEngine:
    """
    Strict pacing decision engine with formal rules
    """
    
    def __init__(self):
        # Thresholds by knowledge level
        self.accuracy_thresholds = {
            'zero': {'speed_up': 0.8, 'stay': 0.6, 'slow_down': 0.4, 'sharp_slowdown': 0.25},
            'beginner': {'speed_up': 0.8, 'stay': 0.6, 'slow_down': 0.45, 'sharp_slowdown': 0.3},
            'intermediate': {'speed_up': 0.85, 'stay': 0.7, 'slow_down': 0.55, 'sharp_slowdown': 0.4},
            'advanced': {'speed_up': 0.9, 'stay': 0.8, 'slow_down': 0.65, 'sharp_slowdown': 0.5}
        }
        
        self.mastery_thresholds = {
            'zero': {'speed_up': 0.7, 'stay': 0.5, 'slow_down': 0.35, 'sharp_slowdown': 0.2},
            'beginner': {'speed_up': 0.75, 'stay': 0.55, 'slow_down': 0.4, 'sharp_slowdown': 0.25},
            'intermediate': {'speed_up': 0.8, 'stay': 0.6, 'slow_down': 0.45, 'sharp_slowdown': 0.3},
            'advanced': {'speed_up': 0.85, 'stay': 0.7, 'slow_down': 0.55, 'sharp_slowdown': 0.4}
        }
        
        # Error type weights for pacing
        self.error_weights = {
            'guessing': 1.2,      # Makes slowdown more likely
            'attentional': 0.8,    # Less impact
            'factual': 1.0,
            'procedural': 1.3,
            'conceptual': 1.8,     # Strongest impact
            'structural': 1.5
        }
    
    def decide_pacing(self, context: PacingContext) -> Tuple[PacingDecision, NextAction, Dict]:
        """
        Make strict pacing decision based on formal rules
        
        Returns:
            Tuple of (pacing_decision, next_action, reasoning)
        """
        # Extract context
        level = context.knowledge_level
        accuracy = context.accuracy
        mastery = context.mastery_score
        streak = context.streak
        error_types = context.error_types
        phase = context.phase
        q_count = context.questions_answered
        
        # Get thresholds for this knowledge level
        acc_thresh = self.accuracy_thresholds.get(level, self.accuracy_thresholds['intermediate'])
        mas_thresh = self.mastery_thresholds.get(level, self.mastery_thresholds['intermediate'])
        
        # Initialize reasoning
        reasoning = {
            'accuracy': accuracy,
            'mastery': mastery,
            'streak': streak,
            'primary_factors': [],
            'error_analysis': {}
        }
        
        # Analyze recent errors
        if error_types:
            error_counts = {}
            for err in error_types[-5:]:  # Last 5 errors
                error_counts[err] = error_counts.get(err, 0) + 1
            
            reasoning['error_analysis'] = error_counts
            
            # Check for severe error patterns
            conceptual_errors = error_counts.get('conceptual', 0)
            structural_errors = error_counts.get('structural', 0)
            repeated_errors = len(error_types) >= 3 and len(set(error_types[-3:])) <= 2
        
        # STEP 1: Check for critical conditions
        critical_conditions = []
        
        # Conceptual errors in last 3 questions
        if any(e in ['conceptual', 'structural'] for e in error_types[-3:] if error_types):
            critical_conditions.append('conceptual_error')
        
        # Very low accuracy
        if accuracy < acc_thresh['sharp_slowdown']:
            critical_conditions.append('very_low_accuracy')
        
        # Very low mastery
        if mastery < mas_thresh['sharp_slowdown']:
            critical_conditions.append('very_low_mastery')
        
        # Negative streak (multiple wrong)
        if streak < -2:  # 2 or more wrong in a row
            critical_conditions.append('negative_streak')
        
        # If any critical condition, sharp slowdown
        if critical_conditions:
            reasoning['primary_factors'] = critical_conditions
            reasoning['severity'] = 'critical'
            
            # Determine next action
            if phase in ['diagnostic', 'teaching'] and mastery < 0.3:
                next_action = NextAction.RETEACH
            elif phase == 'practice':
                next_action = NextAction.RETEACH
            else:
                next_action = NextAction.CONTINUE_PRACTICE
            
            return PacingDecision.SHARP_SLOWDOWN, next_action, reasoning
        
        # STEP 2: Check moderate conditions
        moderate_conditions = []
        
        if accuracy < acc_thresh['slow_down']:
            moderate_conditions.append('low_accuracy')
        
        if mastery < mas_thresh['slow_down']:
            moderate_conditions.append('low_mastery')
        
        if streak < 0:  # Currently on wrong answer
            moderate_conditions.append('negative_streak_start')
        
        # Procedural errors indicate need for practice
        if error_types and error_types[-1] in ['procedural', 'factual']:
            moderate_conditions.append('procedural_error')
        
        if moderate_conditions:
            reasoning['primary_factors'] = moderate_conditions
            reasoning['severity'] = 'moderate'
            return PacingDecision.SLOW_DOWN, NextAction.CONTINUE_PRACTICE, reasoning
        
        # STEP 3: Check speed-up conditions
        speed_conditions = []
        
        if accuracy >= acc_thresh['speed_up']:
            speed_conditions.append('high_accuracy')
        
        if mastery >= mas_thresh['speed_up']:
            speed_conditions.append('high_mastery')
        
        if streak >= 3:  # Strong streak
            speed_conditions.append('strong_streak')
        
        # For speed-up, need at least 2 conditions
        if len(speed_conditions) >= 2:
            reasoning['primary_factors'] = speed_conditions
            reasoning['severity'] = 'positive'
            
            # Check if ready to advance
            if mastery >= 0.7 and accuracy >= 0.8 and streak >= 2:
                # Ready to move to next phase or atom
                if phase == 'diagnostic':
                    next_action = NextAction.ADVANCE_NEXT_ATOM
                elif phase == 'teaching':
                    next_action = NextAction.ADVANCE_NEXT_ATOM
                elif phase == 'practice' and mastery >= 0.8:
                    next_action = NextAction.MASTERY_CHECK
                else:
                    next_action = NextAction.CONTINUE_PRACTICE
            else:
                next_action = NextAction.CONTINUE_PRACTICE
            
            return PacingDecision.SPEED_UP, next_action, reasoning
        
        # STEP 4: Default - stay
        reasoning['primary_factors'] = ['normal_performance']
        reasoning['severity'] = 'normal'
        return PacingDecision.STAY, NextAction.CONTINUE_PRACTICE, reasoning
    
    def get_next_difficulty(self, theta: float, current_pacing: PacingDecision, 
                           knowledge_level: str) -> str:
        """
        Select next difficulty based on ability and pacing
        """
        # Map theta to base difficulty
        if theta < -0.5:
            base_difficulty = 'easy'
        elif theta < 0.5:
            base_difficulty = 'medium'
        else:
            base_difficulty = 'hard'
        
        # Adjust based on pacing
        pacing_adjustments = {
            PacingDecision.SPEED_UP: {'easy': 'medium', 'medium': 'hard', 'hard': 'hard'},
            PacingDecision.STAY: {'easy': 'easy', 'medium': 'medium', 'hard': 'medium'},
            PacingDecision.SLOW_DOWN: {'easy': 'easy', 'medium': 'easy', 'hard': 'medium'},
            PacingDecision.SHARP_SLOWDOWN: {'easy': 'easy', 'medium': 'easy', 'hard': 'easy'}
        }
        
        adjustment = pacing_adjustments.get(current_pacing, {})
        next_difficulty = adjustment.get(base_difficulty, base_difficulty)
        
        # Adjust for knowledge level
        if knowledge_level == 'zero' and next_difficulty == 'hard':
            next_difficulty = 'medium'
        elif knowledge_level == 'advanced' and next_difficulty == 'easy':
            next_difficulty = 'medium'
        
        return next_difficulty
    
    def should_reteach(self, context: PacingContext) -> bool:
        """
        Determine if reteaching is needed
        """
        error_types = context.error_types[-3:] if context.error_types else []
        
        # Conditions for reteaching
        conditions = [
            # Conceptual errors in last 3 questions
            any(e in ['conceptual', 'structural'] for e in error_types),
            # Very low mastery
            context.mastery_score < 0.3,
            # Multiple wrong in a row with low mastery
            context.streak < -2 and context.mastery_score < 0.5,
            # Low accuracy with conceptual errors
            context.accuracy < 0.4 and 'conceptual' in error_types
        ]
        
        return any(conditions)
    
    def should_advance(self, context: PacingContext) -> bool:
        """
        Determine if student should advance to next atom
        """
        conditions = [
            context.mastery_score >= 0.7,
            context.accuracy >= 0.8,
            context.streak >= 2,
            context.questions_answered >= 4,  # Minimum practice
            # No conceptual errors recently
            'conceptual' not in (context.error_types[-3:] if context.error_types else [])
        ]
        
        # Need at least 3 conditions including mastery and accuracy
        return sum(conditions) >= 3 and conditions[0] and conditions[1]


================================================
FILE: backend/learning_engine/question_generator.py
================================================
# backend/learning_engine/question_generator.py - Complete fixed version

import json
import os
from typing import Dict, List, Optional
from groq import Groq
import google.generativeai as genai
from django.conf import settings

class QuestionGenerator:
    """Generate questions and atoms for learning using AI"""
    
    def __init__(self):
        # Initialize Groq client
        groq_key = getattr(settings, 'GROQ_API_KEY', '')
        self.groq_client = Groq(api_key=groq_key) if groq_key else None
        
        # Initialize Gemini client
        gemini_key = getattr(settings, 'GOOGLE_API_KEY', '')
        if gemini_key:
            genai.configure(api_key=gemini_key)
            self.gemini_model = genai.GenerativeModel('gemini-2.5-flash')
        else:
            self.gemini_model = None
    
    def generate_atoms(self, subject: str, concept: str) -> List[str]:
        """
        Generate atomic concepts using Gemini
        
        Args:
            subject: Subject name (e.g., 'Microprocessor')
            concept: Concept name (e.g., 'Memory Organization')
        
        Returns:
            List of atomic concept names
        """
        if not self.gemini_model:
            print("Gemini model not available, using fallback atoms")
            return self._get_fallback_atoms(subject, concept)
        
        prompt = f"""
        You are generating atomic sub-concepts for curriculum design.

        Subject: {subject}
        Concept: {concept}

        You must follow ALL rules strictly.

        STRICT RULES:
        1. Generate EXACTLY between 4 and 6 atoms.
        2. Each atom must be:
           - A noun or noun phrase only.
           - Maximum 4 words.
           - No verbs.
           - No full sentences.
        3. All atoms must belong to the SAME abstraction level.
        4. Do NOT generate:
           - Parentâ€“child pairs
           - General-to-specific relationships
           - Negation pairs (pre/non, with/without, static/dynamic)
           - Overlapping concepts
           - Duplicates
        5. Each atom must be independently assessable.
        6. Do NOT include the concept name itself.
        7. No explanations.
        8. No numbering.
        9. No markdown.
        10. Output STRICT JSON only.

        Output format:
        {{
            "atoms": [
                "Atom 1",
                "Atom 2",
                "Atom 3",
                "Atom 4"
            ]
        }}

        If rules cannot be satisfied, return:
        {{"atoms": []}}
        """
        
        try:
            response = self.gemini_model.generate_content(prompt)
            
            # Extract JSON from response
            text = response.text
            if "```" in text:
                text = text.split("```")[1]
                if text.startswith("json"):
                    text = text[4:]
            
            result = json.loads(text.strip())
            atoms = result.get("atoms", [])
            
            # Validate atom count
            if len(atoms) < 4 or len(atoms) > 6:
                print(f"Invalid atom count: {len(atoms)}, using fallback")
                return self._get_fallback_atoms(subject, concept)
            
            return atoms
            
        except Exception as e:
            print(f"Error generating atoms: {e}")
            return self._get_fallback_atoms(subject, concept)
    
    # backend/learning_engine/question_generator.py - Updated method

    def generate_questions(self, subject: str, concept: str, atom: str,
                        target_difficulty: str, count: int, 
                        knowledge_level: str = 'intermediate',
                        error_focus: List[str] = None) -> List[Dict]:
        """
        Generate questions for an atom with dynamic difficulty
        
        Args:
            subject: Subject name
            concept: Concept name
            atom: Atomic concept name
            target_difficulty: Specific difficulty to generate ('easy', 'medium', 'hard')
            count: Number of questions needed
            knowledge_level: Student's knowledge level
            error_focus: Optional list of error types to address
        
        Returns:
            List of question dictionaries
        """
        print(f"Generating {count} {target_difficulty} questions for atom: {atom}")
        
        if not self.groq_client or count == 0:
            return self._get_fallback_questions(atom, target_difficulty, count, knowledge_level)
        
        # Adjust based on knowledge level
        level_adjustments = {
            'zero': {
                'cognitive': ['recall'],
                'time_factor': 1.5,
                'complexity': 'very simple, foundational',
                'hint_level': 'detailed'
            },
            'beginner': {
                'cognitive': ['recall', 'apply'],
                'time_factor': 1.2,
                'complexity': 'straightforward',
                'hint_level': 'clear'
            },
            'intermediate': {
                'cognitive': ['recall', 'apply', 'analyze'],
                'time_factor': 1.0,
                'complexity': 'moderate',
                'hint_level': 'moderate'
            },
            'advanced': {
                'cognitive': ['apply', 'analyze'],
                'time_factor': 0.8,
                'complexity': 'challenging',
                'hint_level': 'subtle'
            }
        }
        
        adj = level_adjustments.get(knowledge_level, level_adjustments['intermediate'])
        
        # Determine cognitive operations for this difficulty
        if target_difficulty == 'easy':
            allowed_cognitive = ['recall']
        elif target_difficulty == 'medium':
            allowed_cognitive = ['recall', 'apply']
        else:  # hard
            allowed_cognitive = ['apply', 'analyze']
        
        # Add error focus if provided
        error_context = ""
        if error_focus:
            error_context = f"""
            Focus on addressing these common errors:
            {', '.join(error_focus)}
            
            Create questions that help the student overcome these specific difficulties.
            """
        
        prompt = f"""
        You are generating multiple-choice assessment questions.
        
        Subject: {subject}
        Concept: {concept}
        Atomic Concept: {atom}
        Student Level: {knowledge_level.upper()}
        Target Difficulty: {target_difficulty.upper()}
        
        Generate EXACTLY {count} {target_difficulty} question(s) with these characteristics:
        - Complexity: {adj['complexity']}
        - Cognitive levels: {', '.join(allowed_cognitive)}
        - Hint level: {adj['hint_level']}
        
        {error_context}
        
        Each question must:
        - Have exactly 4 options
        - Be clearly worded and self-contained
        - Test understanding, not trickery
        - Include the atomic concept explicitly
        - Maximum 25 words per question text
        - For {target_difficulty} questions, the difficulty should be appropriate:
            * Easy: Direct recall, simple application
            * Medium: Requires understanding, some analysis
            * Hard: Complex application, synthesis of ideas
        
        Each question MUST include:
        - "difficulty": "{target_difficulty}"
        - "cognitive_operation": one of {allowed_cognitive}
        - "estimated_time": integer (seconds) - recall: 20-40, apply: 40-90, analyze: 90-150
        - "question": string
        - "options": array of exactly 4 strings
        - "correct_index": integer (0-3)
        
        OUTPUT STRICT JSON ONLY:
        
        {{
            "questions": [
                {{
                    "difficulty": "{target_difficulty}",
                    "cognitive_operation": "recall",
                    "estimated_time": 30,
                    "question": "Question text here?",
                    "options": [
                        "Option A",
                        "Option B",
                        "Option C",
                        "Option D"
                    ],
                    "correct_index": 1
                }}
            ]
        }}
        
        If constraints cannot be satisfied, return:
        {{"questions": []}}
        """
        
        try:
            response = self.groq_client.chat.completions.create(
                model="llama-3.3-70b-versatile",
                messages=[{"role": "user", "content": prompt}],
                temperature=0.3,
                max_tokens=1024,
            )
            
            raw_text = response.choices[0].message.content
            if "```" in raw_text:
                raw_text = raw_text.split("```")[1]
                if raw_text.startswith("json"):
                    raw_text = raw_text[4:]
            
            result = json.loads(raw_text.strip())
            questions = result.get("questions", [])
            
            # Adjust estimated time based on knowledge level
            for q in questions:
                q['estimated_time'] = int(q.get('estimated_time', 60) * adj['time_factor'])
            
            print(f"Generated {len(questions)} {target_difficulty} questions")
            return questions
            
        except Exception as e:
            print(f"Error generating questions: {e}")
            return self._get_fallback_questions(atom, target_difficulty, count, knowledge_level)
    
    def _get_fallback_atoms(self, subject: str, concept: str) -> List[str]:
        """Provide fallback atoms when AI generation fails"""
        # Common fallback atoms based on concept
        fallbacks = {
            "Memory Organization": [
                "Address Space",
                "Memory Hierarchy",
                "Cache Memory",
                "RAM vs ROM",
                "Memory Mapping"
            ],
            "Address Space": [
                "Address Lines",
                "Memory Locations",
                "Address Decoding",
                "Word Size",
                "Byte Addressing"
            ],
            "Cache Memory": [
                "Cache Levels",
                "Cache Hit/Miss",
                "Cache Mapping",
                "Replacement Policy",
                "Write Policy"
            ]
        }
        
        # Try to find matching fallback
        for key, atoms in fallbacks.items():
            if key.lower() in concept.lower():
                return atoms
        
        # Generic fallback
        return [
            f"{concept} Basics",
            f"{concept} Structure",
            f"{concept} Operations",
            f"{concept} Applications",
            f"{concept} Limitations"
        ]
    
    def _get_fallback_questions(self, atom: str, need_easy: int, need_medium: int, level: str = 'intermediate') -> List[Dict]:
        """Provide fallback questions when AI generation fails"""
        questions = []
        
        # Generate easy questions
        for i in range(need_easy):
            questions.append({
                "difficulty": "easy",
                "cognitive_operation": "recall",
                "estimated_time": 30,
                "question": f"What is the primary purpose of {atom}?",
                "options": [
                    f"To manage {atom} operations",
                    "To store data permanently",
                    "To execute instructions",
                    "To control peripherals"
                ],
                "correct_index": 0
            })
        
        # Generate medium questions
        for i in range(need_medium):
            questions.append({
                "difficulty": "medium",
                "cognitive_operation": "apply",
                "estimated_time": 60,
                "question": f"Which scenario best demonstrates the application of {atom}?",
                "options": [
                    f"When implementing {atom} in a real system",
                    "During basic operations",
                    "In simple calculations",
                    "At the start of processing"
                ],
                "correct_index": 0
            })
        
        return questions
    
    def generate_complete_concept(self, subject: str, concept: str) -> Dict:
        """
        Generate complete concept with atoms and questions
        
        Args:
            subject: Subject name
            concept: Concept name
        
        Returns:
            Dictionary with atoms and questions
        """
        print(f"Generating complete concept for {subject} - {concept}")
        
        # Generate atoms
        atoms = self.generate_atoms(subject, concept)
        print(f"Generated {len(atoms)} atoms: {atoms}")
        
        result = {
            "concept": concept,
            "subject": subject,
            "atoms": {}
        }
        
        # Generate questions for each atom
        for atom in atoms:
            print(f"Generating questions for atom: {atom}")
            # Generate 2 easy and 2 medium questions per atom
            questions = self.generate_questions(
                subject=subject,
                concept=concept,
                atom=atom,
                need_easy=2,
                need_medium=2,
                knowledge_level='intermediate'  # Default level
            )
            
            result["atoms"][atom] = {
                "name": atom,
                "questions": questions
            }
            
            print(f"Generated {len(questions)} questions for {atom}")
        
        return result
    
    
    
    def generate_questions_from_teaching(self, subject, concept, atom, teaching_content, 
                                        need_easy=1, need_medium=2, need_hard=0, 
                                        knowledge_level='intermediate'):
        """
        Generate questions based on the teaching content that was shown
        
        Args:
            subject: Subject name
            concept: Concept name
            atom: Atomic concept name
            teaching_content: Dict with explanation, analogy, examples
            need_easy: Number of easy questions
            need_medium: Number of medium questions
            need_hard: Number of hard questions
            knowledge_level: Student's knowledge level
        
        Returns:
            List of question dictionaries
        """
        print(f"Generating questions from teaching for atom: {atom}")
        
        if not self.groq_client:
            print("Groq client not available, using fallback")
            return self._get_fallback_questions_from_teaching(atom, need_easy, need_medium, need_hard)
        
        total_needed = need_easy + need_medium + need_hard
        
        # Extract teaching content
        explanation = teaching_content.get('explanation', '')
        analogy = teaching_content.get('analogy', '')
        examples = teaching_content.get('examples', [])
        
        examples_text = "\n".join([f"- {ex}" for ex in examples if ex])
        
        prompt = f"""
        You are generating assessment questions based on specific teaching content that was just shown to a student.
        
        Subject: {subject}
        Concept: {concept}
        Atomic Concept: {atom}
        Student Level: {knowledge_level.upper()}
        
        TEACHING CONTENT SHOWN TO STUDENT:
        
        Explanation:
        {explanation}
        
        Analogy:
        {analogy}
        
        Examples/Applications:
        {examples_text}
        
        TASK:
        Generate EXACTLY {total_needed} multiple-choice questions that test understanding of the teaching content above.
        
        Question Distribution:
        - Easy: {need_easy} question(s) - Direct recall from the explanation
        - Medium: {need_medium} question(s) - Apply the concept to new situations
        - Hard: {need_hard} question(s) - Analyze relationships or troubleshoot
        
        RULES:
        1. Each question must be answerable based SOLELY on the teaching content provided
        2. Test genuine understanding, not trickery
        3. Questions should build upon what was taught
        4. Include the analogy or examples where appropriate
        5. Each question must have exactly 4 options
        6. One clearly correct answer, three plausible distractors
        
        OUTPUT STRICT JSON ONLY:
        
        {{
            "questions": [
                {{
                    "difficulty": "easy",
                    "cognitive_operation": "recall",
                    "estimated_time": 30,
                    "question": "Based on the explanation, what is the main purpose of {atom}?",
                    "options": [
                        "Option A based on teaching",
                        "Option B based on teaching", 
                        "Option C based on teaching",
                        "Option D based on teaching"
                    ],
                    "correct_index": 0
                }}
            ]
        }}
        """
        
        try:
            response = self.groq_client.chat.completions.create(
                model="llama-3.3-70b-versatile",
                messages=[{"role": "user", "content": prompt}],
                temperature=0.3,
                max_tokens=1024,
            )
            
            raw_text = response.choices[0].message.content
            if "```" in raw_text:
                raw_text = raw_text.split("```")[1]
                if raw_text.startswith("json"):
                    raw_text = raw_text[4:]
            
            result = json.loads(raw_text.strip())
            questions = result.get("questions", [])
            
            print(f"Generated {len(questions)} questions from teaching")
            return questions
            
        except Exception as e:
            print(f"Error generating questions from teaching: {e}")
            return self._get_fallback_questions_from_teaching(atom, need_easy, need_medium, need_hard)

    def _get_fallback_questions_from_teaching(self, atom, need_easy, need_medium, need_hard):
        """Fallback questions based on teaching content"""
        questions = []
        
        # Easy questions
        for i in range(need_easy):
            questions.append({
                "difficulty": "easy",
                "cognitive_operation": "recall",
                "estimated_time": 30,
                "question": f"What is the main purpose of {atom}?",
                "options": [
                    f"To {atom.lower()} efficiently",
                    "To store data permanently",
                    "To execute instructions",
                    "To control peripherals"
                ],
                "correct_index": 0
            })
        
        # Medium questions
        for i in range(need_medium):
            questions.append({
                "difficulty": "medium",
                "cognitive_operation": "apply",
                "estimated_time": 60,
                "question": f"Which scenario best demonstrates the application of {atom}?",
                "options": [
                    f"When implementing {atom} in a real system",
                    "During basic operations",
                    "In simple calculations",
                    "At the start of processing"
                ],
                "correct_index": 0
            })
        
        # Hard questions
        for i in range(need_hard):
            questions.append({
                "difficulty": "hard",
                "cognitive_operation": "analyze",
                "estimated_time": 90,
                "question": f"What would happen if {atom} was implemented incorrectly?",
                "options": [
                    "System performance would degrade",
                    "Nothing would change",
                    "The system would run faster",
                    "Data would be more secure"
                ],
                "correct_index": 0
            })
        
        return questions


================================================
FILE: backend/learning_engine/utils.py
================================================
import json
from typing import Any, Dict, List

def extract_json(text: str) -> str:
    """Extract JSON from text that might contain markdown code blocks"""
    text = text.strip()
    if text.startswith("```"):
        # Remove fenced code block markers
        lines = [ln.rstrip() for ln in text.splitlines()]
        if lines and lines[0].startswith("```"):
            lines = lines[1:]
        if lines and lines[-1].startswith("```"):
            lines = lines[:-1]
        text = "\n".join(lines).strip()
        if text.lower().startswith("json"):
            text = text[4:].strip()
    return text

def normalize_difficulty(value: str) -> str:
    """Normalize difficulty string"""
    v = (value or "").strip().lower()
    if v in ("med", "mid"):
        return "medium"
    return v

def difficulty_count(questions: List[Dict[str, Any]], difficulty: str) -> int:
    """Count questions of a specific difficulty"""
    d = normalize_difficulty(difficulty)
    return sum(1 for q in questions if normalize_difficulty(q.get("difficulty", "")) == d)

def existing_texts(questions: List[Dict[str, Any]], difficulty: str) -> set:
    """Get set of question texts for a specific difficulty"""
    d = normalize_difficulty(difficulty)
    return {
        (q.get("question") or "").strip().lower()
        for q in questions
        if normalize_difficulty(q.get("difficulty", "")) == d
    }


================================================
FILE: frontend/README.md
================================================
# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) (or [oxc](https://oxc.rs) when used in [rolldown-vite](https://vite.dev/guide/rolldown)) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## React Compiler

The React Compiler is not enabled on this template because of its impact on dev & build performances. To add it, see [this documentation](https://react.dev/learn/react-compiler/installation).

## Expanding the ESLint configuration

If you are developing a production application, we recommend using TypeScript with type-aware lint rules enabled. Check out the [TS template](https://github.com/vitejs/vite/tree/main/packages/create-vite/template-react-ts) for information on how to integrate TypeScript and [`typescript-eslint`](https://typescript-eslint.io) in your project.



================================================
FILE: frontend/eslint.config.js
================================================
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{js,jsx}'],
    extends: [
      js.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    rules: {
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
      'react-hooks/set-state-in-effect': 'off',
      'react-refresh/only-export-components': 'off',
    },
  },
])



================================================
FILE: frontend/index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Student Portal</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>


================================================
FILE: frontend/package.json
================================================
{
  "name": "frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "axios": "^1.13.5",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "react-router-dom": "^7.13.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@types/react": "^19.2.7",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.1",
    "autoprefixer": "^10.4.24",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "postcss": "^8.4.32",
    "tailwindcss": "^3.3.6",
    "vite": "^8.0.0-beta.13"
  },
  "overrides": {
    "vite": "^8.0.0-beta.13"
  }
}



================================================
FILE: frontend/postcss.config.js
================================================
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}



================================================
FILE: frontend/tailwind.config.js
================================================
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}


================================================
FILE: frontend/vite.config.js
================================================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    port: 3000,
    open: true,
    proxy: {
      '/auth': {
        target: 'http://localhost:8000',
        changeOrigin: true,
      },
      '/api': {
        target: 'http://localhost:8000',
        changeOrigin: true,
      }
    }
  }
})


================================================
FILE: frontend/src/App.css
================================================
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}



================================================
FILE: frontend/src/App.jsx
================================================
// In App.jsx - Make sure your route is exactly like this:
import React from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import { AuthProvider } from './context/AuthContext';
import Home from './components/Home';
import Login from './components/Login';
import Register from './components/Register';
import Dashboard from './components/Dashboard';
import ProtectedRoute from './components/ProtectedRoute';
import LearningRoute from './components/Learning/LearningRoute';
import StartAnyConceptSessionRoute from './components/Learning/StartAnyConceptSessionRoute';

function App() {
    return (
        <Router>
            <AuthProvider>
                <Routes>
                    <Route path="/" element={<Home />} />
                    <Route path="/login" element={<Login />} />
                    <Route path="/register" element={<Register />} />
                    
                    <Route
                        path="/dashboard"
                        element={
                            <ProtectedRoute>
                                <Dashboard />
                            </ProtectedRoute>
                        }
                    />

                    {/* This is the important route - note the :conceptId parameter */}
                    <Route
                        path="/learn/:conceptId"
                        element={
                            <ProtectedRoute>
                                <LearningRoute />
                            </ProtectedRoute>
                        }
                    />

                    <Route
                        path="/learn/start"
                        element={
                            <ProtectedRoute>
                                <StartAnyConceptSessionRoute />
                            </ProtectedRoute>
                        }
                    />
                </Routes>
            </AuthProvider>
        </Router>
    );
}

export default App;


================================================
FILE: frontend/src/axiosConfig.js
================================================
import axios from 'axios';

const axiosInstance = axios.create({
    baseURL: 'http://localhost:8000',
    headers: {
        'Content-Type': 'application/json',
    },
});

// Add token to requests if it exists
axiosInstance.interceptors.request.use(
    (config) => {
        const token = localStorage.getItem('access_token');
        
        if (token) {
            config.headers.Authorization = `Bearer ${token}`;
        }
        return config;
    },
    (error) => {
        return Promise.reject(error);
    }
);

// Handle 401 errors and token refresh
axiosInstance.interceptors.response.use(
    (response) => response,
    async (error) => {
        const originalRequest = error.config;
        
        // If error is 401 and we haven't tried to refresh token yet
        if (error.response?.status === 401 && !originalRequest._retry) {
            originalRequest._retry = true;
            
            try {
                const refreshToken = localStorage.getItem('refresh_token');
                if (refreshToken) {
                    const response = await axios.post('http://localhost:8000/api/token/refresh/', {
                        refresh: refreshToken
                    });
                    
                    if (response.data.access) {
                        localStorage.setItem('access_token', response.data.access);
                        originalRequest.headers.Authorization = `Bearer ${response.data.access}`;
                        return axiosInstance(originalRequest);
                    }
                }
            } catch (refreshError) {
                // Refresh failed - clear tokens and redirect to login
                localStorage.removeItem('access_token');
                localStorage.removeItem('refresh_token');
                window.location.href = '/login';
            }
        }
        
        return Promise.reject(error);
    }
);

export default axiosInstance;


================================================
FILE: frontend/src/index.css
================================================
@tailwind base;
@tailwind components;
@tailwind utilities;


@keyframes bounce {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-10px); }
}

.animate-bounce {
    animation: bounce 1s infinite;
}

@keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
}

.animate-pulse-slow {
    animation: pulse 2s infinite;
}

/* Progress bar animations */
.progress-bar-striped {
    background-image: linear-gradient(
        45deg,
        rgba(255, 255, 255, 0.15) 25%,
        transparent 25%,
        transparent 50%,
        rgba(255, 255, 255, 0.15) 50%,
        rgba(255, 255, 255, 0.15) 75%,
        transparent 75%,
        transparent
    );
    background-size: 1rem 1rem;
    animation: progress-bar-stripes 1s linear infinite;
}

@keyframes progress-bar-stripes {
    0% { background-position: 1rem 0; }
    100% { background-position: 0 0; }
}


================================================
FILE: frontend/src/main.jsx
================================================
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)


================================================
FILE: frontend/src/components/Dashboard.jsx
================================================
import React, { useCallback, useEffect, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';
import axios from '../axiosConfig';

const Dashboard = () => {
    const [concepts, setConcepts] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState('');
    const [selectedSubject, setSelectedSubject] = useState('');
    const [subjects, setSubjects] = useState([]);
    
    const { user, logout } = useAuth();
    const navigate = useNavigate();

    const fetchConcepts = useCallback(async () => {
        try {
            const response = await axios.get('/auth/api/concepts/');
            setConcepts(response.data);
            
            // Extract unique subjects
            const uniqueSubjects = [...new Set(response.data.map(c => c.subject))];
            setSubjects(uniqueSubjects);
        } catch (err) {
            console.error('Failed to fetch concepts:', err);
            setError('Failed to load concepts');
            
            if (err.response?.status === 401) {
                logout();
                navigate('/login');
            }
        } finally {
            setLoading(false);
        }
    }, [logout, navigate]);

    useEffect(() => {
        fetchConcepts();
    }, [fetchConcepts]);

    const handleLogout = () => {
        logout();
        navigate('/login');
    };

    const handleStartLearning = (conceptId) => {
        navigate(`/learn/${conceptId}`);
    };

    const handleStartAnyConcept = () => {
        navigate('/learn/start');
    };

    const handleViewProgress = () => {
        navigate('/progress');
    };

    const filteredConcepts = selectedSubject
        ? concepts.filter(c => c.subject === selectedSubject)
        : concepts;

    if (loading) {
        return (
            <div className="min-h-screen flex items-center justify-center">
                <div className="text-xl text-gray-600">Loading...</div>
            </div>
        );
    }

    return (
        <div className="min-h-screen bg-gray-100">
            {/* Navigation */}
            <nav className="bg-white shadow-lg">
                <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
                    <div className="flex justify-between h-16">
                        <div className="flex items-center">
                            <h1 className="text-xl font-semibold text-gray-800">
                                Adaptive Learning System
                            </h1>
                        </div>
                        <div className="flex items-center space-x-4">
                            <span className="text-gray-700">
                                Welcome, {user?.first_name || user?.username}!
                            </span>
                            <button
                                onClick={handleLogout}
                                className="bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-4 rounded"
                            >
                                Logout
                            </button>
                        </div>
                    </div>
                </div>
            </nav>

            <main className="max-w-7xl mx-auto py-6 sm:px-6 lg:px-8">
                <div className="px-4 py-6 sm:px-0">
                    {/* Error Message */}
                    {error && (
                        <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-6">
                            {error}
                        </div>
                    )}

                    {/* Quick Actions */}
                    <div className="bg-white shadow overflow-hidden sm:rounded-lg mb-6">
                        <div className="px-4 py-5 sm:px-6">
                            <h3 className="text-lg leading-6 font-medium text-gray-900">
                                Quick Actions
                            </h3>
                        </div>
                        <div className="border-t border-gray-200 px-4 py-5 sm:px-6">
                            <div className="grid grid-cols-1 gap-4 sm:grid-cols-3">
                                <button
                                    onClick={handleStartAnyConcept}
                                    className="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg text-center transition"
                                >
                                    â–¶ Start New Session
                                </button>

                                <button
                                    onClick={handleViewProgress}
                                    className="bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-4 rounded-lg text-center transition"
                                >
                                    ðŸ“Š View Progress
                                </button>

                                <button
                                    onClick={() => window.location.reload()}
                                    className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg text-center transition"
                                >
                                    ðŸ”„ Refresh
                                </button>
                            </div>
                        </div>
                    </div>

                    {/* Concepts Section */}
                    <div className="bg-white shadow overflow-hidden sm:rounded-lg">
                        <div className="px-4 py-5 sm:px-6 flex justify-between items-center">
                            <div>
                                <h3 className="text-lg leading-6 font-medium text-gray-900">
                                    Available Concepts
                                </h3>
                                <p className="mt-1 text-sm text-gray-500">
                                    Select a concept to start learning
                                </p>
                            </div>
                            
                            {/* Subject Filter */}
                            {subjects.length > 0 && (
                                <div className="w-64">
                                    <select
                                        value={selectedSubject}
                                        onChange={(e) => setSelectedSubject(e.target.value)}
                                        className="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md"
                                    >
                                        <option value="">All Subjects</option>
                                        {subjects.map(subject => (
                                            <option key={subject} value={subject}>
                                                {subject}
                                            </option>
                                        ))}
                                    </select>
                                </div>
                            )}
                        </div>
                        
                        <div className="border-t border-gray-200">
                            {filteredConcepts.length === 0 ? (
                                <div className="text-center py-12">
                                    <p className="text-gray-500">No concepts available.</p>
                                    <p className="text-sm text-gray-400 mt-2">
                                        Click "Start New Session" to create your first concept!
                                    </p>
                                </div>
                            ) : (
                                <ul className="divide-y divide-gray-200">
                                    {filteredConcepts.map((concept) => (
                                        <li key={concept.id} className="px-4 py-4 sm:px-6 hover:bg-gray-50">
                                            <div className="flex items-center justify-between">
                                                <div className="flex-1 min-w-0">
                                                    <p className="text-sm font-medium text-blue-600 truncate">
                                                        {concept.name}
                                                    </p>
                                                    <div className="mt-2 flex items-center text-sm text-gray-500">
                                                        <span className="truncate">{concept.subject}</span>
                                                        <span className="mx-2">â€¢</span>
                                                        <span className="capitalize">
                                                            Difficulty: {concept.difficulty}
                                                        </span>
                                                        {concept.description && (
                                                            <>
                                                                <span className="mx-2">â€¢</span>
                                                                <span className="truncate">{concept.description}</span>
                                                            </>
                                                        )}
                                                    </div>
                                                </div>
                                                <div className="ml-4 flex-shrink-0">
                                                    <button
                                                        onClick={() => handleStartLearning(concept.id)}
                                                        className="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
                                                    >
                                                        Start Learning
                                                    </button>
                                                </div>
                                            </div>
                                        </li>
                                    ))}
                                </ul>
                            )}
                        </div>
                    </div>

                    {/* Learning Tips */}
                    <div className="mt-6 bg-blue-50 border-l-4 border-blue-400 p-4 rounded">
                        <div className="flex">
                            <div className="flex-shrink-0">
                                <svg className="h-5 w-5 text-blue-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                                    <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clipRule="evenodd" />
                                </svg>
                            </div>
                            <div className="ml-3">
                                <p className="text-sm text-blue-700">
                                    <strong>How it works:</strong> For each concept, you'll learn one atomic piece at a time, 
                                    then take a short quiz. The system adapts to your pace and mastery level.
                                </p>
                            </div>
                        </div>
                    </div>
                </div>
            </main>
        </div>
    );
};

export default Dashboard;


================================================
FILE: frontend/src/components/Home.jsx
================================================
Error reading file with 'cp1252': 'charmap' codec can't decode byte 0x9d in position 3592: character maps to <undefined>


================================================
FILE: frontend/src/components/Login.jsx
================================================
import React, { useState } from 'react';
import { useNavigate, Link } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';

const Login = () => {
    const [formData, setFormData] = useState({
        username: '',
        password: ''
    });
    const [error, setError] = useState('');
    const [loading, setLoading] = useState(false);
    
    const { login } = useAuth();
    const navigate = useNavigate();

    const handleChange = (e) => {
        setFormData({
            ...formData,
            [e.target.name]: e.target.value
        });
    };

    const handleSubmit = async (e) => {
        e.preventDefault();
        setError('');
        setLoading(true);

        const result = await login(formData.username, formData.password);
        
        if (result.success) {
            navigate('/dashboard');
        } else {
            setError(result.error);
        }
        
        setLoading(false);
    };

    return (
        <div className="min-h-screen flex items-center justify-center bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
            <div className="max-w-md w-full space-y-8">
                <div>
                    <h2 className="mt-6 text-center text-3xl font-extrabold text-gray-900">
                        Sign in to your account
                    </h2>
                    <p className="mt-2 text-center text-sm text-gray-600">
                        Or{' '}
                        <Link to="/register" className="font-medium text-blue-600 hover:text-blue-500">
                            create a new account
                        </Link>
                    </p>
                </div>
                
                {error && (
                    <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative" role="alert">
                        <span className="block sm:inline">{error}</span>
                    </div>
                )}
                
                <form className="mt-8 space-y-6" onSubmit={handleSubmit}>
                    <div className="rounded-md shadow-sm -space-y-px">
                        <div>
                            <label htmlFor="username" className="sr-only">Username or Email</label>
                            <input
                                id="username"
                                name="username"
                                type="text"
                                required
                                className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-t-md focus:outline-none focus:ring-blue-500 focus:border-blue-500 focus:z-10 sm:text-sm"
                                placeholder="Username or Email"
                                value={formData.username}
                                onChange={handleChange}
                            />
                        </div>
                        <div>
                            <label htmlFor="password" className="sr-only">Password</label>
                            <input
                                id="password"
                                name="password"
                                type="password"
                                required
                                className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-b-md focus:outline-none focus:ring-blue-500 focus:border-blue-500 focus:z-10 sm:text-sm"
                                placeholder="Password"
                                value={formData.password}
                                onChange={handleChange}
                            />
                        </div>
                    </div>

                    <div>
                        <button
                            type="submit"
                            disabled={loading}
                            className="group relative w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50"
                        >
                            {loading ? 'Signing in...' : 'Sign in'}
                        </button>
                    </div>
                </form>
            </div>
        </div>
    );
};

export default Login;


================================================
FILE: frontend/src/components/ProtectedRoute.jsx
================================================
import React from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';

const ProtectedRoute = ({ children }) => {
    const { user, loading } = useAuth();
    const location = useLocation();

    console.log("ProtectedRoute - Auth state:", { user: !!user, loading });

    if (loading) {
        return (
            <div className="min-h-screen flex items-center justify-center">
                <div className="text-xl text-gray-600">Loading...</div>
            </div>
        );
    }

    if (!user) {
        // Save the location they were trying to go to
        return <Navigate to="/login" state={{ from: location.pathname }} replace />;
    }

    return children;
};

export default ProtectedRoute;


================================================
FILE: frontend/src/components/Register.jsx
================================================
import React, { useState } from 'react';
import { useNavigate, Link } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';

const Register = () => {
    const [formData, setFormData] = useState({
        username: '',
        email: '',
        first_name: '',
        last_name: '',
        password: '',
        password2: ''
    });
    const [errors, setErrors] = useState({});
    const [loading, setLoading] = useState(false);
    
    const { register } = useAuth();
    const navigate = useNavigate();

    const handleChange = (e) => {
        setFormData({
            ...formData,
            [e.target.name]: e.target.value
        });
    };

    const handleSubmit = async (e) => {
        e.preventDefault();
        setErrors({});
        setLoading(true);

        const result = await register(formData);
        
        if (result.success) {
            navigate('/login', { state: { message: 'Registration successful! Please login.' } });
        } else {
            setErrors(result.error);
        }
        
        setLoading(false);
    };

    return (
        <div className="min-h-screen flex items-center justify-center bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
            <div className="max-w-md w-full space-y-8">
                <div>
                    <h2 className="mt-6 text-center text-3xl font-extrabold text-gray-900">
                        Create your account
                    </h2>
                    <p className="mt-2 text-center text-sm text-gray-600">
                        Or{' '}
                        <Link to="/login" className="font-medium text-blue-600 hover:text-blue-500">
                            sign in to existing account
                        </Link>
                    </p>
                </div>
                
                <form className="mt-8 space-y-6" onSubmit={handleSubmit}>
                    <div className="space-y-4">
                        <div>
                            <label htmlFor="username" className="block text-sm font-medium text-gray-700">
                                Username *
                            </label>
                            <input
                                id="username"
                                name="username"
                                type="text"
                                required
                                className="mt-1 appearance-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-md focus:outline-none focus:ring-blue-500 focus:border-blue-500 focus:z-10 sm:text-sm"
                                value={formData.username}
                                onChange={handleChange}
                            />
                            {errors.username && (
                                <p className="mt-1 text-sm text-red-600">{errors.username[0]}</p>
                            )}
                        </div>

                        <div>
                            <label htmlFor="email" className="block text-sm font-medium text-gray-700">
                                Email *
                            </label>
                            <input
                                id="email"
                                name="email"
                                type="email"
                                required
                                className="mt-1 appearance-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-md focus:outline-none focus:ring-blue-500 focus:border-blue-500 focus:z-10 sm:text-sm"
                                value={formData.email}
                                onChange={handleChange}
                            />
                            {errors.email && (
                                <p className="mt-1 text-sm text-red-600">{errors.email[0]}</p>
                            )}
                        </div>

                        <div className="grid grid-cols-2 gap-4">
                            <div>
                                <label htmlFor="first_name" className="block text-sm font-medium text-gray-700">
                                    First Name *
                                </label>
                                <input
                                    id="first_name"
                                    name="first_name"
                                    type="text"
                                    required
                                    className="mt-1 appearance-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-md focus:outline-none focus:ring-blue-500 focus:border-blue-500 focus:z-10 sm:text-sm"
                                    value={formData.first_name}
                                    onChange={handleChange}
                                />
                            </div>

                            <div>
                                <label htmlFor="last_name" className="block text-sm font-medium text-gray-700">
                                    Last Name *
                                </label>
                                <input
                                    id="last_name"
                                    name="last_name"
                                    type="text"
                                    required
                                    className="mt-1 appearance-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-md focus:outline-none focus:ring-blue-500 focus:border-blue-500 focus:z-10 sm:text-sm"
                                    value={formData.last_name}
                                    onChange={handleChange}
                                />
                            </div>
                        </div>

                        <div>
                            <label htmlFor="password" className="block text-sm font-medium text-gray-700">
                                Password *
                            </label>
                            <input
                                id="password"
                                name="password"
                                type="password"
                                required
                                className="mt-1 appearance-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-md focus:outline-none focus:ring-blue-500 focus:border-blue-500 focus:z-10 sm:text-sm"
                                value={formData.password}
                                onChange={handleChange}
                            />
                            {errors.password && (
                                <p className="mt-1 text-sm text-red-600">{errors.password[0]}</p>
                            )}
                        </div>

                        <div>
                            <label htmlFor="password2" className="block text-sm font-medium text-gray-700">
                                Confirm Password *
                            </label>
                            <input
                                id="password2"
                                name="password2"
                                type="password"
                                required
                                className="mt-1 appearance-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-md focus:outline-none focus:ring-blue-500 focus:border-blue-500 focus:z-10 sm:text-sm"
                                value={formData.password2}
                                onChange={handleChange}
                            />
                        </div>
                    </div>

                    {errors.non_field_errors && (
                        <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative">
                            <span className="block sm:inline">{errors.non_field_errors[0]}</span>
                        </div>
                    )}

                    <div>
                        <button
                            type="submit"
                            disabled={loading}
                            className="group relative w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50"
                        >
                            {loading ? 'Creating account...' : 'Create account'}
                        </button>
                    </div>
                </form>
            </div>
        </div>
    );
};

export default Register;


================================================
FILE: frontend/src/components/Learning/AtomComplete.jsx
================================================
// frontend/src/components/Learning/AtomComplete.jsx

import React from 'react';
import { useLearning } from '../../context/LearningContext';

const AtomComplete = ({ atom, onContinue }) => {
    const { atomMastery, currentTheta, answers } = useLearning();

    // Calculate stats
    const totalQuestions = answers.length;
    const correctCount = answers.filter(a => a.correct).length;
    const accuracy = totalQuestions > 0 ? (correctCount / totalQuestions) * 100 : 0;
    const avgTime = answers.length > 0 
        ? Math.round(answers.reduce((sum, a) => sum + a.time_taken, 0) / answers.length) 
        : 0;

    return (
        <div className="bg-white rounded-lg shadow-lg p-8 text-center">
            {/* Success Icon */}
            <div className="mb-6">
                <div className="inline-flex items-center justify-center w-24 h-24 bg-green-100 rounded-full">
                    <span className="text-5xl">ðŸŽ‰</span>
                </div>
            </div>

            <h2 className="text-3xl font-bold text-gray-800 mb-2">Atom Complete!</h2>
            <p className="text-xl text-green-600 mb-8">You've mastered: {atom?.name}</p>

            {/* Stats Grid */}
            <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mb-8">
                <div className="bg-blue-50 p-4 rounded-lg">
                    <div className="text-2xl font-bold text-blue-600">
                        {Math.round(atomMastery * 100)}%
                    </div>
                    <div className="text-sm text-gray-600">Final Mastery</div>
                </div>
                
                <div className="bg-purple-50 p-4 rounded-lg">
                    <div className="text-2xl font-bold text-purple-600">
                        {accuracy.toFixed(0)}%
                    </div>
                    <div className="text-sm text-gray-600">Accuracy</div>
                </div>
                
                <div className="bg-green-50 p-4 rounded-lg">
                    <div className="text-2xl font-bold text-green-600">
                        {correctCount}/{totalQuestions}
                    </div>
                    <div className="text-sm text-gray-600">Correct</div>
                </div>
                
                <div className="bg-orange-50 p-4 rounded-lg">
                    <div className="text-2xl font-bold text-orange-600">
                        {avgTime}s
                    </div>
                    <div className="text-sm text-gray-600">Avg Time</div>
                </div>
            </div>

            {/* Theta Change */}
            <div className="mb-8 p-4 bg-gray-50 rounded-lg">
                <div className="text-sm text-gray-600">Ability (Î¸) Progress</div>
                <div className="text-2xl font-bold text-gray-800">
                    {currentTheta.toFixed(2)}
                </div>
            </div>

            {/* Continue Button */}
            <button
                onClick={onContinue}
                className="px-8 py-3 bg-green-600 text-white rounded-lg font-semibold hover:bg-green-700 transition"
            >
                Continue to Next Atom â†’
            </button>

            <p className="mt-4 text-sm text-gray-500">
                You're making great progress! Keep going.
            </p>
        </div>
    );
};

export default AtomComplete;


================================================
FILE: frontend/src/components/Learning/AtomList.jsx
================================================
import React from 'react';

const AtomList = ({ atoms, onStartAtom, conceptName, completedCount }) => {
    const getPhaseIcon = (phase) => {
        const icons = {
            'complete': '✅',
            'teaching': '📚',
            'diagnostic': '📝',
            'not_started': '⭕'
        };
        return icons[phase] || '📌';
    };

    const getPhaseColor = (phase) => {
        const colors = {
            'complete': 'text-green-600',
            'teaching': 'text-blue-600',
            'diagnostic': 'text-purple-600',
            'not_started': 'text-gray-400'
        };
        return colors[phase] || 'text-gray-600';
    };

    return (
        <div className="bg-white rounded-lg shadow-lg p-8">
            <h2 className="text-2xl font-bold mb-2">{conceptName}</h2>
            <p className="text-gray-600 mb-6">
                Completed {completedCount} of {atoms.length} concepts
            </p>

            <div className="space-y-3 mb-8">
                {atoms.map((atom) => (
                    <div
                        key={atom.id}
                        className={`flex items-center justify-between p-4 rounded-lg border ${
                            atom.phase === 'not_started'
                                ? 'border-gray-200 bg-gray-50'
                                : atom.phase === 'complete'
                                ? 'border-green-200 bg-green-50'
                                : 'border-blue-200 bg-blue-50'
                        }`}
                    >
                        <div className="flex items-center">
                            <span className="text-2xl mr-4">{getPhaseIcon(atom.phase)}</span>
                            <div>
                                <p className="font-medium text-lg">{atom.name}</p>
                                <p className={`text-sm ${getPhaseColor(atom.phase)}`}>
                                    {atom.phase === 'complete' && '✓ Mastered'}
                                    {atom.phase === 'teaching' && '📖 Learning in progress'}
                                    {atom.phase === 'diagnostic' && '📝 Questions ready'}
                                    {atom.phase === 'not_started' && '⏳ Not started'}
                                </p>
                                {atom.mastery_score > 0 && (
                                    <p className="text-xs text-gray-500 mt-1">
                                        Mastery: {Math.round(atom.mastery_score * 100)}%
                                    </p>
                                )}
                            </div>
                        </div>
                        
                        {atom.phase === 'not_started' && (
                            <button
                                onClick={() => onStartAtom(atom)}
                                className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
                            >
                                Start Learning
                            </button>
                        )}
                        
                        {atom.phase === 'teaching' && (
                            <button
                                onClick={() => onStartAtom(atom)}
                                className="px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700"
                            >
                                Continue
                            </button>
                        )}
                        
                        {atom.phase === 'complete' && (
                            <span className="text-green-600 font-medium">✓ Completed</span>
                        )}
                    </div>
                ))}
            </div>
        </div>
    );
};

export default AtomList;


================================================
FILE: frontend/src/components/Learning/AtomReview.jsx
================================================
import React, { useState } from 'react';

const AtomReview = ({ atom, metrics, onComplete, onSkip }) => {
    const [reviewMode, setReviewMode] = useState('summary');

    return (
        <div className="bg-white rounded-lg shadow-lg p-6">
            <h2 className="text-2xl font-bold mb-4">Review Required: {atom.name}</h2>
            
            {/* Performance Summary */}
            <div className="bg-red-50 border border-red-200 rounded-lg p-4 mb-6">
                <h3 className="font-semibold text-red-800 mb-2">Performance Analysis</h3>
                <div className="grid grid-cols-2 gap-4 text-sm">
                    <div>
                        <p className="text-gray-600">Accuracy</p>
                        <p className="text-xl font-bold text-red-600">
                            {Math.round(metrics.accuracy * 100)}%
                        </p>
                    </div>
                    <div>
                        <p className="text-gray-600">Mastery</p>
                        <p className="text-xl font-bold text-orange-600">
                            {Math.round(metrics.final_mastery * 100)}%
                        </p>
                    </div>
                    <div>
                        <p className="text-gray-600">Time Ratio</p>
                        <p className="text-xl font-bold text-blue-600">
                            {metrics.time_ratio.toFixed(2)}x
                        </p>
                    </div>
                    <div>
                        <p className="text-gray-600">Î¸ Change</p>
                        <p className={`text-xl font-bold ${metrics.theta_change > 0 ? 'text-green-600' : 'text-red-600'}`}>
                            {metrics.theta_change > 0 ? '+' : ''}{metrics.theta_change.toFixed(2)}
                        </p>
                    </div>
                </div>
            </div>

            {/* Error Analysis */}
            {metrics.error_count > 0 && (
                <div className="mb-6">
                    <h3 className="font-semibold mb-2">Error Types:</h3>
                    <div className="space-y-2">
                        {metrics.conceptual_errors > 0 && (
                            <div className="bg-purple-50 p-2 rounded">
                                <span className="font-medium">Conceptual:</span> {metrics.conceptual_errors} errors
                            </div>
                        )}
                        {metrics.procedural_errors > 0 && (
                            <div className="bg-blue-50 p-2 rounded">
                                <span className="font-medium">Procedural:</span> {metrics.procedural_errors} errors
                            </div>
                        )}
                        {metrics.factual_errors > 0 && (
                            <div className="bg-green-50 p-2 rounded">
                                <span className="font-medium">Factual:</span> {metrics.factual_errors} errors
                            </div>
                        )}
                        {metrics.guessing_errors > 0 && (
                            <div className="bg-yellow-50 p-2 rounded">
                                <span className="font-medium">Guessing:</span> {metrics.guessing_errors} errors
                            </div>
                        )}
                    </div>
                </div>
            )}

            {/* Review Options */}
            <div className="space-y-3">
                <button
                    onClick={() => setReviewMode('teaching')}
                    className="w-full bg-blue-600 text-white py-3 rounded-lg hover:bg-blue-700"
                >
                    Review Teaching Material
                </button>
                <button
                    onClick={() => setReviewMode('practice')}
                    className="w-full bg-green-600 text-white py-3 rounded-lg hover:bg-green-700"
                >
                    Practice with New Questions
                </button>
                <button
                    onClick={onSkip}
                    className="w-full bg-gray-200 text-gray-800 py-3 rounded-lg hover:bg-gray-300"
                >
                    Skip Review (Not Recommended)
                </button>
            </div>
        </div>
    );
};

export default AtomReview;


================================================
FILE: frontend/src/components/Learning/LearningProgress.jsx
================================================
import React, { useEffect } from 'react';
import { useLearning } from '../../context/LearningContext';

const LearningProgress = ({ onContinue }) => {
    const { learningProgress, loadLearningProgress, loading } = useLearning();

    useEffect(() => {
        loadLearningProgress();
    }, [loadLearningProgress]);

    const getPhaseIcon = (phase) => {
        const icons = {
            'complete': '✅',
            'teaching': '📚',
            'diagnostic': '📝',
            'not_started': '⭕'
        };
        return icons[phase] || '📌';
    };

    const getPhaseColor = (phase) => {
        const colors = {
            'complete': 'text-green-600',
            'teaching': 'text-blue-600',
            'diagnostic': 'text-purple-600',
            'not_started': 'text-gray-400'
        };
        return colors[phase] || 'text-gray-600';
    };

    if (loading && !learningProgress) {
        return (
            <div className="text-center py-12">
                <p className="text-gray-600">Loading progress...</p>
            </div>
        );
    }

    if (!learningProgress) {
        return (
            <div className="text-center py-12">
                <p className="text-red-600">Failed to load progress.</p>
            </div>
        );
    }

    return (
        <div className="max-w-4xl mx-auto">
            <h2 className="text-3xl font-bold mb-8">Your Learning Progress</h2>

            {/* Stats Cards */}
            <div className="bg-white rounded-lg shadow-lg p-8 mb-8">
                <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
                    <div className="bg-blue-50 p-4 rounded-lg text-center">
                        <p className="text-2xl font-bold text-blue-600">
                            {Math.round(learningProgress.overall_mastery * 100)}%
                        </p>
                        <p className="text-sm text-gray-600">Overall Mastery</p>
                    </div>
                    
                    <div className="bg-green-50 p-4 rounded-lg text-center">
                        <p className="text-2xl font-bold text-green-600">
                            {learningProgress.total_atoms || 0}
                        </p>
                        <p className="text-sm text-gray-600">Total Atoms</p>
                    </div>
                    
                    <div className="bg-orange-50 p-4 rounded-lg text-center">
                        <p className="text-2xl font-bold text-orange-600">
                            {learningProgress.learning_streak || 0} 🔥
                        </p>
                        <p className="text-sm text-gray-600">Learning Streak</p>
                    </div>
                </div>

                {/* Theta Score */}
                <div className="border-t pt-6">
                    <div className="flex justify-between items-center">
                        <span className="text-gray-700 font-medium">Ability (θ):</span>
                        <span className="text-lg font-semibold text-purple-600">
                            {learningProgress.overall_theta?.toFixed(2) || '0.00'}
                        </span>
                    </div>
                </div>
            </div>

            {/* Concepts */}
            <h3 className="text-xl font-bold mb-4">Concepts</h3>
            
            {learningProgress.concepts?.map((concept, idx) => (
                <div key={idx} className="bg-white rounded-lg shadow-lg p-6 mb-4">
                    <div className="flex justify-between items-center mb-4">
                        <h4 className="text-lg font-semibold">{concept.name}</h4>
                        <span className="text-sm text-gray-500">
                            {concept.mastered_count}/{concept.total_count} mastered
                        </span>
                    </div>

                    <div className="space-y-3">
                        {concept.atoms.map((atom, atomIdx) => (
                            <div key={atomIdx} className="flex items-center justify-between p-3 bg-gray-50 rounded-lg">
                                <div className="flex items-center">
                                    <span className="text-xl mr-3">{getPhaseIcon(atom.phase)}</span>
                                    <div>
                                        <p className="font-medium">{atom.name}</p>
                                        <p className="text-xs text-gray-500">
                                            Mastery: {Math.round(atom.mastery * 100)}%
                                            {atom.streak > 0 && ` • Streak: ${atom.streak}`}
                                        </p>
                                    </div>
                                </div>
                                <span className={`text-sm font-medium ${getPhaseColor(atom.phase)}`}>
                                    {atom.phase === 'complete' ? 'Mastered' : 
                                     atom.phase === 'teaching' ? 'Learning' :
                                     atom.phase === 'diagnostic' ? 'In Progress' : 'Not Started'}
                                </span>
                            </div>
                        ))}
                    </div>
                </div>
            ))}

            <div className="flex justify-center mt-8">
                <button
                    onClick={onContinue}
                    className="bg-blue-600 text-white px-8 py-3 rounded-lg font-semibold hover:bg-blue-700"
                >
                    Continue Learning
                </button>
            </div>
        </div>
    );
};

export default LearningProgress;


================================================
FILE: frontend/src/components/Learning/LearningRoute.jsx
================================================
import React from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { LearningProvider } from '../../context/LearningContext';
import TeachingFirstFlow from './TeachingFirstFlow';

const LearningRoute = () => {
    const { conceptId } = useParams();
    const navigate = useNavigate();
    
    if (!conceptId) {
        return (
            <div className="text-center py-12">
                <p className="text-red-600">No concept selected.</p>
                <button 
                    onClick={() => navigate('/dashboard')}
                    className="mt-4 px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
                >
                    Go to Dashboard
                </button>
            </div>
        );
    }

    return (
        <LearningProvider>
            <TeachingFirstFlow conceptId={parseInt(conceptId)} />
        </LearningProvider>
    );
};

export default LearningRoute;


================================================
FILE: frontend/src/components/Learning/QuestionsFromTeaching.jsx
================================================
Error reading file with 'cp1252': 'charmap' codec can't decode byte 0x9d in position 2580: character maps to <undefined>


================================================
FILE: frontend/src/components/Learning/StartAnyConceptSession.jsx
================================================
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { useLearning } from '../../context/LearningContext';

const StartAnyConceptSession = () => {
    const [formData, setFormData] = useState({
        subject: '',
        concept: '',
        knowledge_level: 'intermediate'
    });
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState('');
    const [generatedAtoms, setGeneratedAtoms] = useState(null);
    
    const navigate = useNavigate();
    const { generateConcept } = useLearning();

    const handleChange = (e) => {
        setFormData({
            ...formData,
            [e.target.name]: e.target.value
        });
    };

    const handleSubmit = async (e) => {
        e.preventDefault();
        setError('');
        setLoading(true);

        const result = await generateConcept(
            formData.subject,
            formData.concept,
            formData.knowledge_level
        );

        if (result.success) {
            setGeneratedAtoms(result.data);
        } else {
            setError(result.error || 'Failed to generate concept');
        }

        setLoading(false);
    };

    const handleStartLearning = () => {
        if (generatedAtoms) {
            navigate(`/learn/${generatedAtoms.concept_id}`);
        }
    };

    const knowledgeLevels = [
        { value: 'zero', label: 'Zero Knowledge (Complete Beginner)' },
        { value: 'beginner', label: 'Beginner (Some basic understanding)' },
        { value: 'intermediate', label: 'Intermediate (Comfortable with basics)' },
        { value: 'advanced', label: 'Advanced (Strong understanding)' }
    ];

    return (
        <div className="min-h-screen bg-gray-50 py-12">
            <div className="max-w-2xl mx-auto px-4">
                <div className="bg-white rounded-lg shadow-lg p-8">
                    <h1 className="text-2xl font-bold text-gray-800 mb-6">
                        Start New Learning Session
                    </h1>

                    {!generatedAtoms ? (
                        <form onSubmit={handleSubmit} className="space-y-6">
                            {/* Subject */}
                            <div>
                                <label className="block text-sm font-medium text-gray-700 mb-2">
                                    Subject *
                                </label>
                                <input
                                    type="text"
                                    name="subject"
                                    value={formData.subject}
                                    onChange={handleChange}
                                    required
                                    placeholder="e.g., Microprocessor, Mathematics, Physics"
                                    className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                                />
                            </div>

                            {/* Concept */}
                            <div>
                                <label className="block text-sm font-medium text-gray-700 mb-2">
                                    Concept *
                                </label>
                                <input
                                    type="text"
                                    name="concept"
                                    value={formData.concept}
                                    onChange={handleChange}
                                    required
                                    placeholder="e.g., Memory Organization, Calculus, Quantum Mechanics"
                                    className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                                />
                            </div>

                            {/* Knowledge Level */}
                            <div>
                                <label className="block text-sm font-medium text-gray-700 mb-2">
                                    Your Knowledge Level *
                                </label>
                                <select
                                    name="knowledge_level"
                                    value={formData.knowledge_level}
                                    onChange={handleChange}
                                    className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                                >
                                    {knowledgeLevels.map(level => (
                                        <option key={level.value} value={level.value}>
                                            {level.label}
                                        </option>
                                    ))}
                                </select>
                            </div>

                            {error && (
                                <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded">
                                    {error}
                                </div>
                            )}

                            <button
                                type="submit"
                                disabled={loading}
                                className="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg transition disabled:opacity-50 disabled:cursor-not-allowed"
                            >
                                {loading ? 'Generating atoms...' : 'Generate Learning Path'}
                            </button>

                            <button
                                type="button"
                                onClick={() => navigate('/dashboard')}
                                className="w-full bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-3 px-4 rounded-lg transition"
                            >
                                Back to Dashboard
                            </button>
                        </form>
                    ) : (
                        <div className="space-y-6">
                            {/* Success message */}
                            <div className="bg-green-50 border border-green-200 rounded-lg p-6">
                                <h3 className="text-lg font-semibold text-green-800 mb-2">
                                    âœ“ Learning Path Generated!
                                </h3>
                                <p className="text-green-700">
                                    We've created {generatedAtoms.atoms.length} atomic concepts for "{generatedAtoms.concept_name}".
                                </p>
                            </div>

                            {/* Atoms list */}
                            <div>
                                <h4 className="font-medium text-gray-700 mb-3">Atomic Concepts:</h4>
                                <div className="space-y-2">
                                    {generatedAtoms.atoms.map((atom, index) => (
                                        <div 
                                            key={atom.id}
                                            className="flex items-center p-3 bg-gray-50 rounded-lg"
                                        >
                                            <span className="w-8 h-8 bg-blue-100 text-blue-800 rounded-full flex items-center justify-center font-bold mr-3">
                                                {index + 1}
                                            </span>
                                            <span className="text-gray-800">{atom.name}</span>
                                        </div>
                                    ))}
                                </div>
                            </div>

                            {/* Start learning button */}
                            <button
                                onClick={handleStartLearning}
                                className="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg transition"
                            >
                                Start Learning Now
                            </button>

                            {/* Note */}
                            <p className="text-sm text-gray-500 text-center">
                                You'll learn each concept one by one, with teaching followed by assessment.
                            </p>
                        </div>
                    )}
                </div>
            </div>
        </div>
    );
};

export default StartAnyConceptSession;


================================================
FILE: frontend/src/components/Learning/StartAnyConceptSessionRoute.jsx
================================================
import React from 'react';
import { LearningProvider } from '../../context/LearningContext';
import StartAnyConceptSession from './StartAnyConceptSession';

const StartAnyConceptSessionRoute = () => {
    return (
        <LearningProvider>
            <StartAnyConceptSession />
        </LearningProvider>
    );
};

export default StartAnyConceptSessionRoute;


================================================
FILE: frontend/src/components/Learning/TeachingFirstFlow.jsx
================================================
Error reading file with 'cp1252': 'charmap' codec can't decode byte 0x8f in position 8956: character maps to <undefined>


================================================
FILE: frontend/src/components/Learning/TeachingModule.jsx
================================================
Error reading file with 'cp1252': 'charmap' codec can't decode byte 0x90 in position 3033: character maps to <undefined>


================================================
FILE: frontend/src/context/AuthContext.jsx
================================================
import React, { createContext, useState, useContext, useEffect } from 'react';
import axios from '../axiosConfig';
import { useNavigate } from 'react-router-dom';

const AuthContext = createContext(null);

export const AuthProvider = ({ children }) => {
    const [user, setUser] = useState(null);
    const [loading, setLoading] = useState(true);
    const navigate = useNavigate();

    // Check for existing token on mount
    useEffect(() => {
        const token = localStorage.getItem('access_token');
        if (token) {
            fetchUser();
        } else {
            setLoading(false);
        }
    }, []);

    const fetchUser = async () => {
        try {
            const response = await axios.get('/auth/api/dashboard/');
            setUser(response.data.user);
        } catch (error) {
            console.error("Failed to fetch user:", error);
            localStorage.removeItem('access_token');
            localStorage.removeItem('refresh_token');
        } finally {
            setLoading(false);
        }
    };

    const login = async (username, password) => {
        try {
            const response = await axios.post('/auth/api/login/', {
                username,
                password
            });
            
            const { access, refresh, user } = response.data;
            
            localStorage.setItem('access_token', access);
            localStorage.setItem('refresh_token', refresh);
            setUser(user);
            
            return { success: true };
        } catch (error) {
            return { 
                success: false, 
                error: error.response?.data?.error || 'Login failed' 
            };
        }
    };

    const register = async (userData) => {
        try {
            const response = await axios.post('/auth/api/register/', userData);
            return { success: true, data: response.data };
        } catch (error) {
            return { 
                success: false, 
                error: error.response?.data || 'Registration failed' 
            };
        }
    };

    const logout = () => {
        localStorage.removeItem('access_token');
        localStorage.removeItem('refresh_token');
        setUser(null);
        navigate('/login');
    };

    const value = {
        user,
        login,
        register,
        logout,
        loading
    };

    return (
        <AuthContext.Provider value={value}>
            {children}
        </AuthContext.Provider>
    );
};

export const useAuth = () => {
    const context = useContext(AuthContext);
    if (!context) {
        throw new Error('useAuth must be used within an AuthProvider');
    }
    return context;
};


================================================
FILE: frontend/src/context/LearningContext.jsx
================================================
// frontend/src/context/LearningContext.jsx - Enhanced version

import React, { createContext, useCallback, useMemo, useState, useContext, useRef } from 'react';
import axios from '../axiosConfig';

const LearningContext = createContext(null);

export const LearningProvider = ({ children }) => {
    const [currentSession, setCurrentSession] = useState(null);
    const [currentAtom, setCurrentAtom] = useState(null);
    const [learningProgress, setLearningProgress] = useState(null);
    const [loading, setLoading] = useState(false);
    const [knowledgeLevel, setKnowledgeLevel] = useState('intermediate');
    
    // Real-time tracking
    const [currentQuestions, setCurrentQuestions] = useState([]);
    const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
    const [answers, setAnswers] = useState([]);
    const [atomMastery, setAtomMastery] = useState(0.3);
    const [currentTheta, setCurrentTheta] = useState(0.0);
    const [pacingDecision, setPacingDecision] = useState('stay');
    const [nextAction, setNextAction] = useState('continue_practice');
    const [showTeaching, setShowTeaching] = useState(false);
    const [teachingContent, setTeachingContent] = useState(null);
    const [metrics, setMetrics] = useState({});
    
    // Timers
    const questionStartTime = useRef(null);
    const [timeSpent, setTimeSpent] = useState(0);

    // Generate atoms for a concept (no questions)
    const generateConcept = useCallback(async (subject, concept, knowledgeLevel = 'intermediate') => {
        setLoading(true);
        try {
            const response = await axios.post('/auth/api/generate-concept/', {
                subject: subject,
                concept: concept,
                knowledge_level: knowledgeLevel
            });
            return { success: true, data: response.data };
        } catch (error) {
            return {
                success: false,
                error: error.response?.data?.error || 'Failed to generate concept'
            };
        } finally {
            setLoading(false);
        }
    }, []);

    // Start teaching session for a concept
    const startTeachingSession = useCallback(async (conceptId, level = 'intermediate') => {
        setLoading(true);
        setKnowledgeLevel(level);
        setAnswers([]);
        setAtomMastery(0.3);
        setPacingDecision('stay');
        
        try {
            const response = await axios.post('/auth/api/start-teaching-session/', {
                concept_id: conceptId,
                knowledge_level: level
            });
            
            setCurrentSession(response.data);
            
            // If there's a current atom, set it
            if (response.data.current_atom) {
                setCurrentAtom(response.data.current_atom);
            }
            
            return { success: true, data: response.data };
        } catch (error) {
            return {
                success: false,
                error: error.response?.data?.error || 'Failed to start session'
            };
        } finally {
            setLoading(false);
        }
    }, []);

    // Get teaching content for an atom
    const getTeachingContent = useCallback(async ({ session_id, atom_id }) => {
        setLoading(true);
        setShowTeaching(true);
        try {
            const response = await axios.post('/auth/api/teaching-content/', {
                session_id: session_id,
                atom_id: atom_id
            });
            
            setTeachingContent(response.data);
            setCurrentAtom({
                id: atom_id,
                ...response.data
            });
            
            return { success: true, data: response.data };
        } catch (error) {
            return {
                success: false,
                error: error.response?.data?.error || 'Failed to get teaching content'
            };
        } finally {
            setLoading(false);
        }
    }, []);

    // Generate questions based on teaching content
    const generateQuestionsFromTeaching = useCallback(async ({ session_id, atom_id }) => {
        setLoading(true);
        try {
            const response = await axios.post('/auth/api/generate-questions-from-teaching/', {
                session_id: session_id,
                atom_id: atom_id
            });
            
            setCurrentQuestions(response.data.questions || []);
            setCurrentQuestionIndex(0);
            
            // Start timer for first question
            questionStartTime.current = Date.now();
            
            return { success: true, data: response.data };
        } catch (error) {
            return {
                success: false,
                error: error.response?.data?.error || 'Failed to generate questions'
            };
        } finally {
            setLoading(false);
        }
    }, []);

    // Submit answer for an atom question with REAL-TIME updates
    const submitAtomAnswer = useCallback(async ({ 
        session_id, 
        atom_id, 
        question_index, 
        selected,
        forceTimeTaken = null
    }) => {
        // Calculate time taken if not provided
        let time_taken = forceTimeTaken;
        if (time_taken === null && questionStartTime.current) {
            time_taken = Math.round((Date.now() - questionStartTime.current) / 1000);
        } else if (time_taken === null) {
            time_taken = 30; // Default fallback
        }
        
        try {
            const response = await axios.post('/auth/api/submit-atom-answer/', {
                session_id: session_id,
                atom_id: atom_id,
                question_index: question_index,
                selected: selected,
                time_taken: time_taken
            });
            
            const data = response.data;
            
            // REAL-TIME UI UPDATES based on response
            setAtomMastery(data.updated_mastery);
            setCurrentTheta(data.updated_theta);
            setPacingDecision(data.pacing_decision);
            setNextAction(data.next_action);
            setMetrics(data.metrics || {});
            
            // Store answer
            const newAnswer = {
                question_index,
                selected,
                correct: data.correct,
                error_type: data.error_type,
                time_taken,
                mastery_after: data.updated_mastery,
                pacing_decision: data.pacing_decision
            };
            
            setAnswers(prev => [...prev, newAnswer]);
            
            // Check if atom is complete
            if (data.atom_complete) {
                // Move to next atom or show completion
                if (data.next_atom) {
                    setCurrentAtom(prev => ({
                        ...prev,
                        next_atom: data.next_atom
                    }));
                }
            }
            
            // Update session data with pacing info
            setCurrentSession(prev => {
                if (!prev) return prev;
                return {
                    ...prev,
                    last_pacing: data.pacing_decision,
                    current_mastery: data.updated_mastery,
                    current_theta: data.updated_theta
                };
            });
            
            return { success: true, data };
        } catch (error) {
            return {
                success: false,
                error: error.response?.data?.error || 'Failed to submit answer'
            };
        }
    }, []);

    // Start next question with timer
    const nextQuestion = useCallback(() => {
        if (currentQuestionIndex < currentQuestions.length - 1) {
            setCurrentQuestionIndex(prev => prev + 1);
            questionStartTime.current = Date.now();
        }
    }, [currentQuestionIndex, currentQuestions.length]);

    // Complete atom and determine next action
    const completeAtom = useCallback(async ({ session_id, atom_id, continue_learning }) => {
        try {
            const response = await axios.post('/auth/api/complete-atom/', {
                session_id: session_id,
                atom_id: atom_id,
                continue_learning: continue_learning
            });
            
            const data = response.data;
            
            // Handle next steps based on pacing
            if (data.next_action === 'next_atom' && data.next_atom) {
                setCurrentAtom(data.next_atom);
                setShowTeaching(true); // Show teaching for next atom
                setCurrentQuestions([]);
                setAnswers([]);
            } else if (data.concept_complete) {
                // All atoms complete
                setCurrentAtom(null);
                setCurrentSession(null);
            }
            
            return { success: true, data };
        } catch (error) {
            return {
                success: false,
                error: error.response?.data?.error || 'Failed to complete atom'
            };
        }
    }, []);

    // Load learning progress
    const loadLearningProgress = useCallback(async () => {
        setLoading(true);
        try {
            const response = await axios.get('/auth/api/progress/');
            setLearningProgress(response.data);
            return { success: true, data: response.data };
        } catch (error) {
            return {
                success: false,
                error: error.response?.data?.error || 'Failed to load progress'
            };
        } finally {
            setLoading(false);
        }
    }, []);

    // Reset for new atom
    const resetForNewAtom = useCallback(() => {
        setCurrentQuestions([]);
        setCurrentQuestionIndex(0);
        setAnswers([]);
        setShowTeaching(true);
        setPacingDecision('stay');
        questionStartTime.current = null;
    }, []);

    const value = useMemo(() => ({
        // State
        currentSession,
        currentAtom,
        learningProgress,
        loading,
        knowledgeLevel,
        
        // Real-time tracking
        currentQuestions,
        currentQuestionIndex,
        answers,
        atomMastery,
        currentTheta,
        pacingDecision,
        nextAction,
        showTeaching,
        teachingContent,
        metrics,
        timeSpent,
        
        // Setters
        setKnowledgeLevel,
        setShowTeaching,
        
        // Core methods
        generateConcept,
        startTeachingSession,
        getTeachingContent,
        generateQuestionsFromTeaching,
        submitAtomAnswer,
        completeAtom,
        loadLearningProgress,
        nextQuestion,
        resetForNewAtom
        
    }), [
        currentSession,
        currentAtom,
        learningProgress,
        loading,
        knowledgeLevel,
        currentQuestions,
        currentQuestionIndex,
        answers,
        atomMastery,
        currentTheta,
        pacingDecision,
        nextAction,
        showTeaching,
        teachingContent,
        metrics,
        timeSpent,
        generateConcept,
        startTeachingSession,
        getTeachingContent,
        generateQuestionsFromTeaching,
        submitAtomAnswer,
        completeAtom,
        loadLearningProgress,
        nextQuestion,
        resetForNewAtom
    ]);

    return (
        <LearningContext.Provider value={value}>
            {children}
        </LearningContext.Provider>
    );
};

export const useLearning = () => {
    const context = useContext(LearningContext);
    if (!context) {
        throw new Error('useLearning must be used within a LearningProvider');
    }
    return context;
};

