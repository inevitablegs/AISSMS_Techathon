Directory structure:
└── AISSMS_Techathon/
    ├── tempCodeRunnerFile.python
    ├── backend/
    │   ├── a.py
    │   ├── manage.py
    │   ├── req.txt
    │   ├── accounts/
    │   │   ├── __init__.py
    │   │   ├── admin.py
    │   │   ├── apps.py
    │   │   ├── models.py
    │   │   ├── serializers.py
    │   │   ├── tests.py
    │   │   ├── urls.py
    │   │   ├── views.py
    │   │   └── migrations/
    │   │       ├── 0001_initial.py
    │   │       ├── 0002_concept_created_by.py
    │   │       ├── 0003_learningsession_knowledge_level_and_more.py
    │   │       ├── 0004_add_error_history_default.py
    │   │       ├── 0005_learningsession_break_count_and_more.py
    │   │       ├── 0006_userxp.py
    │   │       └── __init__.py
    │   ├── core/
    │   │   ├── __init__.py
    │   │   ├── asgi.py
    │   │   ├── settings.py
    │   │   ├── urls.py
    │   │   └── wsgi.py
    │   └── learning_engine/
    │       ├── __init__.py
    │       ├── adaptive_flow.py
<<<<<<< HEAD
    │       ├── ai_assistant.py
=======
>>>>>>> 27ca5f792972d0c6644ef01c0171d1c6ce25ce32
    │       ├── external_resources.py
    │       ├── knowledge_tracing.py
    │       ├── models.py
    │       ├── pacing_engine.py
    │       ├── question_generator.py
    │       └── utils.py
    └── frontend/
        ├── README.md
        ├── eslint.config.js
        ├── index.html
        ├── package.json
        ├── postcss.config.js
        ├── tailwind.config.js
        ├── vite.config.js
        └── src/
            ├── App.css
            ├── App.jsx
            ├── axiosConfig.js
            ├── index.css
            ├── main.jsx
            ├── components/
            │   ├── Dashboard.jsx
            │   ├── Home.jsx
            │   ├── Leaderboard.jsx
            │   ├── Login.jsx
            │   ├── Navbar.jsx
            │   ├── Progress.jsx
            │   ├── ProtectedRoute.jsx
            │   ├── Register.jsx
            │   └── Learning/
            │       ├── AtomComplete.jsx
            │       ├── AtomList.jsx
            │       ├── AtomReview.jsx
            │       ├── ExternalResources.jsx
            │       ├── FatigueIndicator.jsx
            │       ├── LearningProgress.jsx
            │       ├── LearningRoute.jsx
            │       ├── LearningVelocityGraph.jsx
            │       ├── QuestionsFromTeaching.jsx
            │       ├── StartAnyConceptSession.jsx
            │       ├── StartAnyConceptSessionRoute.jsx
            │       ├── TeachingFirstFlow.jsx
<<<<<<< HEAD
            │       ├── TeachingModule.jsx
            │       └── WeakTopicDetector.jsx
            ├── context/
            │   ├── AuthContext.jsx
            │   ├── LearningContext.jsx
            │   └── ThemeContext.jsx
            └── pages/
                └── AIAssistantPage.jsx
=======
            │       └── TeachingModule.jsx
            └── context/
                ├── AuthContext.jsx
                ├── LearningContext.jsx
                └── ThemeContext.jsx
>>>>>>> 27ca5f792972d0c6644ef01c0171d1c6ce25ce32

================================================
FILE: tempCodeRunnerFile.python
================================================
# backend/test_question_generator.py

import os
import sys
import django

# Setup Django environment
sys.path.append(os.path.dirname(os.path.abspath(__file__)))
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'core.settings')
django.setup()

from learning_engine.question_generator import QuestionGenerator
from django.conf import settings

def test_generator():
    print("=" * 50)
    print("Testing QuestionGenerator")
    print("=" * 50)
    
    print(f"GROQ_API_KEY present: {'Yes' if settings.GROQ_API_KEY else 'No'}")
    print(f"GOOGLE_API_KEY present: {'Yes' if settings.GOOGLE_API_KEY else 'No'}")
    
    generator = QuestionGenerator()
    print(f"Groq client initialized: {'Yes' if generator.groq_client else 'No'}")
    print(f"Gemini model initialized: {'Yes' if generator.gemini_model else 'No'}")
    
    if not generator.groq_client and not generator.gemini_model:
        print("\n❌ ERROR: No AI clients available! Check your API keys.")
        return
    
    print("\n" + "=" * 50)
    print("Test 1: Generate atoms")
    print("=" * 50)
    atoms = generator.generate_atoms("Microprocessor", "Memory Organization")
    print(f"Generated atoms: {atoms}")
    
    if atoms:
        print("\n" + "=" * 50)
        print("Test 2: Generate questions for first atom")
        print("=" * 50)
        questions = generator.generate_questions(
            subject="Microprocessor",
            concept="Memory Organization",
            atom=atoms[0],
            need_easy=2,
            need_medium=2,
            knowledge_level='intermediate'
        )
        print(f"Generated {len(questions)} questions")
        for i, q in enumerate(questions):
            print(f"\nQ{i+1}: {q.get('question', 'No question')}")
            print(f"   Difficulty: {q.get('difficulty')}")
            print(f"   Cognitive: {q.get('cognitive_operation')}")
            print(f"   Time: {q.get('estimated_time')}s")
    
    print("\n" + "=" * 50)
    print("Test 3: Generate complete concept")
    print("=" * 50)
    result = generator.generate_complete_concept("Microprocessor", "Memory Organization")
    print(f"Generated concept with {len(result.get('atoms', {}))} atoms")
    for atom_name, atom_data in result['atoms'].items():
        print(f"  - {atom_name}: {len(atom_data['questions'])} questions")

if __name__ == "__main__":
    test_generator()


================================================
FILE: backend/a.py
================================================
# backend/test_question_generator.py

import os
import sys
import django

# Setup Django environment
sys.path.append(os.path.dirname(os.path.abspath(__file__)))
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'core.settings')
django.setup()

from learning_engine.question_generator import QuestionGenerator
from django.conf import settings

def test_generator():
    print("=" * 50)
    print("Testing QuestionGenerator")
    print("=" * 50)
    
    print(f"GROQ_API_KEY present: {'Yes' if settings.GROQ_API_KEY else 'No'}")
    print(f"GOOGLE_API_KEY present: {'Yes' if settings.GOOGLE_API_KEY else 'No'}")
    
    generator = QuestionGenerator()
    print(f"Groq client initialized: {'Yes' if generator.groq_client else 'No'}")
    print(f"Gemini model initialized: {'Yes' if generator.gemini_model else 'No'}")
    
    if not generator.groq_client and not generator.gemini_model:
        print("\n❌ ERROR: No AI clients available! Check your API keys.")
        return
    
    print("\n" + "=" * 50)
    print("Test 1: Generate atoms")
    print("=" * 50)
    atoms = generator.generate_atoms("Microprocessor", "Memory Organization")
    print(f"Generated atoms: {atoms}")
    
    if atoms:
        print("\n" + "=" * 50)
        print("Test 2: Generate questions for first atom")
        print("=" * 50)
        questions = []
        questions.extend(generator.generate_questions(
            subject="Microprocessor",
            concept="Memory Organization",
            atom=atoms[0],
            target_difficulty="easy",
            count=2,
            knowledge_level='intermediate'
        ))
        questions.extend(generator.generate_questions(
            subject="Microprocessor",
            concept="Memory Organization",
            atom=atoms[0],
            target_difficulty="medium",
            count=2,
            knowledge_level='intermediate'
        ))
        print(f"Generated {len(questions)} questions")
        for i, q in enumerate(questions):
            print(f"\nQ{i+1}: {q.get('question', 'No question')}")
            print(f"   Difficulty: {q.get('difficulty')}")
            print(f"   Cognitive: {q.get('cognitive_operation')}")
            print(f"   Time: {q.get('estimated_time')}s")
    
    print("\n" + "=" * 50)
    print("Test 3: Generate complete concept")
    print("=" * 50)
    result = generator.generate_complete_concept("Microprocessor", "Memory Organization")
    print(f"Generated concept with {len(result.get('atoms', {}))} atoms")
    for atom_name, atom_data in result['atoms'].items():
        print(f"  - {atom_name}: {len(atom_data['questions'])} questions")

if __name__ == "__main__":
    test_generator()


================================================
FILE: backend/manage.py
================================================
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'core.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()



================================================
FILE: backend/req.txt
================================================
pip install django djangorestframework
pip install djangorestframework-simplejwt
pip install django-cors-headers
pip install youtube-search-python
pip install serpapi
<<<<<<< HEAD
pip install google.generativeai
pip install youtube-search
pip install dotenv groq numpy

=======
>>>>>>> 27ca5f792972d0c6644ef01c0171d1c6ce25ce32


================================================
FILE: backend/accounts/__init__.py
================================================
[Empty file]


================================================
FILE: backend/accounts/admin.py
================================================
from django.contrib import admin

# Register your models here.



================================================
FILE: backend/accounts/apps.py
================================================
from django.apps import AppConfig


class AccountsConfig(AppConfig):
    name = 'accounts'



================================================
FILE: backend/accounts/models.py
================================================
from django.db import models
from django.contrib.auth.models import User
import json

class LearningProfile(models.Model):
    """Student's learning profile and progress"""
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='learning_profile')
    overall_theta = models.FloatField(default=0.0)  # IRT ability parameter
    current_subject = models.CharField(max_length=100, blank=True)
    current_concept = models.CharField(max_length=100, blank=True)
    learning_streak = models.IntegerField(default=0)
    total_time_spent = models.IntegerField(default=0)  # in minutes
    last_active = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'learning_profile'

class Concept(models.Model):
    """Learning concepts and atoms"""
    DIFFICULTY_CHOICES = [
        ('easy', 'Easy'),
        ('medium', 'Medium'),
        ('hard', 'Hard'),
    ]
    
    name = models.CharField(max_length=200)
    subject = models.CharField(max_length=100)
    created_by = models.ForeignKey(
        User,
        null=True,
        blank=True,
        on_delete=models.SET_NULL,
        related_name='created_concepts'
    )
    description = models.TextField(blank=True)
    prerequisites = models.ManyToManyField('self', symmetrical=False, blank=True)
    difficulty = models.CharField(max_length=10, choices=DIFFICULTY_CHOICES, default='medium')
    order = models.IntegerField(default=0)
    
    class Meta:
        ordering = ['subject', 'order']
        unique_together = ['name', 'subject', 'created_by']

class TeachingAtom(models.Model):
    """Atomic learning units"""
    PHASE_CHOICES = [
        ('diagnostic', 'Diagnostic'),
        ('teaching', 'Teaching'),
        ('practice', 'Practice'),
        ('reinforcement', 'Reinforcement'),
        ('mastery_check', 'Mastery Check'),
        ('complete', 'Complete'),
    ]
    
    name = models.CharField(max_length=200)
    concept = models.ForeignKey(Concept, on_delete=models.CASCADE, related_name='atoms')
    explanation = models.TextField(blank=True)
    analogy = models.TextField(blank=True)
    examples = models.JSONField(default=list)
    order = models.IntegerField(default=0)
    
    class Meta:
        ordering = ['concept', 'order']

class Question(models.Model):
    """Practice questions"""
    DIFFICULTY_CHOICES = [
        ('easy', 'Easy'),
        ('medium', 'Medium'),
        ('hard', 'Hard'),
    ]
    
    COGNITIVE_CHOICES = [
        ('recall', 'Recall'),
        ('apply', 'Apply'),
        ('analyze', 'Analyze'),
    ]
    
    atom = models.ForeignKey(TeachingAtom, on_delete=models.CASCADE, related_name='questions')
    difficulty = models.CharField(max_length=10, choices=DIFFICULTY_CHOICES)
    cognitive_operation = models.CharField(max_length=10, choices=COGNITIVE_CHOICES)
    estimated_time = models.IntegerField(default=60)  # in seconds
    question_text = models.TextField()
    options = models.JSONField(default=list)
    correct_index = models.IntegerField()
    
    def to_dict(self):
        return {
            'id': self.id,
            'difficulty': self.difficulty,
            'cognitive_operation': self.cognitive_operation,
            'estimated_time': self.estimated_time,
            'question': self.question_text,
            'options': self.options,
            'correct_index': self.correct_index,
        }

class StudentProgress(models.Model):
    """Track student progress on atoms â€” enriched for 10-feature pacing engine."""
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='progress')
    atom = models.ForeignKey(TeachingAtom, on_delete=models.CASCADE)
    mastery_score = models.FloatField(default=0.3)
    phase = models.CharField(max_length=20, choices=TeachingAtom.PHASE_CHOICES, default='diagnostic')
    streak = models.IntegerField(default=0)
    hint_usage = models.IntegerField(default=0)
    error_history = models.JSONField(default=list)
    retention_verified = models.BooleanField(default=False)
    last_practiced = models.DateTimeField(auto_now=True)
    times_practiced = models.IntegerField(default=0)

    # â”€â”€ Feature 2: per-atom learning speed â”€â”€
    time_per_question = models.JSONField(default=list, blank=True)  # list of floats (seconds)

    # â”€â”€ Feature 6: retention tracking â”€â”€
    retention_score = models.FloatField(default=1.0)
    retention_checks_passed = models.IntegerField(default=0)
    retention_checks_failed = models.IntegerField(default=0)
    next_review_at = models.DateTimeField(null=True, blank=True)

    # â”€â”€ Feature 10: velocity snapshots â”€â”€
    velocity_snapshots = models.JSONField(default=list, blank=True)

    class Meta:
        unique_together = ['user', 'atom']


    
class KnowledgeLevel(models.TextChoices):
    ZERO = 'zero', 'Zero Knowledge'
    BEGINNER = 'beginner', 'Beginner'
    INTERMEDIATE = 'intermediate', 'Intermediate'
    ADVANCED = 'advanced', 'Advanced'


class LearningSession(models.Model):
    """Track learning sessions â€” enriched for 10-feature pacing engine."""
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='learning_sessions')
    concept = models.ForeignKey(Concept, on_delete=models.CASCADE)
    start_time = models.DateTimeField(auto_now_add=True)
    end_time = models.DateTimeField(null=True, blank=True)
    questions_answered = models.IntegerField(default=0)
    correct_answers = models.IntegerField(default=0)
    hints_used = models.IntegerField(default=0)
    session_data = models.JSONField(default=dict)
    knowledge_level = models.CharField(
        max_length=20,
        choices=KnowledgeLevel.choices,
        default=KnowledgeLevel.ZERO
    )
    user_feedback = models.JSONField(default=dict)

    # â”€â”€ Feature 8: fatigue tracking â”€â”€
    fatigue_level = models.CharField(max_length=20, default='fresh')   # fresh|mild|moderate|high|critical
    break_count = models.IntegerField(default=0)
    last_break_at = models.DateTimeField(null=True, blank=True)

    # â”€â”€ Feature 9: engagement â”€â”€
    engagement_score = models.FloatField(default=0.7)
    consecutive_skips = models.IntegerField(default=0)

    # â”€â”€ Feature 10: session-level velocity snapshots â”€â”€
    velocity_data = models.JSONField(default=list, blank=True)  


class UserXP(models.Model):
    """Track XP points for leaderboard"""
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='xp_profile')
    total_xp = models.IntegerField(default=0)
    questions_xp = models.IntegerField(default=0)
    atoms_xp = models.IntegerField(default=0)
    concepts_xp = models.IntegerField(default=0)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = 'user_xp'
        ordering = ['-total_xp']

    def __str__(self):
        return f"{self.user.username} - {self.total_xp} XP"

    def award_xp(self, amount, category='questions'):
        """Award XP and update totals"""
        self.total_xp += amount
        if category == 'questions':
            self.questions_xp += amount
        elif category == 'atoms':
            self.atoms_xp += amount
        elif category == 'concepts':
            self.concepts_xp += amount
        self.save()



================================================
FILE: backend/accounts/serializers.py
================================================
from django.contrib.auth.models import User
from django.contrib.auth.password_validation import validate_password
from rest_framework import serializers
from rest_framework.validators import UniqueValidator

class RegisterSerializer(serializers.ModelSerializer):
    email = serializers.EmailField(
        required=True,
        validators=[UniqueValidator(queryset=User.objects.all())]
    )
    password = serializers.CharField(
        write_only=True, 
        required=True, 
        validators=[validate_password]
    )
    password2 = serializers.CharField(write_only=True, required=True)

    class Meta:
        model = User
        fields = ('username', 'password', 'password2', 'email', 'first_name', 'last_name')
        extra_kwargs = {
            'first_name': {'required': True},
            'last_name': {'required': True}
        }

    def validate(self, attrs):
        if attrs['password'] != attrs['password2']:
            raise serializers.ValidationError(
                {"password": "Password fields didn't match."}
            )
        return attrs

    def create(self, validated_data):
        user = User.objects.create(
            username=validated_data['username'],
            email=validated_data['email'],
            first_name=validated_data['first_name'],
            last_name=validated_data['last_name']
        )
        user.set_password(validated_data['password'])
        user.save()
        
        # Create learning profile for the user
        from .models import LearningProfile
        LearningProfile.objects.create(user=user)
        
        return user

class UserSerializer(serializers.ModelSerializer):
    class Meta:
        model = User
        fields = ('id', 'username', 'email', 'first_name', 'last_name')
        
        
        
from .models import (
    LearningProfile, Concept, TeachingAtom, 
    Question, StudentProgress, LearningSession
)

class ConceptSerializer(serializers.ModelSerializer):
    class Meta:
        model = Concept
        fields = ['id', 'name', 'subject', 'description', 'difficulty', 'order']

class TeachingAtomSerializer(serializers.ModelSerializer):
    class Meta:
        model = TeachingAtom
        fields = ['id', 'name', 'explanation', 'analogy', 'examples', 'order']

class QuestionSerializer(serializers.ModelSerializer):
    class Meta:
        model = Question
        fields = ['id', 'difficulty', 'cognitive_operation', 'estimated_time', 
                 'question_text', 'options', 'correct_index']

class StudentProgressSerializer(serializers.ModelSerializer):
    atom_name = serializers.CharField(source='atom.name', read_only=True)
    concept_name = serializers.CharField(source='atom.concept.name', read_only=True)
    
    class Meta:
        model = StudentProgress
        fields = ['id', 'atom_name', 'concept_name', 'mastery_score', 'phase', 
                 'streak', 'hint_usage', 'retention_verified']

class LearningSessionSerializer(serializers.ModelSerializer):
    class Meta:
        model = LearningSession
        fields = ['id', 'concept', 'start_time', 'end_time', 'questions_answered',
                 'correct_answers', 'hints_used']


================================================
FILE: backend/accounts/tests.py
================================================
from django.test import TestCase

# Create your tests here.



================================================
FILE: backend/accounts/urls.py
================================================
from django.urls import path
from .views import (
    # Auth views
<<<<<<< HEAD
    AIDoubtAssistantView, GetConceptResourcesView, RegisterView, LoginView, DashboardView,
=======
    GetConceptResourcesView, RegisterView, LoginView, DashboardView,
>>>>>>> 27ca5f792972d0c6644ef01c0171d1c6ce25ce32
    
    # Concept management
    ConceptListView, GenerateConceptView,
    
    # Teaching-first flow views
    StartTeachingSessionView, GetTeachingContentView,
    GenerateQuestionsFromTeachingView, SubmitAtomAnswerView,
    CompleteAtomView, GetLearningProgressView,
    GenerateInitialQuizView, SubmitInitialQuizAnswerView, CompleteInitialQuizView,
    GenerateFinalChallengeView, CompleteFinalChallengeView,

    # Enhanced pacing engine views
    GetVelocityGraphView, GetFatigueStatusView, RecordBreakView,
    RetentionCheckView, RecordHintUsageView,

    # Leaderboard views
    LeaderboardView, MyXPView,

    # Concept final challenge views
    GenerateConceptFinalChallengeView, SubmitConceptFinalAnswerView,
    CompleteConceptFinalChallengeView,
)

urlpatterns = [
    # Auth endpoints
    path('api/register/', RegisterView.as_view(), name='register'),
    path('api/login/', LoginView.as_view(), name='login'),
    path('api/dashboard/', DashboardView.as_view(), name='dashboard'),
    
    # Concept management
    path('api/concepts/', ConceptListView.as_view(), name='concepts'),
    path('api/generate-concept/', GenerateConceptView.as_view(), name='generate_concept'),
    
    # Teaching-first flow endpoints
    path('api/start-teaching-session/', StartTeachingSessionView.as_view(), name='start_teaching_session'),
    path('api/initial-quiz/', GenerateInitialQuizView.as_view(), name='generate_initial_quiz'),
    path('api/submit-initial-quiz-answer/', SubmitInitialQuizAnswerView.as_view(), name='submit_initial_quiz_answer'),
    path('api/complete-initial-quiz/', CompleteInitialQuizView.as_view(), name='complete_initial_quiz'),
    path('api/teaching-content/', GetTeachingContentView.as_view(), name='teaching_content'),
    path('api/generate-questions-from-teaching/', GenerateQuestionsFromTeachingView.as_view(), name='generate_questions_from_teaching'),
    path('api/submit-atom-answer/', SubmitAtomAnswerView.as_view(), name='submit_atom_answer'),
    path('api/complete-atom/', CompleteAtomView.as_view(), name='complete_atom'),
    path('api/final-challenge/', GenerateFinalChallengeView.as_view(), name='generate_final_challenge'),
    path('api/complete-final-challenge/', CompleteFinalChallengeView.as_view(), name='complete_final_challenge'),
    
    # Progress
    path('api/progress/', GetLearningProgressView.as_view(), name='learning_progress'),
    
    path('api/concept-resources/', GetConceptResourcesView.as_view(), name='concept_resources'),

    # Enhanced pacing engine endpoints
    path('api/velocity-graph/', GetVelocityGraphView.as_view(), name='velocity_graph'),
    path('api/fatigue-status/', GetFatigueStatusView.as_view(), name='fatigue_status'),
    path('api/record-break/', RecordBreakView.as_view(), name='record_break'),
    path('api/retention-check/', RetentionCheckView.as_view(), name='retention_check'),
    path('api/record-hint/', RecordHintUsageView.as_view(), name='record_hint'),

    # Leaderboard endpoints
    path('api/leaderboard/', LeaderboardView.as_view(), name='leaderboard'),
    path('api/my-xp/', MyXPView.as_view(), name='my_xp'),

    # Concept final challenge endpoints
    path('api/concept-final-challenge/', GenerateConceptFinalChallengeView.as_view(), name='generate_concept_final_challenge'),
    path('api/submit-concept-final-answer/', SubmitConceptFinalAnswerView.as_view(), name='submit_concept_final_answer'),
    path('api/complete-concept-final-challenge/', CompleteConceptFinalChallengeView.as_view(), name='complete_concept_final_challenge'),
<<<<<<< HEAD
    path("ai-assistant/", AIDoubtAssistantView.as_view(), name="ai_assistant"),
=======
>>>>>>> 27ca5f792972d0c6644ef01c0171d1c6ce25ce32
]


================================================
FILE: backend/accounts/views.py
================================================
<<<<<<< HEAD
Error reading file with 'cp1252': 'charmap' codec can't decode byte 0x8f in position 42578: character maps to <undefined>
=======
Error reading file with 'cp1252': 'charmap' codec can't decode byte 0x8f in position 48342: character maps to <undefined>
>>>>>>> 27ca5f792972d0c6644ef01c0171d1c6ce25ce32


================================================
FILE: backend/accounts/migrations/0001_initial.py
================================================
# Generated by Django 6.0.2 on 2026-02-16 10:28

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='Concept',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=200)),
                ('subject', models.CharField(max_length=100)),
                ('description', models.TextField(blank=True)),
                ('difficulty', models.CharField(choices=[('easy', 'Easy'), ('medium', 'Medium'), ('hard', 'Hard')], default='medium', max_length=10)),
                ('order', models.IntegerField(default=0)),
                ('prerequisites', models.ManyToManyField(blank=True, to='accounts.concept')),
            ],
            options={
                'ordering': ['subject', 'order'],
                'unique_together': {('name', 'subject')},
            },
        ),
        migrations.CreateModel(
            name='LearningProfile',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('overall_theta', models.FloatField(default=0.0)),
                ('current_subject', models.CharField(blank=True, max_length=100)),
                ('current_concept', models.CharField(blank=True, max_length=100)),
                ('learning_streak', models.IntegerField(default=0)),
                ('total_time_spent', models.IntegerField(default=0)),
                ('last_active', models.DateTimeField(auto_now=True)),
                ('user', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, related_name='learning_profile', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'db_table': 'learning_profile',
            },
        ),
        migrations.CreateModel(
            name='LearningSession',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('start_time', models.DateTimeField(auto_now_add=True)),
                ('end_time', models.DateTimeField(blank=True, null=True)),
                ('questions_answered', models.IntegerField(default=0)),
                ('correct_answers', models.IntegerField(default=0)),
                ('hints_used', models.IntegerField(default=0)),
                ('session_data', models.JSONField(default=dict)),
                ('concept', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='accounts.concept')),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='learning_sessions', to=settings.AUTH_USER_MODEL)),
            ],
        ),
        migrations.CreateModel(
            name='TeachingAtom',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=200)),
                ('explanation', models.TextField(blank=True)),
                ('analogy', models.TextField(blank=True)),
                ('examples', models.JSONField(default=list)),
                ('order', models.IntegerField(default=0)),
                ('concept', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='atoms', to='accounts.concept')),
            ],
            options={
                'ordering': ['concept', 'order'],
            },
        ),
        migrations.CreateModel(
            name='Question',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('difficulty', models.CharField(choices=[('easy', 'Easy'), ('medium', 'Medium'), ('hard', 'Hard')], max_length=10)),
                ('cognitive_operation', models.CharField(choices=[('recall', 'Recall'), ('apply', 'Apply'), ('analyze', 'Analyze')], max_length=10)),
                ('estimated_time', models.IntegerField(default=60)),
                ('question_text', models.TextField()),
                ('options', models.JSONField(default=list)),
                ('correct_index', models.IntegerField()),
                ('atom', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='questions', to='accounts.teachingatom')),
            ],
        ),
        migrations.CreateModel(
            name='StudentProgress',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('mastery_score', models.FloatField(default=0.3)),
                ('phase', models.CharField(choices=[('diagnostic', 'Diagnostic'), ('teaching', 'Teaching'), ('practice', 'Practice'), ('reinforcement', 'Reinforcement'), ('mastery_check', 'Mastery Check'), ('complete', 'Complete')], default='diagnostic', max_length=20)),
                ('streak', models.IntegerField(default=0)),
                ('hint_usage', models.IntegerField(default=0)),
                ('error_history', models.JSONField(default=list)),
                ('retention_verified', models.BooleanField(default=False)),
                ('last_practiced', models.DateTimeField(auto_now=True)),
                ('times_practiced', models.IntegerField(default=0)),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='progress', to=settings.AUTH_USER_MODEL)),
                ('atom', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='accounts.teachingatom')),
            ],
            options={
                'unique_together': {('user', 'atom')},
            },
        ),
    ]



================================================
FILE: backend/accounts/migrations/0002_concept_created_by.py
================================================
# Generated by GitHub Copilot on 2026-02-17

from django.conf import settings
from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):

    dependencies = [
        ('accounts', '0001_initial'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.AddField(
            model_name='concept',
            name='created_by',
            field=models.ForeignKey(
                blank=True,
                null=True,
                on_delete=django.db.models.deletion.SET_NULL,
                related_name='created_concepts',
                to=settings.AUTH_USER_MODEL,
            ),
        ),
        migrations.AlterUniqueTogether(
            name='concept',
            unique_together={('name', 'subject', 'created_by')},
        ),
    ]



================================================
FILE: backend/accounts/migrations/0003_learningsession_knowledge_level_and_more.py
================================================
# Generated by Django 6.0.2 on 2026-02-17 12:58

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('accounts', '0002_concept_created_by'),
    ]

    operations = [
        migrations.AddField(
            model_name='learningsession',
            name='knowledge_level',
            field=models.CharField(choices=[('zero', 'Zero Knowledge'), ('beginner', 'Beginner'), ('intermediate', 'Intermediate'), ('advanced', 'Advanced')], default='zero', max_length=20),
        ),
        migrations.AddField(
            model_name='learningsession',
            name='user_feedback',
            field=models.JSONField(default=dict),
        ),
    ]



================================================
FILE: backend/accounts/migrations/0004_add_error_history_default.py
================================================
# In accounts/migrations/0004_add_error_history_default.py
from django.db import migrations, models

class Migration(migrations.Migration):
    dependencies = [
        ('accounts', '0003_learningsession_knowledge_level_and_more'),
    ]

    operations = [
        migrations.AlterField(
            model_name='studentprogress',
            name='error_history',
            field=models.JSONField(default=list),
        ),
    ]


================================================
FILE: backend/accounts/migrations/0005_learningsession_break_count_and_more.py
================================================
# Generated by Django 6.0.2 on 2026-02-19 14:37

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('accounts', '0004_add_error_history_default'),
    ]

    operations = [
        migrations.AddField(
            model_name='learningsession',
            name='break_count',
            field=models.IntegerField(default=0),
        ),
        migrations.AddField(
            model_name='learningsession',
            name='consecutive_skips',
            field=models.IntegerField(default=0),
        ),
        migrations.AddField(
            model_name='learningsession',
            name='engagement_score',
            field=models.FloatField(default=0.7),
        ),
        migrations.AddField(
            model_name='learningsession',
            name='fatigue_level',
            field=models.CharField(default='fresh', max_length=20),
        ),
        migrations.AddField(
            model_name='learningsession',
            name='last_break_at',
            field=models.DateTimeField(blank=True, null=True),
        ),
        migrations.AddField(
            model_name='learningsession',
            name='velocity_data',
            field=models.JSONField(blank=True, default=list),
        ),
        migrations.AddField(
            model_name='studentprogress',
            name='next_review_at',
            field=models.DateTimeField(blank=True, null=True),
        ),
        migrations.AddField(
            model_name='studentprogress',
            name='retention_checks_failed',
            field=models.IntegerField(default=0),
        ),
        migrations.AddField(
            model_name='studentprogress',
            name='retention_checks_passed',
            field=models.IntegerField(default=0),
        ),
        migrations.AddField(
            model_name='studentprogress',
            name='retention_score',
            field=models.FloatField(default=1.0),
        ),
        migrations.AddField(
            model_name='studentprogress',
            name='time_per_question',
            field=models.JSONField(blank=True, default=list),
        ),
        migrations.AddField(
            model_name='studentprogress',
            name='velocity_snapshots',
            field=models.JSONField(blank=True, default=list),
        ),
    ]



================================================
FILE: backend/accounts/migrations/0006_userxp.py
================================================
# Generated by Django 6.0.2 on 2026-02-19 16:04

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('accounts', '0005_learningsession_break_count_and_more'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='UserXP',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('total_xp', models.IntegerField(default=0)),
                ('questions_xp', models.IntegerField(default=0)),
                ('atoms_xp', models.IntegerField(default=0)),
                ('concepts_xp', models.IntegerField(default=0)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('user', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, related_name='xp_profile', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'db_table': 'user_xp',
                'ordering': ['-total_xp'],
            },
        ),
    ]



================================================
FILE: backend/accounts/migrations/__init__.py
================================================
[Empty file]


================================================
FILE: backend/core/__init__.py
================================================
import os
import sys

# Add the backend directory to path
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
if BASE_DIR not in sys.path:
    sys.path.append(BASE_DIR)


================================================
FILE: backend/core/asgi.py
================================================
"""
ASGI config for core project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/6.0/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'core.settings')

application = get_asgi_application()



================================================
FILE: backend/core/settings.py
================================================
import os
from datetime import timedelta
from pathlib import Path

from dotenv import load_dotenv

load_dotenv()

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/6.0/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-gq5gu@@4-^r(35**5w-v6l-qkkr@aut890$z=lx^e_%1$q+nb%'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = ["*"]


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    
    # Third party apps
    'rest_framework',
    'rest_framework_simplejwt',
    'corsheaders',
    
    # Local apps
    'accounts',
    'learning_engine',

]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'corsheaders.middleware.CorsMiddleware',  # Add this
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'core.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'core.wsgi.application'


# Database
# https://docs.djangoproject.com/en/6.0/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}


# Password validation
# https://docs.djangoproject.com/en/6.0/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/6.0/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/6.0/howto/static-files/

STATIC_URL = 'static/'


DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# CORS settings
CORS_ALLOWED_ORIGINS = [
    "http://localhost:3000",
    "http://127.0.0.1:3000",
    "http://localhost:5173",
    "http://127.0.0.1:5173",
    "http://localhost:5174",
    "http://127.0.0.1:5174",
]

CORS_ALLOW_CREDENTIALS = True

# REST Framework settings
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ),
    'DEFAULT_PERMISSION_CLASSES': (
        'rest_framework.permissions.IsAuthenticated',
    ),
}

# JWT settings
SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(minutes=60),
    'REFRESH_TOKEN_LIFETIME': timedelta(days=1),
    'ROTATE_REFRESH_TOKENS': False,
    'BLACKLIST_AFTER_ROTATION': True,
    'UPDATE_LAST_LOGIN': False,

    'ALGORITHM': 'HS256',
    'SIGNING_KEY': SECRET_KEY,
    'VERIFYING_KEY': None,
    'AUDIENCE': None,
    'ISSUER': None,

    'AUTH_HEADER_TYPES': ('Bearer',),
    'AUTH_HEADER_NAME': 'HTTP_AUTHORIZATION',
    'USER_ID_FIELD': 'id',
    'USER_ID_CLAIM': 'user_id',

    'AUTH_TOKEN_CLASSES': ('rest_framework_simplejwt.tokens.AccessToken',),
    'TOKEN_TYPE_CLAIM': 'token_type',

    'JTI_CLAIM': 'jti',

    'SLIDING_TOKEN_REFRESH_EXP_CLAIM': 'refresh_exp',
    'SLIDING_TOKEN_LIFETIME': timedelta(minutes=5),
    'SLIDING_TOKEN_REFRESH_LIFETIME': timedelta(days=1),
}


LEARNING_ENGINE = {
    'MAX_PER_DIFFICULTY': 4,
    'MASTERY_THRESHOLD': 0.7,
    'BKT_SLIP': 0.1,
    'BKT_GUESS': 0.2,
    'BKT_LEARN': 0.15,
}

# API Keys (set these in environment variables)
<<<<<<< HEAD
GOOGLE_API_KEY = os.environ.get('GOOGLE_API_KEY',  '')
GOOGLE_API_KEY = os.getenv("GOOGLE_API_KEY")
=======
GOOGLE_API_KEY = os.getenv('GOOGLE_API_KEY', '')
>>>>>>> 27ca5f792972d0c6644ef01c0171d1c6ce25ce32
GROQ_API_KEY = os.environ.get('GROQ_API_KEY', '')


LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'format': '{levelname} {asctime} {module} {process:d} {thread:d} {message}',
            'style': '{',
        },
        'simple': {
            'format': '{levelname} {asctime} {message}',
            'style': '{',
        },
    },
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
            'formatter': 'simple',
        },
        'file': {
            'class': 'logging.FileHandler',
            'filename': os.path.join(BASE_DIR, 'debug.log'),
            'formatter': 'verbose',
        },
    },
    'root': {
        'handlers': ['console', 'file'],
        'level': 'INFO',
    },
    'loggers': {
        'django': {
            'handlers': ['console', 'file'],
            'level': 'INFO',
            'propagate': False,
        },
        'accounts': {
            'handlers': ['console', 'file'],
            'level': 'DEBUG',
            'propagate': False,
        },
        'learning_engine': {
            'handlers': ['console', 'file'],
            'level': 'DEBUG',
            'propagate': False,
        },
    },
}


================================================
FILE: backend/core/urls.py
================================================
from django.contrib import admin
from django.urls import path, include
from rest_framework_simplejwt.views import TokenRefreshView

urlpatterns = [
    path('admin/', admin.site.urls),
    path('auth/', include('accounts.urls')),  # This should be correct
    path('api/token/refresh/', TokenRefreshView.as_view(), name='token_refresh'),
]


================================================
FILE: backend/core/wsgi.py
================================================
"""
WSGI config for core project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/6.0/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'core.settings')

application = get_wsgi_application()



================================================
FILE: backend/learning_engine/__init__.py
================================================
from .adaptive_flow import AdaptiveLearningEngine
from .knowledge_tracing import bkt_update, irt_probability, update_theta, classify_behavior, update_mastery_from_behavior, classify_error_type
from .question_generator import QuestionGenerator
from .models import TeachingAtomState, LearningPhase, ErrorType, PacingDecision

__all__ = [
    'AdaptiveLearningEngine',
    'bkt_update',
    'irt_probability',
    'update_theta',
    'classify_behavior',
    'update_mastery_from_behavior',
    'classify_error_type',
    'QuestionGenerator',
    'TeachingAtomState',
    'LearningPhase',
    'ErrorType',
    'PacingDecision',
]


================================================
FILE: backend/learning_engine/adaptive_flow.py
================================================
<<<<<<< HEAD
# backend/learning_engine/adaptive_flow.py - Enhanced with robust 10-feature pacing engine
=======
Error reading file with 'cp1252': 'charmap' codec can't decode byte 0x9d in position 30221: character maps to <undefined>
>>>>>>> 27ca5f792972d0c6644ef01c0171d1c6ce25ce32


================================================
FILE: backend/learning_engine/external_resources.py
================================================
# backend/learning_engine/external_resources.py

import os
import requests
from youtube_search import YoutubeSearch
from serpapi import Client  # Changed import
from django.conf import settings
<<<<<<< HEAD
from groq import Groq
from .models import TeachingAtomState, LearningPhase
from .knowledge_tracing import calculate_updated_mastery, classify_error_type
from .pacing_engine import (
    PacingEngine, PacingContext, PacingDecision, NextAction,
    PacingResult, FatigueLevel,
)
=======
import logging
import json
>>>>>>> 27ca5f792972d0c6644ef01c0171d1c6ce25ce32

logger = logging.getLogger(__name__)

class ExternalResourceFetcher:
    """Fetch external learning resources (images, videos) for concepts"""
    
    def __init__(self):
<<<<<<< HEAD
        self.groq_client = None
        groq_key = getattr(settings, 'GROQ_API_KEY', '')
        if groq_key:
            self.groq_client = Groq(api_key=groq_key)
        
        self.pacing_engine = PacingEngine()

    def determine_pacing(self, diagnostic_results: Dict, knowledge_level: str) -> str:
        """
        Compatibility helper for legacy callers.
        Translates aggregate diagnostics into a PacingContext and returns a pacing decision string.
        """
        accuracy = float(diagnostic_results.get('accuracy', 0))
        mastery = float(diagnostic_results.get('mastery', 0))
        streak = int(diagnostic_results.get('streak', 0))
        error_types = diagnostic_results.get('error_types', []) or []
        theta = float(diagnostic_results.get('theta', 0.0))
        questions_answered = int(diagnostic_results.get('questions_answered', 0))

        context = PacingContext(
            accuracy=accuracy,
            mastery_score=mastery,
            streak=streak,
            error_types=error_types,
            theta=theta,
            questions_answered=questions_answered,
            knowledge_level=knowledge_level,
            phase=diagnostic_results.get('phase', 'practice'),
            # Enriched signals from diagnostic_results
            avg_response_time=float(diagnostic_results.get('avg_response_time', 0)),
            expected_response_time=float(diagnostic_results.get('expected_response_time', 60)),
            time_per_question_history=diagnostic_results.get('time_per_question_history', []),
            hint_usage_count=int(diagnostic_results.get('hint_usage_count', 0)),
            session_duration_minutes=float(diagnostic_results.get('session_duration_minutes', 0)),
            total_questions_session=int(diagnostic_results.get('total_questions_session', 0)),
            recent_accuracy_trend=diagnostic_results.get('recent_accuracy_trend', []),
            recent_response_times=diagnostic_results.get('recent_response_times', []),
            last_practiced_minutes_ago=float(diagnostic_results.get('last_practiced_minutes_ago', 0)),
            retention_score=float(diagnostic_results.get('retention_score', 1.0)),
            retention_checks_passed=int(diagnostic_results.get('retention_checks_passed', 0)),
            engagement_score=float(diagnostic_results.get('engagement_score', 0.7)),
            diagnostic_accuracy=diagnostic_results.get('diagnostic_accuracy'),
        )

        result: PacingResult = self.pacing_engine.decide_pacing(context)
        return result.decision.value if hasattr(result.decision, 'value') else result.decision

    def determine_pacing_full(self, diagnostic_results: Dict, knowledge_level: str, session=None) -> Dict[str, Any]:
        """
        Full pacing decision with all 10-feature signals.
        Returns a rich dict with decision, fatigue, retention, hints, velocity, etc.
        Optionally accepts a session object to enrich context with session-level data.
        """
        accuracy = float(diagnostic_results.get('accuracy', 0))
        mastery = float(diagnostic_results.get('mastery', 0))
        streak = int(diagnostic_results.get('streak', 0))
        error_types = diagnostic_results.get('error_types', []) or []
        theta = float(diagnostic_results.get('theta', 0.0))
        questions_answered = int(diagnostic_results.get('questions_answered', 0))

        context = PacingContext(
            accuracy=accuracy,
            mastery_score=mastery,
            streak=streak,
            error_types=error_types,
            theta=theta,
            questions_answered=questions_answered,
            knowledge_level=knowledge_level,
            phase=diagnostic_results.get('phase', 'practice'),
            avg_response_time=float(diagnostic_results.get('avg_response_time', 0)),
            expected_response_time=float(diagnostic_results.get('expected_response_time', 60)),
            time_per_question_history=diagnostic_results.get('time_per_question_history', []),
            hint_usage_count=int(diagnostic_results.get('hint_usage_count', 0)),
            session_duration_minutes=float(diagnostic_results.get('session_duration_minutes', 0)),
            total_questions_session=int(diagnostic_results.get('total_questions_session', 0)),
            recent_accuracy_trend=diagnostic_results.get('recent_accuracy_trend', []),
            recent_response_times=diagnostic_results.get('recent_response_times', []),
            last_practiced_minutes_ago=float(diagnostic_results.get('last_practiced_minutes_ago', 0)),
            retention_score=float(diagnostic_results.get('retention_score', 1.0)),
            retention_checks_passed=int(diagnostic_results.get('retention_checks_passed', 0)),
            retention_checks_failed=int(diagnostic_results.get('retention_checks_failed', 0)),
            engagement_score=float(diagnostic_results.get('engagement_score', 0.7)),
            consecutive_skips=int(diagnostic_results.get('consecutive_skips', 0)),
            drop_off_risk=float(diagnostic_results.get('drop_off_risk', 0)),
            diagnostic_accuracy=diagnostic_results.get('diagnostic_accuracy'),
        )

        # Enrich context from session object if available
        if session is not None:
            from django.utils import timezone as tz
            elapsed = (tz.now() - session.start_time).total_seconds() / 60.0
            context.session_duration_minutes = max(context.session_duration_minutes, elapsed)
            context.consecutive_skips = getattr(session, 'consecutive_skips', 0)
            perf = (session.session_data or {}).get('performance_history', [])
            if perf and not context.time_per_question_history:
                context.time_per_question_history = [p.get('time_taken', 30) for p in perf]

        result: PacingResult = self.pacing_engine.decide_pacing(context)

        return {
            'pacing': result.decision.value,
            'decision': result.decision.value,
            'next_action': result.next_action.value,
            'fatigue': result.fatigue.value,
            'recommended_difficulty': result.recommended_difficulty,
            'mastery_verdict': result.mastery_verdict,
            'retention_action': result.retention_action,
            'hint_warning': result.hint_warning,
            'velocity_snapshot': result.velocity_snapshot,
            'engagement_adjustment': result.engagement_adjustment,
            'reasoning': result.reasoning,
        }
=======
        self.serpapi_key = getattr(settings, 'SERPAPI_KEY', os.getenv('SERPAPI_KEY', ''))
        self.download_folder = os.path.join(settings.BASE_DIR, 'media', 'concept_images')
        os.makedirs(self.download_folder, exist_ok=True)
>>>>>>> 27ca5f792972d0c6644ef01c0171d1c6ce25ce32
    
    def get_youtube_videos(self, topic, max_results=3):
        """
        Search YouTube for videos related to the given topic
        """
<<<<<<< HEAD
        # Determine correctness
        correct = (selected_answer == question.get('correct_index', -1))
        
        # Classify error type if wrong
        error_type = None
        if not correct:
            error_type = classify_error_type(
                question, selected_answer, time_taken, atom_state.name
            )
        
        # REAL-TIME MASTERY UPDATE (after EVERY answer)
        new_mastery, new_theta, metrics = calculate_updated_mastery(
            current_mastery=atom_state.mastery_score,
            current_theta=theta,
            question=question,
            correct=correct,
            time_taken=time_taken,
            error_type=error_type
        )
        
        # Update atom state
        atom_state.mastery_score = new_mastery
        
        if correct:
            atom_state.streak = atom_state.streak + 1 if atom_state.streak > 0 else 1
        else:
            atom_state.streak = atom_state.streak - 1 if atom_state.streak < 0 else -1
        
        if error_type:
            atom_state.error_history.append(error_type)
        
        # Calculate recent metrics for pacing
        recent_questions = questions_history[-5:] if questions_history else []
        recent_correct = sum(1 for q in recent_questions if q.get('correct', False))
        recent_accuracy = recent_correct / len(recent_questions) if recent_questions else (1.0 if correct else 0.0)
        
        # Get recent error types
        recent_errors = [e for e in atom_state.error_history[-5:] if e]
        
        # Collect time-per-question history from questions_history
        time_history = [q.get('time_taken', 30) for q in questions_history if 'time_taken' in q]
        time_history.append(time_taken)

        # Compute accuracy trend (rolling window of recent correctness)
        accuracy_trend = []
        for q in questions_history[-10:]:
            accuracy_trend.append(1.0 if q.get('correct', False) else 0.0)
        accuracy_trend.append(1.0 if correct else 0.0)

        # Hint usage count from atom state
        hint_count = atom_state.hint_usage

        # Expected response time from question
        expected_time = question.get('estimated_time', 60)

        # Create enriched pacing context with all 10 features
        pacing_context = PacingContext(
            accuracy=recent_accuracy,
            mastery_score=new_mastery,
            streak=atom_state.streak,
            error_types=recent_errors,
            theta=new_theta,
            questions_answered=len(questions_history) + 1,
            knowledge_level=knowledge_level,
            phase=atom_state.phase.value if hasattr(atom_state.phase, 'value') else atom_state.phase,
            # Feature 2: learning speed
            avg_response_time=time_taken,
            expected_response_time=float(expected_time),
            time_per_question_history=time_history,
            # Feature 7: hint depth
            hint_usage_count=hint_count,
            # Feature 8: fatigue (session-level, passed from caller if available)
            recent_accuracy_trend=accuracy_trend,
            recent_response_times=time_history[-10:],
            # Feature 6: retention
            retention_score=getattr(atom_state, 'retention_score', 1.0),
            retention_checks_passed=getattr(atom_state, 'retention_checks_passed', 0),
            last_practiced_minutes_ago=getattr(atom_state, 'last_practiced_minutes_ago', 0),
        )

        # Get full pacing result (10-feature)
        pacing_result: PacingResult = self.pacing_engine.decide_pacing(pacing_context)
        pacing_decision = pacing_result.decision
        next_action = pacing_result.next_action
        reasoning = pacing_result.reasoning
        
        # Determine next difficulty based on ability and pacing
        next_difficulty = self.pacing_engine.get_next_difficulty(
            new_theta, pacing_decision, knowledge_level
        )
        
        # Check if atom is complete
        atom_complete = self._check_atom_complete(atom_state, pacing_context)
        
        # Store velocity snapshot on atom state
        if hasattr(atom_state, 'velocity_snapshots'):
            atom_state.velocity_snapshots.append(pacing_result.velocity_snapshot)

        # Store time_taken on atom state for per-atom speed tracking
        if hasattr(atom_state, 'time_per_question'):
            atom_state.time_per_question.append(time_taken)

        # Fatigue recommendation
        fatigue_rec = self.pacing_engine.get_fatigue_recommendation(pacing_result.fatigue)

        # Prepare result with all 10 feature outputs
        result = {
            'correct': correct,
            'error_type': error_type,
            'updated_mastery': new_mastery,
            'updated_theta': new_theta,
            'metrics': metrics,
            'pacing_decision': pacing_decision.value if hasattr(pacing_decision, 'value') else pacing_decision,
            'next_action': next_action.value if hasattr(next_action, 'value') else next_action,
            'next_difficulty': next_difficulty,
            'reasoning': reasoning,
            'atom_complete': atom_complete,
            'streak': atom_state.streak,
            # â”€â”€ Feature 5: mastery verdict â”€â”€
            'mastery_verdict': pacing_result.mastery_verdict,
            # â”€â”€ Feature 6: retention â”€â”€
            'retention_action': pacing_result.retention_action,
            # â”€â”€ Feature 7: hint warning â”€â”€
            'hint_warning': pacing_result.hint_warning,
            # â”€â”€ Feature 8: fatigue â”€â”€
            'fatigue': {
                'level': pacing_result.fatigue.value,
                'message': fatigue_rec.get('message', ''),
                'break_suggested': fatigue_rec.get('break_suggested', False),
                'lighter_mode': fatigue_rec.get('lighter_mode', False),
            },
            # â”€â”€ Feature 9: engagement â”€â”€
            'engagement_adjustment': pacing_result.engagement_adjustment,
            # â”€â”€ Feature 10: velocity snapshot â”€â”€
            'velocity_snapshot': pacing_result.velocity_snapshot,
        }

        # Add specific recommendations
        if next_action == NextAction.RETEACH:
            result['recommendation'] = 'review_teaching'
            result['message'] = "Let's review the teaching material again."
        elif next_action == NextAction.ADVANCE_NEXT_ATOM:
            result['recommendation'] = 'advance'
            result['message'] = "Great job! Ready for the next concept."
        elif next_action == NextAction.TAKE_BREAK:
            result['recommendation'] = 'take_break'
            result['message'] = fatigue_rec.get('message', "Time for a short break!")
        elif next_action == NextAction.LIGHTER_TASK:
            result['recommendation'] = 'lighter_task'
            result['message'] = "Switching to lighter tasks to keep you going."
        elif next_action == NextAction.INSERT_REVIEW:
            result['recommendation'] = 'review_old_content'
            result['message'] = "Let's quickly review some earlier content to keep it fresh."
        elif pacing_decision == PacingDecision.SHARP_SLOWDOWN:
            result['recommendation'] = 'easier_questions'
            result['message'] = "Let's try some easier questions to build confidence."
        elif pacing_decision == PacingDecision.SPEED_UP:
            result['recommendation'] = 'challenge'
            result['message'] = "You're doing great! Ready for a challenge?"

        return result
    
    def _check_atom_complete(self, atom_state: TeachingAtomState, 
                            context: PacingContext) -> bool:
        """
        Check if atom should be marked complete using the engine's should_exit_atom.
        """
        should_exit, reason = self.pacing_engine.should_exit_atom(context)
        return should_exit
    
    def select_next_questions(self, 
                             atom_state: TeachingAtomState,
                             theta: float,
                             pacing_decision: PacingDecision,
                             knowledge_level: str,
                             available_questions: Dict[str, List[Dict]]) -> List[Dict]:
        """
        Select next questions based on ability, not fixed counts
        """
        selected = []
        
        # Determine target difficulty based on theta
        if theta < -0.3:
            target_difficulty = 'easy'
        elif theta < 0.6:
            target_difficulty = 'medium'
        else:
            target_difficulty = 'hard'
        
        # Adjust based on pacing
        if pacing_decision == PacingDecision.SHARP_SLOWDOWN:
            # Focus on easy questions
            target_difficulty = 'easy'
            count = 3
        elif pacing_decision == PacingDecision.SLOW_DOWN:
            # Mix of easy and medium
            easy_count = 2
            medium_count = 1
        elif pacing_decision == PacingDecision.STAY:
            # Mix based on ability
            if target_difficulty == 'easy':
                easy_count, medium_count, hard_count = 2, 1, 0
            elif target_difficulty == 'medium':
                easy_count, medium_count, hard_count = 1, 2, 0
            else:  # hard
                easy_count, medium_count, hard_count = 0, 2, 1
        else:  # SPEED_UP
            # Challenge with harder questions
            if target_difficulty == 'easy':
                easy_count, medium_count, hard_count = 1, 2, 0
            elif target_difficulty == 'medium':
                easy_count, medium_count, hard_count = 0, 2, 1
            else:  # hard
                easy_count, medium_count, hard_count = 0, 1, 2
        
        # Select questions (up to available)
        for difficulty, count in [('easy', easy_count), ('medium', medium_count), ('hard', hard_count)]:
            if count > 0 and difficulty in available_questions:
                pool = available_questions[difficulty]
                # Select without replacement
                to_select = min(count, len(pool))
                if to_select > 0:
                    selected.extend(random.sample(pool, to_select))
        
        return selected
    
    def generate_teaching_content(self, atom_name: str, subject: str, 
                                  concept: str, knowledge_level: str,
                                  error_history: List[str] = None) -> Dict[str, str]:
        """
        Generate personalized teaching content based on knowledge level and error history
        """
        # If reteaching due to errors, focus on problem areas
        if error_history and len(error_history) > 0:
            recent_errors = error_history[-3:]
            error_focus = self._get_error_focus(recent_errors)
        else:
            error_focus = None
        
        if not self.groq_client:
            return self._get_fallback_content(atom_name, concept, knowledge_level, error_focus)
        
        level_descriptions = {
            'zero': "Complete beginner - needs fundamental concepts explained from scratch",
            'beginner': "Has basic understanding but needs clear explanations and examples",
            'intermediate': "Knows the basics - needs deeper insights and applications",
            'advanced': "Strong understanding - needs advanced concepts and edge cases"
        }
        
        error_context = ""
        if error_focus:
            error_context = f"""
            The student has struggled with these types of errors recently:
            {', '.join(error_focus)}
=======
        try:
            # Enhance the search query for better educational content
            search_query = f"{topic} tutorial explanation"
>>>>>>> 27ca5f792972d0c6644ef01c0171d1c6ce25ce32
            
            # Try-except for youtube-search which might have issues
            try:
                results = YoutubeSearch(search_query, max_results=max_results).to_dict()
            except Exception as e:
                logger.error(f"YouTube search failed: {e}")
                # Fallback: return empty list
                return []
            
            videos = []
            for result in results:
                video = {
                    'title': result.get('title', ''),
                    'url': f"https://youtube.com{result.get('url_suffix', '')}",
                    'channel': result.get('channel', ''),
                    'duration': result.get('duration', ''),
                    'thumbnail': result.get('thumbnails', [''])[0] if result.get('thumbnails') else '',
                    'views': result.get('views', '')
                }
                videos.append(video)
            return videos
        except Exception as e:
            logger.error(f"Error in get_youtube_videos: {e}")
            return []
    
    def get_images(self, query, max_images=3):
        """
        Fetch relevant images/diagrams for a concept using SerpAPI
        """
        if not self.serpapi_key:
            logger.warning("SERPAPI_KEY not set, skipping image fetch")
            return self.get_fallback_images(query, max_images)
        
        try:
            # Priority sites for educational content
            priority_sites = [
                "geeksforgeeks.org",
                "medium.com",
                "tutorialspoint.com",
                "javatpoint.com",
                "programiz.com",
                "w3schools.com"
            ]
            
            image_urls = []
            
            # First try to get images from priority sites
            for site in priority_sites[:max_images]:
                if len(image_urls) >= max_images:
                    break
                
                try:
                    # Using the Client approach for serpapi
                    client = Client(api_key=self.serpapi_key)
                    
                    full_query = f"{query} diagram OR illustration site:{site}"
                    
                    # Create params for image search
                    params = {
                        "engine": "google_images",
                        "q": full_query,
                        "num": 1,
                        "ijn": 0,
                        "api_key": self.serpapi_key
                    }
                    
                    # Make the request
                    result = client.search(params)
                    
                    if hasattr(result, 'get') and result.get('images_results'):
                        images = result['images_results']
                        if images and len(images) > 0:
                            image_urls.append({
                                'url': images[0].get('original', ''),
                                'title': images[0].get('title', ''),
                                'source': site,
                                'thumbnail': images[0].get('thumbnail', '')
                            })
                            logger.info(f"Found image from {site}")
                except Exception as e:
                    logger.error(f"Error fetching image from {site}: {e}")
                    continue
            
            # If we still need more images, do a general search
            if len(image_urls) < max_images:
                try:
                    client = Client(api_key=self.serpapi_key)
                    params = {
                        "engine": "google_images",
                        "q": f"{query} educational diagram",
                        "num": max_images - len(image_urls),
                        "ijn": 0,
                        "api_key": self.serpapi_key
                    }
                    
                    result = client.search(params)
                    
                    if hasattr(result, 'get') and result.get('images_results'):
                        images = result['images_results']
                        for img in images:
                            if len(image_urls) >= max_images:
                                break
                            image_urls.append({
                                'url': img.get('original', ''),
                                'title': img.get('title', ''),
                                'source': img.get('source', ''),
                                'thumbnail': img.get('thumbnail', '')
                            })
                except Exception as e:
                    logger.error(f"Error in general image search: {e}")
            
            return image_urls
            
        except Exception as e:
            logger.error(f"Error in get_images: {e}")
            return self.get_fallback_images(query, max_images)
    
    def get_fallback_images(self, query, max_images=3):
        """Provide fallback placeholder images when API fails"""
        fallback_images = []
        for i in range(min(max_images, 3)):
            fallback_images.append({
                'url': f'https://via.placeholder.com/600x400?text={query.replace(" ", "+")}+Diagram+{i+1}',
                'title': f'{query} - Diagram {i+1}',
                'source': 'placeholder',
                'thumbnail': f'https://via.placeholder.com/300x200?text={query.replace(" ", "+")}+{i+1}'
            })
        return fallback_images
    
    def get_resources_for_concept(self, subject, concept, atom_name=None):
        """
        Get both videos and images for a concept
        """
        # Create search queries
        if atom_name:
            main_query = f"{subject} {concept} {atom_name}"
            specific_query = f"{atom_name} in {concept}"
        else:
            main_query = f"{subject} {concept}"
            specific_query = concept
        
        # Fetch resources with error handling
        videos = []
        images = []
        
        try:
            videos = self.get_youtube_videos(main_query, max_results=2)
        except Exception as e:
            logger.error(f"Error fetching videos: {e}")
        
        try:
            images = self.get_images(main_query, max_images=3)
        except Exception as e:
            logger.error(f"Error fetching images: {e}")
        
        # If no results, try more specific query
        if not videos and not images:
            try:
                videos = self.get_youtube_videos(specific_query, max_results=2)
                images = self.get_images(specific_query, max_images=3)
            except Exception as e:
                logger.error(f"Error in fallback search: {e}")
        
        return {
            'videos': videos,
            'images': images
        }


================================================
FILE: backend/learning_engine/ai_assistant.py
================================================
# learning_engine/ai_assistant.py

import google.generativeai as genai
from django.conf import settings


# Configure Gemini
genai.configure(api_key=settings.GOOGLE_API_KEY)

model = genai.GenerativeModel("gemini-3-flash-preview")


def generate_ai_response(question, topic, level, accuracy=None):
    """
    Core Learning Engine Logic
    """

    # Adaptive Level Based on Accuracy (Optional)
    if accuracy is not None:
        if accuracy < 50:
            level = "Beginner"
        elif accuracy < 80:
            level = "Intermediate"
        else:
            level = "Advanced"

    difficulty_instruction = {
        "Beginner": "Explain in very simple language using real-life analogy.",
        "Intermediate": "Explain clearly with one technical example.",
        "Advanced": "Explain deeply with edge cases and complexity."
    }

    prompt = f"""
    You are an adaptive AI tutor.

    Student Level: {level}
    Topic: {topic}

    {difficulty_instruction.get(level)}

    Question: {question}

    Only answer if the question is related to academic syllabus.
    Keep answer under 200 words.
    """

    response = model.generate_content(prompt)

    return response.text


================================================
FILE: backend/learning_engine/external_resources.py
================================================
# backend/learning_engine/external_resources.py

import os
import requests
from youtube_search import YoutubeSearch
from serpapi import Client  # Changed import
from django.conf import settings
import logging
import json

logger = logging.getLogger(__name__)

class ExternalResourceFetcher:
    """Fetch external learning resources (images, videos) for concepts"""
    
    def __init__(self):
        self.serpapi_key = getattr(settings, 'SERPAPI_KEY', os.getenv('SERPAPI_KEY', ''))
        self.download_folder = os.path.join(settings.BASE_DIR, 'media', 'concept_images')
        os.makedirs(self.download_folder, exist_ok=True)
    
    def get_youtube_videos(self, topic, max_results=3):
        """
        Search YouTube for videos related to the given topic
        """
        try:
            # Enhance the search query for better educational content
            search_query = f"{topic} tutorial explanation"
            
            # Try-except for youtube-search which might have issues
            try:
                results = YoutubeSearch(search_query, max_results=max_results).to_dict()
            except Exception as e:
                logger.error(f"YouTube search failed: {e}")
                # Fallback: return empty list
                return []
            
            videos = []
            for result in results:
                video = {
                    'title': result.get('title', ''),
                    'url': f"https://youtube.com{result.get('url_suffix', '')}",
                    'channel': result.get('channel', ''),
                    'duration': result.get('duration', ''),
                    'thumbnail': result.get('thumbnails', [''])[0] if result.get('thumbnails') else '',
                    'views': result.get('views', '')
                }
                videos.append(video)
            return videos
        except Exception as e:
            logger.error(f"Error in get_youtube_videos: {e}")
            return []
    
    def get_images(self, query, max_images=3):
        """
        Fetch relevant images/diagrams for a concept using SerpAPI
        """
        if not self.serpapi_key:
            logger.warning("SERPAPI_KEY not set, skipping image fetch")
            return self.get_fallback_images(query, max_images)
        
        try:
            # Priority sites for educational content
            priority_sites = [
                "geeksforgeeks.org",
                "medium.com",
                "tutorialspoint.com",
                "javatpoint.com",
                "programiz.com",
                "w3schools.com"
            ]
            
            image_urls = []
            
            # First try to get images from priority sites
            for site in priority_sites[:max_images]:
                if len(image_urls) >= max_images:
                    break
                
                try:
                    # Using the Client approach for serpapi
                    client = Client(api_key=self.serpapi_key)
                    
                    full_query = f"{query} diagram OR illustration site:{site}"
                    
                    # Create params for image search
                    params = {
                        "engine": "google_images",
                        "q": full_query,
                        "num": 1,
                        "ijn": 0,
                        "api_key": self.serpapi_key
                    }
                    
                    # Make the request
                    result = client.search(params)
                    
                    if hasattr(result, 'get') and result.get('images_results'):
                        images = result['images_results']
                        if images and len(images) > 0:
                            image_urls.append({
                                'url': images[0].get('original', ''),
                                'title': images[0].get('title', ''),
                                'source': site,
                                'thumbnail': images[0].get('thumbnail', '')
                            })
                            logger.info(f"Found image from {site}")
                except Exception as e:
                    logger.error(f"Error fetching image from {site}: {e}")
                    continue
            
            # If we still need more images, do a general search
            if len(image_urls) < max_images:
                try:
                    client = Client(api_key=self.serpapi_key)
                    params = {
                        "engine": "google_images",
                        "q": f"{query} educational diagram",
                        "num": max_images - len(image_urls),
                        "ijn": 0,
                        "api_key": self.serpapi_key
                    }
                    
                    result = client.search(params)
                    
                    if hasattr(result, 'get') and result.get('images_results'):
                        images = result['images_results']
                        for img in images:
                            if len(image_urls) >= max_images:
                                break
                            image_urls.append({
                                'url': img.get('original', ''),
                                'title': img.get('title', ''),
                                'source': img.get('source', ''),
                                'thumbnail': img.get('thumbnail', '')
                            })
                except Exception as e:
                    logger.error(f"Error in general image search: {e}")
            
            return image_urls
            
        except Exception as e:
            logger.error(f"Error in get_images: {e}")
            return self.get_fallback_images(query, max_images)
    
    def get_fallback_images(self, query, max_images=3):
        """Provide fallback placeholder images when API fails"""
        fallback_images = []
        for i in range(min(max_images, 3)):
            fallback_images.append({
                'url': f'https://via.placeholder.com/600x400?text={query.replace(" ", "+")}+Diagram+{i+1}',
                'title': f'{query} - Diagram {i+1}',
                'source': 'placeholder',
                'thumbnail': f'https://via.placeholder.com/300x200?text={query.replace(" ", "+")}+{i+1}'
            })
        return fallback_images
    
    def get_resources_for_concept(self, subject, concept, atom_name=None):
        """
        Get both videos and images for a concept
        """
        # Create search queries
        if atom_name:
            main_query = f"{subject} {concept} {atom_name}"
            specific_query = f"{atom_name} in {concept}"
        else:
            main_query = f"{subject} {concept}"
            specific_query = concept
        
        # Fetch resources with error handling
        videos = []
        images = []
        
        try:
            videos = self.get_youtube_videos(main_query, max_results=2)
        except Exception as e:
            logger.error(f"Error fetching videos: {e}")
        
        try:
            images = self.get_images(main_query, max_images=3)
        except Exception as e:
            logger.error(f"Error fetching images: {e}")
        
        # If no results, try more specific query
        if not videos and not images:
            try:
                videos = self.get_youtube_videos(specific_query, max_results=2)
                images = self.get_images(specific_query, max_images=3)
            except Exception as e:
                logger.error(f"Error in fallback search: {e}")
        
        return {
            'videos': videos,
            'images': images
        }


================================================
FILE: backend/learning_engine/knowledge_tracing.py
================================================
import math
from typing import Dict, Any, Optional

def bkt_update(p_know: float, correct: bool, p_slip: float = 0.1, 
               p_guess: float = 0.2, p_learn: float = 0.15) -> float:
    """
    Bayesian Knowledge Tracing update
    
    Args:
        p_know: Current probability student knows the skill
        correct: Whether answer was correct
        p_slip: Probability of slip (wrong despite knowing)
        p_guess: Probability of guess (correct despite not knowing)
        p_learn: Probability of learning after opportunity
    
    Returns:
        Updated probability of knowledge
    """
    if correct:
        numerator = p_know * (1 - p_slip)
        denominator = numerator + (1 - p_know) * p_guess
    else:
        numerator = p_know * p_slip
        denominator = numerator + (1 - p_know) * (1 - p_guess)
    
    posterior = numerator / denominator if denominator != 0 else p_know
    
    # Learning transition
    updated = posterior + (1 - posterior) * p_learn
    
    return min(1.0, max(0.0, updated))

def irt_probability(theta: float, b: float, a: float = 1.0) -> float:
    """
    Item Response Theory 2PL model
    
    Args:
        theta: Student ability
        b: Item difficulty
        a: Item discrimination
    
    Returns:
        Probability of correct response
    """
    return 1 / (1 + math.exp(-a * (theta - b)))

def update_theta(theta: float, correct: bool, b: float, 
                 a: float = 1.0, lr: float = 0.4) -> float:
    """
    Update theta using gradient of log-likelihood
    
    Args:
        theta: Current ability estimate
        correct: Whether answer was correct
        b: Item difficulty
        a: Item discrimination
        lr: Learning rate
    
    Returns:
        Updated ability estimate
    """
    predicted = irt_probability(theta, b, a)
    actual = 1.0 if correct else 0.0
    
    # Simple gradient update
    theta = theta + lr * (actual - predicted)
    
    return theta

def classify_behavior(correct: bool, time_taken: float, 
                      estimated_time: int) -> str:
    """
    Classify student behavior based on correctness and time
    
    Args:
        correct: Whether answer was correct
        time_taken: Actual time taken in seconds
        estimated_time: Expected time in seconds
    
    Returns:
        Behavior classification
    """
    if estimated_time <= 0:
        return "normal_correct" if correct else "confused"
        
    ratio = time_taken / estimated_time
    
    if correct:
        if ratio < 0.7:
            return "strong_mastery"
        elif ratio > 1.3:
            return "weak_mastery"
        else:
            return "normal_correct"
    else:
        if ratio < 0.7:
            return "guessing"
        else:
            return "confused"

def update_mastery_from_behavior(score: float, behavior: str) -> float:
    """
    Update mastery score based on behavior classification
    
    Args:
        score: Current mastery score
        behavior: Behavior classification
    
    Returns:
        Updated mastery score
    """
    weights = {
        "strong_mastery": 2.0,
        "normal_correct": 1.0,
        "weak_mastery": 0.5,
        "guessing": -1.0,
        "confused": -0.5,
    }
    
    # Convert to 0-1 range update
    update = weights.get(behavior, 0) * 0.05
    return min(1.0, max(0.0, score + update))

def classify_error_type(question: Dict[str, Any], answer: int, 
                       time_taken: float, atom_name: str) -> Optional[str]:
    """
    Classify error type based on question, answer, and timing
    
    Args:
        question: Question dictionary
        answer: Selected answer index
        time_taken: Time taken in seconds
        atom_name: Name of the teaching atom
    
    Returns:
        Error type string or None if correct
    """
    correct = (answer == question.get('correct_index'))
    estimated = question.get('estimated_time', 60)
    time_ratio = time_taken / estimated if estimated > 0 else 1.0
    
    if not correct:
        # Fast wrong = guessing
        if time_ratio < 0.5:
            return "guessing"
        
        # Slow wrong on easy question = conceptual
        if question.get('difficulty') == 'easy' and time_ratio > 1.3:
            return "conceptual"
        
        # Check for structural errors
        q_text = question.get('question', '').lower()
        if any(term in q_text for term in ['mapping', 'between', 'versus', 'vs', 'relationship']):
            return "structural"
        
        # Check if it's a factual error
        if question.get('difficulty') == 'easy':
            return "factual"
        
        # Default
        return "procedural"
    
    # Even correct answers can indicate issues
    if correct and time_ratio < 0.3:
        return "attentional"
    
    return None


# backend/learning_engine/knowledge_tracing.py

def classify_error_type(question, answer, time_taken, atom_name):
    """Classify error type based on question, answer, and timing"""
    if answer == -1:  # No answer
        return "no_answer"
    
    estimated = question.get('estimated_time', 60)
    time_ratio = time_taken / estimated if estimated > 0 else 1.0
    
    # Fast wrong = guessing
    if time_ratio < 0.5:
        return "guessing"
    
    # Slow wrong on easy question = conceptual
    if question.get('difficulty') == 'easy' and time_ratio > 1.3:
        return "conceptual"
    
    # Check for structural errors based on question content
    q_text = question.get('question', '').lower()
    if any(term in q_text for term in ['compare', 'contrast', 'difference', 'relationship']):
        return "structural"
    
    # Check if it's a factual error
    if question.get('difficulty') == 'easy':
        return "factual"
    
    # Default
    return "procedural"

def bkt_update(p_know, correct, p_slip=0.1, p_guess=0.2, p_learn=0.15):
    """Bayesian Knowledge Tracing update"""
    if correct:
        numerator = p_know * (1 - p_slip)
        denominator = numerator + (1 - p_know) * p_guess
    else:
        numerator = p_know * p_slip
        denominator = numerator + (1 - p_know) * (1 - p_guess)
    
    posterior = numerator / denominator if denominator != 0 else p_know
    
    # Learning transition
    updated = posterior + (1 - posterior) * p_learn
    
    return min(1.0, max(0.0, updated))

def update_theta(theta, correct, b=0.0, a=1.0, lr=0.4):
    """Update IRT theta parameter"""
    import math
    
    # IRT probability
    def irt_prob(theta, b, a):
        return 1 / (1 + math.exp(-a * (theta - b)))
    
    predicted = irt_prob(theta, b, a)
    actual = 1.0 if correct else 0.0
    
    # Gradient update
    theta = theta + lr * (actual - predicted)
    
    return theta



# backend/learning_engine/knowledge_tracing.py - Enhanced version

import math
import numpy as np
from typing import Dict, Any, Optional, Tuple

def calculate_updated_mastery(
    current_mastery: float,
    current_theta: float,
    question: Dict[str, Any],
    correct: bool,
    time_taken: float,
    error_type: Optional[str]
) -> Tuple[float, float, Dict[str, float]]:
    """
    Real-time mastery estimation after every answer
    
    Args:
        current_mastery: Current mastery score (0-1)
        current_theta: Current ability parameter
        question: Question dictionary with difficulty, estimated_time
        correct: Whether answer was correct
        time_taken: Time taken in seconds
        error_type: Classified error type or None if correct
    
    Returns:
        Tuple of (new_mastery, new_theta, metrics)
    """
    # Extract question parameters
    difficulty = question.get('difficulty', 'medium')
    estimated_time = question.get('estimated_time', 60)
    cognitive = question.get('cognitive_operation', 'recall')
    
    # Map difficulty to item parameter b (IRT difficulty)
    difficulty_map = {
        'easy': -1.0,
        'medium': 0.0,
        'hard': 1.0
    }
    b = difficulty_map.get(difficulty, 0.0)
    
    # Map cognitive to discrimination a (IRT discrimination)
    cognitive_map = {
        'recall': 0.8,
        'apply': 1.2,
        'analyze': 1.5
    }
    a = cognitive_map.get(cognitive, 1.0)
    
    # Calculate time ratio (normalized)
    time_ratio = time_taken / estimated_time if estimated_time > 0 else 1.0
    
    # 1. Update IRT theta (ability)
    new_theta = update_theta_weighted(
        current_theta, correct, b, a, 
        time_ratio, error_type
    )
    
    # 2. Update mastery based on multiple factors
    mastery_update = calculate_mastery_update(
        current_mastery, correct, time_ratio, 
        error_type, difficulty
    )
    
    new_mastery = min(1.0, max(0.0, current_mastery + mastery_update))
    
    # 3. Calculate performance metrics
    metrics = {
        'theta_change': new_theta - current_theta,
        'mastery_change': mastery_update,
        'confidence': calculate_confidence(correct, time_ratio, error_type),
        'learning_rate': mastery_update / 0.1,  # Normalized learning rate
        'performance_quality': calculate_performance_quality(correct, time_ratio, error_type)
    }
    
    return new_mastery, new_theta, metrics


def update_theta_weighted(
    theta: float,
    correct: bool,
    b: float,
    a: float,
    time_ratio: float,
    error_type: Optional[str],
    base_lr: float = 0.4
) -> float:
    """
    Update theta with time and error-type weighting
    """
    # IRT probability
    prob_correct = 1 / (1 + math.exp(-a * (theta - b)))
    
    # Actual outcome (continuous for weighted updates)
    actual = 1.0 if correct else 0.0
    
    # Calculate confidence weight based on time
    if correct:
        # Fast correct = high confidence
        confidence_weight = min(1.5, 1.0 / max(0.3, time_ratio))
    else:
        # Slow wrong = low confidence, fast wrong = guessing
        if time_ratio < 0.5:  # Guessing
            confidence_weight = 0.3
        elif time_ratio > 1.5:  # Struggling
            confidence_weight = 0.7
        else:
            confidence_weight = 0.5
    
    # Adjust learning rate based on error type
    error_multipliers = {
        'guessing': 0.3,      # Less update from guesses
        'attentional': 0.6,    # Moderate update
        'factual': 0.8,        # Stronger update
        'procedural': 0.9,     # Strong update
        'conceptual': 1.2,     # Very strong update (conceptual errors matter)
        'structural': 1.1,      # Strong update
        None: 1.0               # Normal for correct
    }
    
    error_mult = error_multipliers.get(error_type, 1.0)
    
    # Apply weighted update
    adjusted_lr = base_lr * confidence_weight * error_mult
    theta_update = adjusted_lr * (actual - prob_correct)
    
    return theta + theta_update


def calculate_mastery_update(
    current_mastery: float,
    correct: bool,
    time_ratio: float,
    error_type: Optional[str],
    difficulty: str
) -> float:
    """
    Calculate mastery update with nuanced factors
    """
    # Base update amount
    base_update = 0.05
    
    # Difficulty multiplier
    difficulty_multipliers = {
        'easy': 0.7,    # Less impact from easy questions
        'medium': 1.0,
        'hard': 1.3     # More impact from hard questions
    }
    diff_mult = difficulty_multipliers.get(difficulty, 1.0)
    
    if correct:
        # Time factor for correct answers
        if time_ratio < 0.7:  # Fast correct
            time_factor = 1.3
        elif time_ratio < 1.0:  # Normal
            time_factor = 1.0
        else:  # Slow but correct
            time_factor = 0.7
        
        # Mastery increases less as it approaches 1.0
        ceiling_factor = (1.0 - current_mastery) * 2
        
        update = base_update * diff_mult * time_factor * ceiling_factor
        
    else:  # Incorrect
        # Different impacts based on error type
        error_impacts = {
            'guessing': -0.02,      # Small penalty - just guessing
            'attentional': -0.03,    # Small penalty - careless
            'factual': -0.06,        # Moderate - missing facts
            'procedural': -0.08,     # Significant - don't know process
            'conceptual': -0.12,     # Severe - fundamental misunderstanding
            'structural': -0.10      # Severe - can't see relationships
        }
        
        update = error_impacts.get(error_type, -0.05)
        
        # Additional time factor for wrong answers
        if time_ratio > 1.5:  # Very slow wrong = struggling
            update *= 1.3
        elif time_ratio < 0.5:  # Fast wrong = guessing
            update *= 0.7
    
    return update


def calculate_confidence(correct: bool, time_ratio: float, error_type: Optional[str]) -> float:
    """
    Calculate confidence in the response (0-1)
    """
    if correct:
        # Higher confidence for fast correct answers
        confidence = min(1.0, 1.2 - time_ratio * 0.3)
    else:
        # Lower confidence for wrong answers, especially fast wrong
        if error_type == 'guessing':
            confidence = 0.1
        elif error_type == 'attentional':
            confidence = 0.3
        elif time_ratio < 0.5:
            confidence = 0.2
        elif time_ratio > 1.5:
            confidence = 0.5  # At least tried
        else:
            confidence = 0.4
    
    return max(0.1, min(1.0, confidence))


def calculate_performance_quality(correct: bool, time_ratio: float, error_type: Optional[str]) -> float:
    """
    Calculate overall performance quality (-1 to 1)
    """
    if correct:
        quality = 1.0 - abs(1.0 - time_ratio) * 0.5
    else:
        if error_type == 'guessing':
            quality = -0.8
        elif error_type == 'attentional':
            quality = -0.3
        elif error_type == 'conceptual':
            quality = -0.6
        else:
            quality = -0.4
    
    return max(-1.0, min(1.0, quality))


================================================
FILE: backend/learning_engine/models.py
================================================
from dataclasses import dataclass, field
from typing import List, Dict, Optional
from enum import Enum


class LearningPhase(str, Enum):
    DIAGNOSTIC = "diagnostic"
    TEACHING = "teaching"
    PRACTICE = "practice"
    REINFORCEMENT = "reinforcement"
    MASTERY_CHECK = "mastery_check"
    COMPLETE = "complete"


class ErrorType(str, Enum):
    CONCEPTUAL = "conceptual"
    PROCEDURAL = "procedural"
    FACTUAL = "factual"
    GUESSING = "guessing"
    STRUCTURAL = "structural"
    ATTENTIONAL = "attentional"


class PacingDecision(str, Enum):
    SPEED_UP = "speed_up"
    SLOW_DOWN = "slow_down"
    SHARP_SLOWDOWN = "sharp_slowdown"
    STAY = "stay"
    REINFORCE = "reinforce"
    ADVANCE = "advance"
    RETREAT = "retreat"


@dataclass
class TeachingAtomState:
    """Represents a teaching atom's state in memory â€” enriched for the 10-feature pacing engine."""
    id: int
    name: str
    mastery_score: float = 0.3
    phase: LearningPhase = LearningPhase.DIAGNOSTIC
    streak: int = 0
    hint_usage: int = 0
    error_history: List[str] = None
    retention_verified: bool = False

    # â”€â”€ Per-atom learning speed (feature 2) â”€â”€
    time_per_question: List[float] = None

    # â”€â”€ Retention tracking (feature 6) â”€â”€
    retention_score: float = 1.0
    retention_checks_passed: int = 0
    retention_checks_failed: int = 0
    last_practiced_minutes_ago: float = 0.0

    # â”€â”€ Velocity snapshots (feature 10) â”€â”€
    velocity_snapshots: List[Dict] = None

    def __post_init__(self):
        if self.error_history is None:
            self.error_history = []
        if self.time_per_question is None:
            self.time_per_question = []
        if self.velocity_snapshots is None:
            self.velocity_snapshots = []

    def to_dict(self):
        return {
            'id': self.id,
            'name': self.name,
            'mastery_score': self.mastery_score,
            'phase': self.phase.value if hasattr(self.phase, 'value') else self.phase,
            'streak': self.streak,
            'hint_usage': self.hint_usage,
            'retention_verified': self.retention_verified,
            'error_history': self.error_history[-5:],
            'retention_score': self.retention_score,
            'retention_checks_passed': self.retention_checks_passed,
            'time_per_question': self.time_per_question[-10:],
            'velocity_snapshots': self.velocity_snapshots[-20:],
        }



================================================
FILE: backend/learning_engine/pacing_engine.py
================================================
Error reading file with 'cp1252': 'charmap' codec can't decode byte 0x90 in position 1045: character maps to <undefined>


================================================
FILE: backend/learning_engine/question_generator.py
================================================
# backend/learning_engine/question_generator.py - Complete fixed version

import json
import os
from typing import Dict, List, Optional
from groq import Groq
import google.generativeai as genai
from django.conf import settings

class QuestionGenerator:
    """Generate questions and atoms for learning using AI"""
    
    def __init__(self):
        # Initialize Groq client
        groq_key = getattr(settings, 'GROQ_API_KEY', '')
        self.groq_client = Groq(api_key=groq_key) if groq_key else None
        
        # Initialize Gemini client
        gemini_key = getattr(settings, 'GOOGLE_API_KEY', '')
        if gemini_key:
            genai.configure(api_key=gemini_key)
            self.gemini_model = genai.GenerativeModel('gemini-2.5-flash')
        else:
            self.gemini_model = None

    @staticmethod
    def _validate_questions(questions: list) -> list:
        """
        Validate and sanitise AI-generated questions.
        - Ensures correct_index is an int within [0, len(options)-1]
        - Ensures options is a list of exactly 4 strings
        - Drops any malformed question instead of passing it through
        """
        validated = []
        for q in questions:
            opts = q.get('options')
            if not isinstance(opts, list) or len(opts) != 4:
                continue  # Skip malformed question

            ci = q.get('correct_index')
            try:
                ci = int(ci)
            except (TypeError, ValueError):
                ci = 0  # Fallback to first option

            if ci < 0 or ci >= len(opts):
                ci = 0  # Clamp to safe default

            q['correct_index'] = ci
            validated.append(q)
        return validated
    
    def generate_atoms(self, subject: str, concept: str) -> List[str]:
        """
        Generate atomic concepts using Gemini
        
        Args:
            subject: Subject name (e.g., 'Microprocessor')
            concept: Concept name (e.g., 'Memory Organization')
        
        Returns:
            List of atomic concept names
        """
        if not self.gemini_model:
            print("Gemini model not available, using fallback atoms")
            return self._get_fallback_atoms(subject, concept)
        
        prompt = f"""
        You are generating atomic sub-concepts for curriculum design.

        Subject: {subject}
        Concept: {concept}

        You must follow ALL rules strictly.

        STRICT RULES:
        1. Generate EXACTLY between 4 and 6 atoms.
        2. Each atom must be:
           - A noun or noun phrase only.
           - Maximum 4 words.
           - No verbs.
           - No full sentences.
        3. All atoms must belong to the SAME abstraction level.
        4. Do NOT generate:
           - Parentâ€“child pairs
           - General-to-specific relationships
           - Negation pairs (pre/non, with/without, static/dynamic)
           - Overlapping concepts
           - Duplicates
        5. Each atom must be independently assessable.
        6. Do NOT include the concept name itself.
        7. No explanations.
        8. No numbering.
        9. No markdown.
        10. Output STRICT JSON only.

        Output format:
        {{
            "atoms": [
                "Atom 1",
                "Atom 2",
                "Atom 3",
                "Atom 4"
            ]
        }}

        If rules cannot be satisfied, return:
        {{"atoms": []}}
        """
        
        try:
            response = self.gemini_model.generate_content(prompt)
            
            # Extract JSON from response
            text = response.text
            if "```" in text:
                text = text.split("```")[1]
                if text.startswith("json"):
                    text = text[4:]
            
            result = json.loads(text.strip())
            atoms = result.get("atoms", [])
            
            # Validate atom count
            if len(atoms) < 4 or len(atoms) > 6:
                print(f"Invalid atom count: {len(atoms)}, using fallback")
                return self._get_fallback_atoms(subject, concept)
            
            return atoms
            
        except Exception as e:
            print(f"Error generating atoms: {e}")
            return self._get_fallback_atoms(subject, concept)
    
    # backend/learning_engine/question_generator.py - Updated method

    def generate_questions(self, subject: str, concept: str, atom: str,
                        target_difficulty: str, count: int, 
                        knowledge_level: str = 'intermediate',
                        error_focus: List[str] = None) -> List[Dict]:
        """
        Generate questions for an atom with dynamic difficulty
        
        Args:
            subject: Subject name
            concept: Concept name
            atom: Atomic concept name
            target_difficulty: Specific difficulty to generate ('easy', 'medium', 'hard')
            count: Number of questions needed
            knowledge_level: Student's knowledge level
            error_focus: Optional list of error types to address
        
        Returns:
            List of question dictionaries
        """
        print(f"Generating {count} {target_difficulty} questions for atom: {atom}")
        
        if not self.groq_client or count == 0:
            return self._get_fallback_questions(atom, target_difficulty, count, knowledge_level)
        
        # Adjust based on knowledge level
        level_adjustments = {
            'zero': {
                'cognitive': ['recall'],
                'time_factor': 1.5,
                'complexity': 'very simple, foundational',
                'hint_level': 'detailed'
            },
            'beginner': {
                'cognitive': ['recall', 'apply'],
                'time_factor': 1.2,
                'complexity': 'straightforward',
                'hint_level': 'clear'
            },
            'intermediate': {
                'cognitive': ['recall', 'apply', 'analyze'],
                'time_factor': 1.0,
                'complexity': 'moderate',
                'hint_level': 'moderate'
            },
            'advanced': {
                'cognitive': ['apply', 'analyze'],
                'time_factor': 0.8,
                'complexity': 'challenging',
                'hint_level': 'subtle'
            }
        }
        
        adj = level_adjustments.get(knowledge_level, level_adjustments['intermediate'])
        
        # Determine cognitive operations for this difficulty
        if target_difficulty == 'easy':
            allowed_cognitive = ['recall']
        elif target_difficulty == 'medium':
            allowed_cognitive = ['recall', 'apply']
        else:  # hard
            allowed_cognitive = ['apply', 'analyze']
        
        # Add error focus if provided
        error_context = ""
        if error_focus:
            error_context = f"""
            Focus on addressing these common errors:
            {', '.join(error_focus)}
            
            Create questions that help the student overcome these specific difficulties.
            """
        
        prompt = f"""
            You are an experienced teacher creating high-quality conceptual assessment questions to evaluate deep student understanding.

            Subject: {subject}
            Concept: {concept}
            Atomic Concept: {atom}
            Student Level: {knowledge_level.upper()}
            Target Difficulty: {target_difficulty.upper()}

            Generate EXACTLY {count} {target_difficulty} question(s) with these characteristics:

            - Complexity: {adj['complexity']}
            - Cognitive levels: {', '.join(allowed_cognitive)}
            - Hint level: {adj['hint_level']}

            {error_context}

            CRITICAL QUALITY REQUIREMENTS:

            The goal is to test CONCEPTUAL UNDERSTANDING, not memorization.

            Each question MUST:

            - Be written like an experienced teacher checking real understanding
            - Require thinking, reasoning, or application â€” NOT simple definition recall
            - Be scenario-based, example-based, comparison-based, or reasoning-based whenever possible
            - Explicitly involve the atomic concept in a meaningful way
            - Avoid trivial, obvious, or keyword-matching questions
            - Avoid fill-in-the-blank style

            OPTIONS REQUIREMENTS (VERY IMPORTANT):

            Each question must have exactly 4 options where:

            - All options are plausible and believable
            - All options belong to the SAME conceptual category
            - Incorrect options must reflect common student misconceptions or mistakes
            - Avoid joke options, extreme options, or obviously wrong answers
            - Avoid options that differ only in grammar or wording tricks

            QUESTION LENGTH:

            - 10 to 35 words REQUIRED
            - Must be self-contained and clear

            DIFFICULTY REQUIREMENTS:

            For {target_difficulty} questions:

            Easy:
            - Simple scenario or example
            - Direct conceptual application

            Medium:
            - Requires reasoning, interpretation, or comparison

            Hard:
            - Multi-step reasoning, prediction, or analysis


            Each question MUST include:

            - "difficulty": "{target_difficulty}"
            - "cognitive_operation": one of {allowed_cognitive}
            - "estimated_time": integer (seconds)
                recall: 20-40
                apply: 40-90
                analyze: 90-150
            - "question": string
            - "options": array of exactly 4 strings
            - "correct_index": integer (0-3)

            OUTPUT STRICT JSON ONLY:

            {{
                "questions": [
                    {{
                        "difficulty": "{target_difficulty}",
                        "cognitive_operation": "recall",
                        "estimated_time": 30,
                        "question": "Question text here?",
                        "options": [
                            "Option A",
                            "Option B",
                            "Option C",
                            "Option D"
                        ],
                        "correct_index": 1
                    }}
                ]
            }}

            If constraints cannot be satisfied, return:

            {{"questions": []}}
            """

        
        try:
            response = self.groq_client.chat.completions.create(
                model="llama-3.3-70b-versatile",
                messages=[{"role": "user", "content": prompt}],
                temperature=0.3,
                max_tokens=2048,
            )
            
            raw_text = response.choices[0].message.content
            if "```" in raw_text:
                raw_text = raw_text.split("```")[1]
                if raw_text.startswith("json"):
                    raw_text = raw_text[4:]
            
            result = json.loads(raw_text.strip())
            questions = result.get("questions", [])

            # Validate correct_index and options for every question
            questions = self._validate_questions(questions)
            
            # Adjust estimated time based on knowledge level
            for q in questions:
                q['estimated_time'] = int(q.get('estimated_time', 60) * adj['time_factor'])
            
            print(f"Generated {len(questions)} {target_difficulty} questions")
            return questions
            
        except Exception as e:
            print(f"Error generating questions: {e}")
            return self._get_fallback_questions(atom, target_difficulty, count, knowledge_level)
    
    def _get_fallback_atoms(self, subject: str, concept: str) -> List[str]:
        """Provide fallback atoms when AI generation fails"""
        # Common fallback atoms based on concept
        fallbacks = {
            "Memory Organization": [
                "Address Space",
                "Memory Hierarchy",
                "Cache Memory",
                "RAM vs ROM",
                "Memory Mapping"
            ],
            "Address Space": [
                "Address Lines",
                "Memory Locations",
                "Address Decoding",
                "Word Size",
                "Byte Addressing"
            ],
            "Cache Memory": [
                "Cache Levels",
                "Cache Hit/Miss",
                "Cache Mapping",
                "Replacement Policy",
                "Write Policy"
            ]
        }
        
        # Try to find matching fallback
        for key, atoms in fallbacks.items():
            if key.lower() in concept.lower():
                return atoms
        
        # Generic fallback
        return [
            f"{concept} Basics",
            f"{concept} Structure",
            f"{concept} Operations",
            f"{concept} Applications",
            f"{concept} Limitations"
        ]
    
    def _get_fallback_questions(self, atom: str, target_difficulty: str, count: int,
                                level: str = 'intermediate') -> List[Dict]:
        """Provide fallback questions when AI generation fails"""
        questions = []

        for _ in range(count):
            if target_difficulty == 'easy':
                questions.append({
                    "difficulty": "easy",
                    "cognitive_operation": "recall",
                    "estimated_time": 30,
                    "question": f"What is the primary purpose of {atom}?",
                    "options": [
                        f"To manage {atom} operations",
                        "To store data permanently",
                        "To execute instructions",
                        "To control peripherals"
                    ],
                    "correct_index": 0
                })
            elif target_difficulty == 'medium':
                questions.append({
                    "difficulty": "medium",
                    "cognitive_operation": "apply",
                    "estimated_time": 60,
                    "question": f"Which scenario best demonstrates the application of {atom}?",
                    "options": [
                        f"When implementing {atom} in a real system",
                        "During basic operations",
                        "In simple calculations",
                        "At the start of processing"
                    ],
                    "correct_index": 0
                })
            else:
                questions.append({
                    "difficulty": "hard",
                    "cognitive_operation": "analyze",
                    "estimated_time": 90,
                    "question": f"What would happen if {atom} was implemented incorrectly?",
                    "options": [
                        "System performance would degrade",
                        "Nothing would change",
                        "The system would run faster",
                        "Data would be more secure"
                    ],
                    "correct_index": 0
                })

        return questions
    
    def generate_complete_concept(self, subject: str, concept: str) -> Dict:
        """
        Generate complete concept with atoms and questions
        
        Args:
            subject: Subject name
            concept: Concept name
        
        Returns:
            Dictionary with atoms and questions
        """
        print(f"Generating complete concept for {subject} - {concept}")
        
        # Generate atoms
        atoms = self.generate_atoms(subject, concept)
        print(f"Generated {len(atoms)} atoms: {atoms}")
        
        result = {
            "concept": concept,
            "subject": subject,
            "atoms": {}
        }
        
        # Generate questions for each atom
        for atom in atoms:
            print(f"Generating questions for atom: {atom}")
            # Generate 2 easy and 2 medium questions per atom
            questions = []
            questions.extend(self.generate_questions(
                subject=subject,
                concept=concept,
                atom=atom,
                target_difficulty='easy',
                count=2,
                knowledge_level='intermediate'
            ))
            questions.extend(self.generate_questions(
                subject=subject,
                concept=concept,
                atom=atom,
                target_difficulty='medium',
                count=2,
                knowledge_level='intermediate'
            ))
            
            result["atoms"][atom] = {
                "name": atom,
                "questions": questions
            }
            
            print(f"Generated {len(questions)} questions for {atom}")
        
        return result
    
    
    
    def generate_initial_quiz(self, subject: str, concept: str,
                              knowledge_level: str = 'intermediate',
                              count: int = 5) -> List[Dict]:
        """
        Simple diagnostic quiz based only on subject/concept/knowledge level.
        Uses the same question generator with atom=concept for simplicity.
        """
        easy_count = max(1, count // 2)
        medium_count = max(0, count - easy_count)

        questions = []
        questions.extend(self.generate_questions(
            subject=subject,
            concept=concept,
            atom=concept,
            target_difficulty='easy',
            count=easy_count,
            knowledge_level=knowledge_level
        ))
        if medium_count > 0:
            questions.extend(self.generate_questions(
                subject=subject,
                concept=concept,
                atom=concept,
                target_difficulty='medium',
                count=medium_count,
                knowledge_level=knowledge_level
            ))

        return questions

    def generate_questions_from_teaching(self, subject, concept, atom, teaching_content, 
                                        need_easy=1, need_medium=2, need_hard=0, 
                                        knowledge_level='intermediate'):
        """
        Generate questions based on the teaching content that was shown
        
        Args:
            subject: Subject name
            concept: Concept name
            atom: Atomic concept name
            teaching_content: Dict with explanation, analogy, examples
            need_easy: Number of easy questions
            need_medium: Number of medium questions
            need_hard: Number of hard questions
            knowledge_level: Student's knowledge level
        
        Returns:
            List of question dictionaries
        """
        print(f"Generating questions from teaching for atom: {atom}")
        
        if not self.groq_client:
            print("Groq client not available, using fallback")
            return self._get_fallback_questions_from_teaching(atom, need_easy, need_medium, need_hard)
        
        total_needed = need_easy + need_medium + need_hard
        
        # Extract teaching content
        explanation = teaching_content.get('explanation', '')
        analogy = teaching_content.get('analogy', '')
        examples = teaching_content.get('examples', [])
        
        examples_text = "\n".join([f"- {ex}" for ex in examples if ex])
        
        prompt = f"""
            You are an experienced teacher generating conceptual assessment questions to verify whether a student truly understood the concept that was just taught.

            Subject: {subject}
            Concept: {concept}
            Atomic Concept: {atom}
            Student Level: {knowledge_level.upper()}

            TEACHING CONTENT SHOWN TO STUDENT:

            Explanation:
            {explanation}

            Analogy:
            {analogy}

            Examples/Applications:
            {examples_text}


            TASK:

            Generate EXACTLY {total_needed} multiple-choice questions that test CONCEPTUAL UNDERSTANDING of "{atom}" based on the teaching content.

            IMPORTANT:

            The goal is NOT to test memory of the explanation, analogy, or examples.

            The goal is to test whether the student understood the underlying CONCEPT.


            CRITICAL RULES:

            1. DO NOT ask questions about the analogy itself
            2. DO NOT ask questions about the specific examples themselves
            3. DO NOT ask questions that require recalling sentences from the explanation

            4. Instead, create NEW conceptual situations where the student must APPLY the concept

            5. Questions must test:

            - understanding of how the concept works
            - when the concept applies
            - when the concept does NOT apply
            - consequences of using or misusing the concept

            6. Each question must be meaningful, realistic, and require thinking

            7. Avoid definition questions starting with:

            - What is
            - Define
            - Identify

            8. Each question must be 18â€“35 words

            9. Each question must have exactly 4 options

            10. All options must be:

            - plausible
            - same conceptual category
            - based on realistic student mistakes or misconceptions

            11. Avoid obvious wrong answers


            DIFFICULTY DISTRIBUTION:

            Easy ({need_easy}):

            - Simple conceptual application

            Medium ({need_medium}):

            - Requires reasoning or interpretation

            Hard ({need_hard}):

            - Requires deeper reasoning, prediction, or identifying incorrect application



            OUTPUT STRICT JSON ONLY:

            {{
                "questions": [
                    {{
                        "difficulty": "easy",
                        "cognitive_operation": "apply",
                        "estimated_time": 40,
                        "question": "Question text here?",
                        "options": [
                            "Option A",
                            "Option B",
                            "Option C",
                            "Option D"
                        ],
                        "correct_index": 0
                    }}
                ]
            }}
            """

        
        try:
            response = self.groq_client.chat.completions.create(
                model="llama-3.3-70b-versatile",
                messages=[{"role": "user", "content": prompt}],
                temperature=0.3,
                max_tokens=2048,
            )
            
            raw_text = response.choices[0].message.content
            if "```" in raw_text:
                raw_text = raw_text.split("```")[1]
                if raw_text.startswith("json"):
                    raw_text = raw_text[4:]
            
            result = json.loads(raw_text.strip())
            questions = result.get("questions", [])

            # Validate correct_index and options for every question
            questions = self._validate_questions(questions)
            
            print(f"Generated {len(questions)} questions from teaching")
            return questions
            
        except Exception as e:
            print(f"Error generating questions from teaching: {e}")
            return self._get_fallback_questions_from_teaching(atom, need_easy, need_medium, need_hard)

    def _get_fallback_questions_from_teaching(self, atom, need_easy, need_medium, need_hard):
        """Fallback questions based on teaching content"""
        questions = []
        
        # Easy questions
        for i in range(need_easy):
            questions.append({
                "difficulty": "easy",
                "cognitive_operation": "recall",
                "estimated_time": 30,
                "question": f"What is the main purpose of {atom}?",
                "options": [
                    f"To {atom.lower()} efficiently",
                    "To store data permanently",
                    "To execute instructions",
                    "To control peripherals"
                ],
                "correct_index": 0
            })
        
        # Medium questions
        for i in range(need_medium):
            questions.append({
                "difficulty": "medium",
                "cognitive_operation": "apply",
                "estimated_time": 60,
                "question": f"Which scenario best demonstrates the application of {atom}?",
                "options": [
                    f"When implementing {atom} in a real system",
                    "During basic operations",
                    "In simple calculations",
                    "At the start of processing"
                ],
                "correct_index": 0
            })
        
        # Hard questions
        for i in range(need_hard):
            questions.append({
                "difficulty": "hard",
                "cognitive_operation": "analyze",
                "estimated_time": 90,
                "question": f"What would happen if {atom} was implemented incorrectly?",
                "options": [
                    "System performance would degrade",
                    "Nothing would change",
                    "The system would run faster",
                    "Data would be more secure"
                ],
                "correct_index": 0
            })
        
        return questions


================================================
FILE: backend/learning_engine/utils.py
================================================
import json
from typing import Any, Dict, List

def extract_json(text: str) -> str:
    """Extract JSON from text that might contain markdown code blocks"""
    text = text.strip()
    if text.startswith("```"):
        # Remove fenced code block markers
        lines = [ln.rstrip() for ln in text.splitlines()]
        if lines and lines[0].startswith("```"):
            lines = lines[1:]
        if lines and lines[-1].startswith("```"):
            lines = lines[:-1]
        text = "\n".join(lines).strip()
        if text.lower().startswith("json"):
            text = text[4:].strip()
    return text

def normalize_difficulty(value: str) -> str:
    """Normalize difficulty string"""
    v = (value or "").strip().lower()
    if v in ("med", "mid"):
        return "medium"
    return v

def difficulty_count(questions: List[Dict[str, Any]], difficulty: str) -> int:
    """Count questions of a specific difficulty"""
    d = normalize_difficulty(difficulty)
    return sum(1 for q in questions if normalize_difficulty(q.get("difficulty", "")) == d)

def existing_texts(questions: List[Dict[str, Any]], difficulty: str) -> set:
    """Get set of question texts for a specific difficulty"""
    d = normalize_difficulty(difficulty)
    return {
        (q.get("question") or "").strip().lower()
        for q in questions
        if normalize_difficulty(q.get("difficulty", "")) == d
    }


================================================
FILE: frontend/README.md
================================================
# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) (or [oxc](https://oxc.rs) when used in [rolldown-vite](https://vite.dev/guide/rolldown)) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## React Compiler

The React Compiler is not enabled on this template because of its impact on dev & build performances. To add it, see [this documentation](https://react.dev/learn/react-compiler/installation).

## Expanding the ESLint configuration

If you are developing a production application, we recommend using TypeScript with type-aware lint rules enabled. Check out the [TS template](https://github.com/vitejs/vite/tree/main/packages/create-vite/template-react-ts) for information on how to integrate TypeScript and [`typescript-eslint`](https://typescript-eslint.io) in your project.



================================================
FILE: frontend/eslint.config.js
================================================
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{js,jsx}'],
    extends: [
      js.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    rules: {
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
      'react-hooks/set-state-in-effect': 'off',
      'react-refresh/only-export-components': 'off',
    },
  },
])



================================================
FILE: frontend/index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet" />
    <title>AdaptLearn â€” Adaptive Learning System</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>


================================================
FILE: frontend/package.json
================================================
{
  "name": "frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "axios": "^1.13.5",
    "lucide-react": "^0.575.0",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "react-router-dom": "^7.13.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@types/react": "^19.2.7",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.1",
    "autoprefixer": "^10.4.24",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "postcss": "^8.4.32",
    "tailwindcss": "^3.3.6",
    "vite": "^8.0.0-beta.13"
  },
  "overrides": {
    "vite": "^8.0.0-beta.13"
  }
}



================================================
FILE: frontend/postcss.config.js
================================================
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}



================================================
FILE: frontend/tailwind.config.js
================================================
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  darkMode: 'class',
  theme: {
    extend: {
      colors: {
        primary: {
          DEFAULT: 'rgb(var(--color-primary) / <alpha-value>)',
          light: 'rgb(var(--color-primary-light) / <alpha-value>)',
          dark: 'rgb(var(--color-primary-dark) / <alpha-value>)',
        },
        accent: {
          DEFAULT: 'rgb(var(--color-accent) / <alpha-value>)',
          light: 'rgb(var(--color-accent-light) / <alpha-value>)',
        },
        surface: {
          DEFAULT: 'rgb(var(--color-surface) / <alpha-value>)',
          alt: 'rgb(var(--color-surface-alt) / <alpha-value>)',
        },
        theme: {
          bg: 'rgb(var(--color-bg) / <alpha-value>)',
          text: 'rgb(var(--color-text) / <alpha-value>)',
          'text-secondary': 'rgb(var(--color-text-secondary) / <alpha-value>)',
          'text-muted': 'rgb(var(--color-text-muted) / <alpha-value>)',
          border: 'rgb(var(--color-border) / <alpha-value>)',
          'border-light': 'rgb(var(--color-border-light) / <alpha-value>)',
        },
        success: 'rgb(var(--color-success) / <alpha-value>)',
        warning: 'rgb(var(--color-warning) / <alpha-value>)',
        error: 'rgb(var(--color-error) / <alpha-value>)',
        info: 'rgb(var(--color-info) / <alpha-value>)',
      },
      borderRadius: {
        theme: 'var(--radius)',
        'theme-lg': 'var(--radius-lg)',
        'theme-xl': 'var(--radius-xl)',
      },
      boxShadow: {
        'theme-sm': 'var(--shadow-sm)',
        'theme': 'var(--shadow-md)',
        'theme-lg': 'var(--shadow-lg)',
        'theme-xl': 'var(--shadow-xl)',
      },
      fontFamily: {
        sans: ['Inter', 'system-ui', '-apple-system', 'sans-serif'],
      },
      animation: {
        'fade-in-up': 'fadeInUp 0.5s ease-out forwards',
        'fade-in': 'fadeIn 0.4s ease-out forwards',
        'slide-in-right': 'slideInRight 0.4s ease-out forwards',
        'scale-in': 'scaleIn 0.3s ease-out forwards',
        'float': 'float 3s ease-in-out infinite',
      },
    },
  },
  plugins: [],
}


================================================
FILE: frontend/vite.config.js
================================================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    port: 3000,
    open: true,
    proxy: {
      '/auth': {
        target: 'http://localhost:8000',
        changeOrigin: true,
      },
      '/api': {
        target: 'http://localhost:8000',
        changeOrigin: true,
      }
    }
  }
})


================================================
FILE: frontend/src/App.css
================================================
/* App.css is no longer needed â€” all styles are in index.css + Tailwind */



================================================
FILE: frontend/src/App.jsx
================================================
import React from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import { AuthProvider } from './context/AuthContext';
import { ThemeProvider } from './context/ThemeContext';
import Home from './components/Home';
import Login from './components/Login';
import Register from './components/Register';
import Dashboard from './components/Dashboard';
import ProtectedRoute from './components/ProtectedRoute';
import LearningRoute from './components/Learning/LearningRoute';
import StartAnyConceptSessionRoute from './components/Learning/StartAnyConceptSessionRoute';
import Leaderboard from './components/Leaderboard';
import Progress from './components/Progress';
<<<<<<< HEAD
import AIAssistantPage from './pages/AIAssistantPage.jsx';
=======
>>>>>>> 27ca5f792972d0c6644ef01c0171d1c6ce25ce32

function App() {
    return (
        <ThemeProvider>
            <Router>
                <AuthProvider>
                    <Routes>
                        <Route path="/" element={<Home />} />
                        <Route path="/login" element={<Login />} />
                        <Route path="/register" element={<Register />} />
                        
                        <Route
                            path="/dashboard"
                            element={
                                <ProtectedRoute>
                                    <Dashboard />
                                </ProtectedRoute>
                            }
                        />

                        <Route
                            path="/leaderboard"
                            element={
                                <ProtectedRoute>
                                    <Leaderboard />
                                </ProtectedRoute>
                            }
                        />

                        <Route
                            path="/progress"
                            element={
                                <ProtectedRoute>
                                    <Progress />
                                </ProtectedRoute>
                            }
                        />

                        <Route
                            path="/learn/:conceptId"
                            element={
                                <ProtectedRoute>
                                    <LearningRoute />
                                </ProtectedRoute>
                            }
                        />

                        <Route
                            path="/learn/start"
                            element={
                                <ProtectedRoute>
                                    <StartAnyConceptSessionRoute />
                                </ProtectedRoute>
                            }
                        />
                    </Routes>
<<<<<<< HEAD
                         <AIAssistantPage /> 
=======
>>>>>>> 27ca5f792972d0c6644ef01c0171d1c6ce25ce32
                </AuthProvider>
            </Router>
        </ThemeProvider>
    );
}

export default App;


================================================
FILE: frontend/src/axiosConfig.js
================================================
import axios from 'axios';

const axiosInstance = axios.create({
    baseURL: 'http://localhost:8000',
    headers: {
        'Content-Type': 'application/json',
    },
});

// Add token to requests if it exists
axiosInstance.interceptors.request.use(
    (config) => {
        const token = localStorage.getItem('access_token');
        
        if (token) {
            config.headers.Authorization = `Bearer ${token}`;
        }
        return config;
    },
    (error) => {
        return Promise.reject(error);
    }
);

// Handle 401 errors and token refresh
axiosInstance.interceptors.response.use(
    (response) => response,
    async (error) => {
        const originalRequest = error.config;
        
        // If error is 401 and we haven't tried to refresh token yet
        if (error.response?.status === 401 && !originalRequest._retry) {
            originalRequest._retry = true;
            
            try {
                const refreshToken = localStorage.getItem('refresh_token');
                if (refreshToken) {
                    const response = await axios.post('http://localhost:8000/api/token/refresh/', {
                        refresh: refreshToken
                    });
                    
                    if (response.data.access) {
                        localStorage.setItem('access_token', response.data.access);
                        originalRequest.headers.Authorization = `Bearer ${response.data.access}`;
                        return axiosInstance(originalRequest);
                    }
                }
            } catch (refreshError) {
                // Refresh failed - clear tokens and redirect to login
                localStorage.removeItem('access_token');
                localStorage.removeItem('refresh_token');
                window.location.href = '/login';
            }
        }
        
        return Promise.reject(error);
    }
);

export default axiosInstance;


================================================
FILE: frontend/src/index.css
================================================
@tailwind base;
@tailwind components;
@tailwind utilities;

/* ══════════════════════════════════════════════
   CSS Custom Properties — Light & Dark Themes
   ══════════════════════════════════════════════ */
:root {
  /* Brand palette */
  --color-primary: 99 102 241;
  --color-primary-light: 129 140 248;
  --color-primary-dark: 79 70 229;
  --color-accent: 236 72 153;
  --color-accent-light: 244 114 182;

  /* Surfaces */
  --color-bg: 249 250 251;
  --color-surface: 255 255 255;
  --color-surface-alt: 243 244 246;

  /* Text */
  --color-text: 17 24 39;
  --color-text-secondary: 107 114 128;
  --color-text-muted: 156 163 175;

  /* Borders */
  --color-border: 229 231 235;
  --color-border-light: 243 244 246;

  /* Semantic */
  --color-success: 34 197 94;
  --color-warning: 234 179 8;
  --color-error: 239 68 68;
  --color-info: 59 130 246;

  /* Shadows */
  --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
  --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.07), 0 2px 4px -2px rgb(0 0 0 / 0.07);
  --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.08), 0 4px 6px -4px rgb(0 0 0 / 0.08);
  --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);

  --radius: 0.75rem;
  --radius-lg: 1rem;
  --radius-xl: 1.5rem;
}

.dark {
  --color-primary: 129 140 248;
  --color-primary-light: 165 180 252;
  --color-primary-dark: 99 102 241;
  --color-accent: 244 114 182;
  --color-accent-light: 251 146 199;

  --color-bg: 15 23 42;
  --color-surface: 30 41 59;
  --color-surface-alt: 51 65 85;

  --color-text: 241 245 249;
  --color-text-secondary: 148 163 184;
  --color-text-muted: 100 116 139;

  --color-border: 51 65 85;
  --color-border-light: 30 41 59;

  --color-success: 74 222 128;
  --color-warning: 250 204 21;
  --color-error: 248 113 113;
  --color-info: 96 165 250;

  --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.2);
  --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.3), 0 2px 4px -2px rgb(0 0 0 / 0.25);
  --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.35), 0 4px 6px -4px rgb(0 0 0 / 0.3);
  --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.4), 0 8px 10px -6px rgb(0 0 0 / 0.35);
}

/* ══════════════════════════════════════════════
   Base styles
   ══════════════════════════════════════════════ */
body {
  background-color: rgb(var(--color-bg));
  color: rgb(var(--color-text));
  font-family: 'Inter', system-ui, -apple-system, sans-serif;
  transition: background-color 0.3s ease, color 0.3s ease;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

#root {
  min-height: 100vh;
}

::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: rgb(var(--color-bg)); }
::-webkit-scrollbar-thumb { background: rgb(var(--color-text-muted)); border-radius: 3px; }
::-webkit-scrollbar-thumb:hover { background: rgb(var(--color-text-secondary)); }

/* ══════════════════════════════════════════════
   Utility classes
   ══════════════════════════════════════════════ */
.glass {
  background: rgb(var(--color-surface) / 0.7);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  border: 1px solid rgb(var(--color-border) / 0.5);
}

.glass-strong {
  background: rgb(var(--color-surface) / 0.85);
  backdrop-filter: blur(20px);
  -webkit-backdrop-filter: blur(20px);
  border: 1px solid rgb(var(--color-border) / 0.4);
}

.gradient-primary {
  background: linear-gradient(135deg, rgb(var(--color-primary)), rgb(var(--color-accent)));
}

.gradient-surface {
  background: linear-gradient(180deg, rgb(var(--color-surface)), rgb(var(--color-surface-alt)));
}

.text-gradient {
  background: linear-gradient(135deg, rgb(var(--color-primary)), rgb(var(--color-accent)));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

/* ══════════════════════════════════════════════
   Animations
   ══════════════════════════════════════════════ */
@keyframes float {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-10px); }
}

@keyframes shimmer {
  0% { background-position: -200% 0; }
  100% { background-position: 200% 0; }
}

@keyframes fadeInUp {
  from { opacity: 0; transform: translateY(20px); }
  to { opacity: 1; transform: translateY(0); }
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes slideInRight {
  from { opacity: 0; transform: translateX(20px); }
  to { opacity: 1; transform: translateX(0); }
}

@keyframes scaleIn {
  from { opacity: 0; transform: scale(0.9); }
  to { opacity: 1; transform: scale(1); }
}

@keyframes spin { to { transform: rotate(360deg); } }

.animate-float { animation: float 3s ease-in-out infinite; }
.animate-shimmer {
  background: linear-gradient(90deg, transparent, rgb(var(--color-primary) / 0.1), transparent);
  background-size: 200% 100%;
  animation: shimmer 2s infinite;
}
.animate-fade-in-up { animation: fadeInUp 0.5s ease-out forwards; }
.animate-fade-in { animation: fadeIn 0.4s ease-out forwards; }
.animate-slide-in-right { animation: slideInRight 0.4s ease-out forwards; }
.animate-scale-in { animation: scaleIn 0.3s ease-out forwards; }

.stagger > * { opacity: 0; animation: fadeInUp 0.5s ease-out forwards; }
.stagger > *:nth-child(1) { animation-delay: 0.05s; }
.stagger > *:nth-child(2) { animation-delay: 0.1s; }
.stagger > *:nth-child(3) { animation-delay: 0.15s; }
.stagger > *:nth-child(4) { animation-delay: 0.2s; }
.stagger > *:nth-child(5) { animation-delay: 0.25s; }
.stagger > *:nth-child(6) { animation-delay: 0.3s; }
.stagger > *:nth-child(7) { animation-delay: 0.35s; }
.stagger > *:nth-child(8) { animation-delay: 0.4s; }

.progress-bar-striped {
  background-image: linear-gradient(
    45deg,
    rgba(255, 255, 255, 0.15) 25%,
    transparent 25%,
    transparent 50%,
    rgba(255, 255, 255, 0.15) 50%,
    rgba(255, 255, 255, 0.15) 75%,
    transparent 75%,
    transparent
  );
  background-size: 1rem 1rem;
  animation: progress-bar-stripes 1s linear infinite;
}

@keyframes progress-bar-stripes {
  0% { background-position: 1rem 0; }
  100% { background-position: 0 0; }
}

.focus-ring:focus-visible {
  outline: 2px solid rgb(var(--color-primary));
  outline-offset: 2px;
}


================================================
FILE: frontend/src/main.jsx
================================================
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)


================================================
FILE: frontend/src/components/Dashboard.jsx
================================================
Error reading file with 'cp1252': 'charmap' codec can't decode byte 0x8f in position 3178: character maps to <undefined>


================================================
FILE: frontend/src/components/Home.jsx
================================================
Error reading file with 'cp1252': 'charmap' codec can't decode byte 0x8f in position 2717: character maps to <undefined>


================================================
FILE: frontend/src/components/Leaderboard.jsx
================================================
Error reading file with 'cp1252': 'charmap' codec can't decode byte 0x8f in position 2261: character maps to <undefined>


================================================
FILE: frontend/src/components/Login.jsx
================================================
Error reading file with 'cp1252': 'charmap' codec can't decode byte 0x8f in position 4088: character maps to <undefined>


================================================
FILE: frontend/src/components/Navbar.jsx
================================================
import React, { useState } from 'react';
import { Link, useNavigate, useLocation } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';
import { useTheme } from '../context/ThemeContext';

const ThemeToggle = () => {
    const { theme, toggleTheme } = useTheme();
    return (
        <button
            onClick={toggleTheme}
            className="relative w-14 h-7 rounded-full bg-surface-alt border border-theme-border transition-colors duration-300 focus-ring"
            aria-label="Toggle theme"
        >
            <span
                className={`absolute top-0.5 left-0.5 w-6 h-6 rounded-full transition-all duration-300 flex items-center justify-center text-sm ${
                    theme === 'dark'
                        ? 'translate-x-7 bg-indigo-500 text-white'
                        : 'translate-x-0 bg-yellow-400 text-yellow-900'
                }`}
            >
                {theme === 'dark' ? '🌙' : '☀️'}
            </span>
        </button>
    );
};

const Navbar = ({ variant = 'default' }) => {
    const { user, logout } = useAuth();
    const navigate = useNavigate();
    const location = useLocation();
    const [mobileOpen, setMobileOpen] = useState(false);

    const handleLogout = () => {
        logout();
        navigate('/login');
    };

    const isActive = (path) => location.pathname === path;

    const navLinks = user
        ? [
            { path: '/dashboard', label: 'Dashboard', icon: '🏠' },
            { path: '/progress', label: 'Progress', icon: '📊' },
            { path: '/leaderboard', label: 'Leaderboard', icon: '🏆' },
            { path: '/learn/start', label: 'New Session', icon: '▶️' },
          ]
        : [];

    return (
        <nav className="sticky top-0 z-50 glass-strong">
            <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
                <div className="flex justify-between h-16 items-center">
                    {/* Logo */}
                    <Link to={user ? '/dashboard' : '/'} className="flex items-center gap-2 group">
                        <div className="w-9 h-9 gradient-primary rounded-xl flex items-center justify-center text-white font-bold text-lg shadow-lg group-hover:scale-105 transition-transform">
                            A
                        </div>
                        <span className="text-lg font-bold text-theme-text hidden sm:block">
                            Adapt<span className="text-gradient">Learn</span>
                        </span>
                    </Link>

                    {/* Desktop Nav Links */}
                    {user && (
                        <div className="hidden md:flex items-center gap-1">
                            {navLinks.map(link => (
                                <Link
                                    key={link.path}
                                    to={link.path}
                                    className={`px-3 py-2 rounded-lg text-sm font-medium transition-all duration-200 ${
                                        isActive(link.path)
                                            ? 'bg-primary/10 text-primary'
                                            : 'text-theme-text-secondary hover:text-theme-text hover:bg-surface-alt'
                                    }`}
                                >
                                    <span className="mr-1.5">{link.icon}</span>
                                    {link.label}
                                </Link>
                            ))}
                        </div>
                    )}

                    {/* Right section */}
                    <div className="flex items-center gap-3">
                        <ThemeToggle />

                        {user ? (
                            <>
                                <div className="hidden sm:flex items-center gap-2 px-3 py-1.5 rounded-lg bg-surface-alt">
                                    <div className="w-7 h-7 gradient-primary rounded-full flex items-center justify-center text-white text-xs font-bold">
                                        {(user.first_name || user.username || '?')[0].toUpperCase()}
                                    </div>
                                    <span className="text-sm font-medium text-theme-text">
                                        {user.first_name || user.username}
                                    </span>
                                </div>
                                <button
                                    onClick={handleLogout}
                                    className="px-3 py-1.5 rounded-lg text-sm font-medium text-error hover:bg-error/10 transition-colors"
                                >
                                    Logout
                                </button>
                            </>
                        ) : (
                            variant !== 'auth' && (
                                <div className="flex items-center gap-2">
                                    <Link
                                        to="/login"
                                        className="px-4 py-2 rounded-lg text-sm font-medium text-theme-text-secondary hover:text-theme-text transition-colors"
                                    >
                                        Sign In
                                    </Link>
                                    <Link
                                        to="/register"
                                        className="px-4 py-2 gradient-primary text-white rounded-lg text-sm font-semibold hover:opacity-90 transition-opacity shadow-theme"
                                    >
                                        Get Started
                                    </Link>
                                </div>
                            )
                        )}

                        {/* Mobile hamburger */}
                        {user && (
                            <button
                                className="md:hidden p-2 rounded-lg text-theme-text-secondary hover:bg-surface-alt"
                                onClick={() => setMobileOpen(!mobileOpen)}
                            >
                                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    {mobileOpen ? (
                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                                    ) : (
                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 12h16M4 18h16" />
                                    )}
                                </svg>
                            </button>
                        )}
                    </div>
                </div>

                {/* Mobile nav */}
                {mobileOpen && user && (
                    <div className="md:hidden pb-4 pt-2 border-t border-theme-border animate-fade-in">
                        <div className="flex flex-col gap-1">
                            {navLinks.map(link => (
                                <Link
                                    key={link.path}
                                    to={link.path}
                                    onClick={() => setMobileOpen(false)}
                                    className={`px-3 py-2.5 rounded-lg text-sm font-medium transition-colors ${
                                        isActive(link.path)
                                            ? 'bg-primary/10 text-primary'
                                            : 'text-theme-text-secondary hover:bg-surface-alt'
                                    }`}
                                >
                                    <span className="mr-2">{link.icon}</span>
                                    {link.label}
                                </Link>
                            ))}
                        </div>
                    </div>
                )}
            </div>
        </nav>
    );
};

export { ThemeToggle };
export default Navbar;



================================================
FILE: frontend/src/components/Progress.jsx
================================================
Error reading file with 'cp1252': 'charmap' codec can't decode byte 0x9d in position 1064: character maps to <undefined>


================================================
FILE: frontend/src/components/ProtectedRoute.jsx
================================================
import React from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';

const ProtectedRoute = ({ children }) => {
    const { user, loading } = useAuth();
    const location = useLocation();

    if (loading) {
        return (
            <div className="min-h-screen bg-theme-bg flex items-center justify-center">
                <div className="text-center animate-fade-in">
                    <div className="w-12 h-12 border-4 border-primary border-t-transparent rounded-full animate-spin mx-auto mb-4" />
                    <p className="text-theme-text-secondary font-medium">Loading...</p>
                </div>
            </div>
        );
    }

    if (!user) {
        return <Navigate to="/login" state={{ from: location.pathname }} replace />;
    }

    return children;
};

export default ProtectedRoute;


================================================
FILE: frontend/src/components/Register.jsx
================================================
Error reading file with 'cp1252': 'charmap' codec can't decode byte 0x8f in position 4530: character maps to <undefined>


================================================
FILE: frontend/src/components/Learning/AtomComplete.jsx
================================================
// frontend/src/components/Learning/AtomComplete.jsx

import React from 'react';
import { useLearning } from '../../context/LearningContext';

const AtomComplete = ({ atom, onContinue, recommendation = '' }) => {
    const { atomMastery, currentTheta, answers } = useLearning();

    // Calculate stats
    const totalQuestions = answers.length;
    const correctCount = answers.filter(a => a.correct).length;
    const accuracy = totalQuestions > 0 ? (correctCount / totalQuestions) * 100 : 0;
    const avgTime = answers.length > 0 
        ? Math.round(answers.reduce((sum, a) => sum + a.time_taken, 0) / answers.length) 
        : 0;

    return (
        <div className="bg-surface rounded-theme-xl shadow-theme-lg p-8 text-center border border-theme-border animate-scale-in">
            {/* Success Icon */}
            <div className="mb-6">
                <div className="inline-flex items-center justify-center w-24 h-24 bg-emerald-500/10 rounded-full">
                    <span className="text-5xl">ðŸŽ‰</span>
                </div>
            </div>

            <h2 className="text-3xl font-bold text-theme-text mb-2">Atom Complete!</h2>
            <p className="text-xl text-emerald-500 mb-8">You've mastered: {atom?.name}</p>

            {/* Stats Grid */}
            <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mb-8 stagger">
                <div className="bg-primary/10 p-4 rounded-theme-lg">
                    <div className="text-2xl font-bold text-primary">
                        {Math.round(atomMastery * 100)}%
                    </div>
                    <div className="text-sm text-theme-text-muted">Final Mastery</div>
                </div>
                
                <div className="bg-violet-500/10 p-4 rounded-theme-lg">
                    <div className="text-2xl font-bold text-violet-500">
                        {accuracy.toFixed(0)}%
                    </div>
                    <div className="text-sm text-theme-text-muted">Accuracy</div>
                </div>
                
                <div className="bg-emerald-500/10 p-4 rounded-theme-lg">
                    <div className="text-2xl font-bold text-emerald-500">
                        {correctCount}/{totalQuestions}
                    </div>
                    <div className="text-sm text-theme-text-muted">Correct</div>
                </div>
                
                <div className="bg-orange-500/10 p-4 rounded-theme-lg">
                    <div className="text-2xl font-bold text-orange-500">
                        {avgTime}s
                    </div>
                    <div className="text-sm text-theme-text-muted">Avg Time</div>
                </div>
            </div>

            {/* Theta Change */}
            <div className="mb-8 p-4 bg-theme-bg rounded-theme-lg">
                <div className="text-sm text-theme-text-muted">Ability (Î¸) Progress</div>
                <div className="text-2xl font-bold text-theme-text">
                    {currentTheta.toFixed(2)}
                </div>
            </div>

            {recommendation && (
                <div className="mb-6 p-4 bg-info/10 border border-info/20 rounded-theme-lg text-info">
                    {recommendation}
                </div>
            )}

            {/* Continue Button */}
            <button
                onClick={onContinue}
                className="px-8 py-3 bg-emerald-500 text-white rounded-theme font-semibold hover:bg-emerald-600 transition-colors shadow-theme"
            >
                Continue to Next Atom â†’
            </button>

            <p className="mt-4 text-sm text-theme-text-muted">
                You're making great progress! Keep going.
            </p>
        </div>
    );
};

export default AtomComplete;


================================================
FILE: frontend/src/components/Learning/AtomList.jsx
================================================
import React from 'react';

const AtomList = ({ atoms, onStartAtom, conceptName, completedCount }) => {
    const getPhaseIcon = (phase) => {
        const icons = {
            'complete': '✅',
            'teaching': '📚',
            'diagnostic': '📝',
            'not_started': '⭕'
        };
        return icons[phase] || '📌';
    };

    const getPhaseColor = (phase) => {
        const colors = {
            'complete': 'text-emerald-500',
            'teaching': 'text-primary',
            'diagnostic': 'text-violet-500',
            'not_started': 'text-theme-text-muted'
        };
        return colors[phase] || 'text-theme-text-muted';
    };

    return (
        <div className="bg-surface rounded-theme-xl shadow-theme border border-theme-border p-8 animate-fade-in-up">
            <h2 className="text-2xl font-bold text-theme-text mb-2">{conceptName}</h2>
            <p className="text-theme-text-secondary mb-6">
                Completed {completedCount} of {atoms.length} concepts
            </p>

            <div className="space-y-3 mb-8">
                {atoms.map((atom, idx) => (
                    <div
                        key={atom.id}
                        className={`flex items-center justify-between p-4 rounded-theme-lg border transition-colors ${
                            atom.phase === 'not_started'
                                ? 'border-theme-border bg-theme-bg'
                                : atom.phase === 'complete'
                                ? 'border-emerald-500/20 bg-emerald-500/5'
                                : 'border-primary/20 bg-primary/5'
                        }`}
                    >
                        <div className="flex items-center">
                            <span className="text-2xl mr-4">{getPhaseIcon(atom.phase)}</span>
                            <div>
                                <p className="font-medium text-lg text-theme-text">{atom.name}</p>
                                <p className={`text-sm ${getPhaseColor(atom.phase)}`}>
                                    {atom.phase === 'complete' && '✓ Mastered'}
                                    {atom.phase === 'teaching' && '📖 Learning in progress'}
                                    {atom.phase === 'diagnostic' && '📝 Questions ready'}
                                    {atom.phase === 'not_started' && '⏳ Not started'}
                                </p>
                                {atom.mastery_score > 0 && (
                                    <p className="text-xs text-theme-text-muted mt-1">
                                        Mastery: {Math.round(atom.mastery_score * 100)}%
                                    </p>
                                )}
                            </div>
                        </div>
                        
                        {atom.phase === 'not_started' && (
                            <button
                                onClick={() => onStartAtom(atom)}
                                className="px-4 py-2 gradient-primary text-white rounded-theme font-medium hover:opacity-90 transition-opacity shadow-sm"
                            >
                                Start Learning
                            </button>
                        )}
                        
                        {atom.phase === 'teaching' && (
                            <button
                                onClick={() => onStartAtom(atom)}
                                className="px-4 py-2 bg-violet-500 text-white rounded-theme font-medium hover:bg-violet-600 transition-colors"
                            >
                                Continue
                            </button>
                        )}
                        
                        {atom.phase === 'complete' && (
                            <span className="text-emerald-500 font-medium">✓ Completed</span>
                        )}
                    </div>
                ))}
            </div>
        </div>
    );
};

export default AtomList;


================================================
FILE: frontend/src/components/Learning/AtomReview.jsx
================================================
import React from 'react';

const AtomReview = ({ atom, metrics, onComplete, onSkip }) => {

    return (
        <div className="bg-surface rounded-theme-xl shadow-theme border border-theme-border p-6 animate-fade-in-up">
            <h2 className="text-2xl font-bold text-theme-text mb-4">Review Required: {atom.name}</h2>
            
            {/* Performance Summary */}
            <div className="bg-error/10 border border-error/20 rounded-theme-lg p-4 mb-6">
                <h3 className="font-semibold text-error mb-2">Performance Analysis</h3>
                <div className="grid grid-cols-2 gap-4 text-sm">
                    <div>
                        <p className="text-theme-text-muted">Accuracy</p>
                        <p className="text-xl font-bold text-error">
                            {Math.round(metrics.accuracy * 100)}%
                        </p>
                    </div>
                    <div>
                        <p className="text-theme-text-muted">Mastery</p>
                        <p className="text-xl font-bold text-orange-500">
                            {Math.round(metrics.final_mastery * 100)}%
                        </p>
                    </div>
                    <div>
                        <p className="text-theme-text-muted">Time Ratio</p>
                        <p className="text-xl font-bold text-primary">
                            {metrics.time_ratio.toFixed(2)}x
                        </p>
                    </div>
                    <div>
                        <p className="text-theme-text-muted">Î¸ Change</p>
                        <p className={`text-xl font-bold ${metrics.theta_change > 0 ? 'text-emerald-500' : 'text-error'}`}>
                            {metrics.theta_change > 0 ? '+' : ''}{metrics.theta_change.toFixed(2)}
                        </p>
                    </div>
                </div>
            </div>

            {/* Error Analysis */}
            {metrics.error_count > 0 && (
                <div className="mb-6">
                    <h3 className="font-semibold text-theme-text mb-2">Error Types:</h3>
                    <div className="space-y-2">
                        {metrics.conceptual_errors > 0 && (
                            <div className="bg-violet-500/10 p-2.5 rounded-theme text-theme-text">
                                <span className="font-medium">Conceptual:</span> {metrics.conceptual_errors} errors
                            </div>
                        )}
                        {metrics.procedural_errors > 0 && (
                            <div className="bg-primary/10 p-2.5 rounded-theme text-theme-text">
                                <span className="font-medium">Procedural:</span> {metrics.procedural_errors} errors
                            </div>
                        )}
                        {metrics.factual_errors > 0 && (
                            <div className="bg-emerald-500/10 p-2.5 rounded-theme text-theme-text">
                                <span className="font-medium">Factual:</span> {metrics.factual_errors} errors
                            </div>
                        )}
                        {metrics.guessing_errors > 0 && (
                            <div className="bg-amber-500/10 p-2.5 rounded-theme text-theme-text">
                                <span className="font-medium">Guessing:</span> {metrics.guessing_errors} errors
                            </div>
                        )}
                    </div>
                </div>
            )}

            {/* Review Options */}
            <div className="space-y-3">
                <button
                    onClick={() => onComplete('reteach')}
                    className="w-full gradient-primary text-white py-3 rounded-theme font-semibold hover:opacity-90 transition-opacity"
                >
                    Review Teaching Material
                </button>
                <button
                    onClick={() => onComplete('practice')}
                    className="w-full bg-emerald-500 text-white py-3 rounded-theme font-semibold hover:bg-emerald-600 transition-colors"
                >
                    Practice with New Questions
                </button>
                <button
                    onClick={onSkip}
                    className="w-full bg-theme-bg text-theme-text-secondary py-3 rounded-theme font-semibold border border-theme-border hover:bg-surface-alt transition-colors"
                >
                    Skip Review (Not Recommended)
                </button>
            </div>
        </div>
    );
};

export default AtomReview;


================================================
FILE: frontend/src/components/Learning/ExternalResources.jsx
================================================
Error reading file with 'cp1252': 'charmap' codec can't decode byte 0x8f in position 3978: character maps to <undefined>


================================================
FILE: frontend/src/components/Learning/FatigueIndicator.jsx
================================================
Error reading file with 'cp1252': 'charmap' codec can't decode byte 0x8d in position 1779: character maps to <undefined>


================================================
FILE: frontend/src/components/Learning/LearningProgress.jsx
================================================
import React, { useEffect } from 'react';
import { useLearning } from '../../context/LearningContext';

const LearningProgress = ({ onContinue }) => {
    const { learningProgress, loadLearningProgress, loading } = useLearning();

    useEffect(() => {
        loadLearningProgress();
    }, [loadLearningProgress]);

    const getPhaseIcon = (phase) => {
        const icons = {
            'complete': '✅',
            'teaching': '📚',
            'diagnostic': '📝',
            'not_started': '⭕'
        };
        return icons[phase] || '📌';
    };

    const getPhaseColor = (phase) => {
        const colors = {
            'complete': 'text-emerald-500',
            'teaching': 'text-primary',
            'diagnostic': 'text-violet-500',
            'not_started': 'text-theme-text-muted'
        };
        return colors[phase] || 'text-theme-text-muted';
    };

    if (loading && !learningProgress) {
        return (
            <div className="text-center py-12">
                <div className="w-10 h-10 border-4 border-primary border-t-transparent rounded-full animate-spin mx-auto mb-3" />
                <p className="text-theme-text-muted">Loading progress...</p>
            </div>
        );
    }

    if (!learningProgress) {
        return (
            <div className="text-center py-12">
                <p className="text-error">Failed to load progress.</p>
            </div>
        );
    }

    return (
        <div className="max-w-4xl mx-auto">
            <h2 className="text-3xl font-bold text-theme-text mb-8">Your Learning Progress</h2>

            {/* Stats Cards */}
            <div className="bg-surface rounded-theme-xl shadow-theme border border-theme-border p-8 mb-8">
                <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
                    <div className="bg-primary/10 p-4 rounded-theme-lg text-center">
                        <p className="text-2xl font-bold text-primary">
                            {Math.round(learningProgress.overall_mastery * 100)}%
                        </p>
                        <p className="text-sm text-theme-text-muted">Overall Mastery</p>
                    </div>
                    
                    <div className="bg-emerald-500/10 p-4 rounded-theme-lg text-center">
                        <p className="text-2xl font-bold text-emerald-500">
                            {learningProgress.total_atoms || 0}
                        </p>
                        <p className="text-sm text-theme-text-muted">Total Atoms</p>
                    </div>
                    
                    <div className="bg-orange-500/10 p-4 rounded-theme-lg text-center">
                        <p className="text-2xl font-bold text-orange-500">
                            {learningProgress.learning_streak || 0} 🔥
                        </p>
                        <p className="text-sm text-theme-text-muted">Learning Streak</p>
                    </div>
                </div>

                {/* Theta Score */}
                <div className="border-t border-theme-border pt-6">
                    <div className="flex justify-between items-center">
                        <span className="text-theme-text font-medium">Ability (θ):</span>
                        <span className="text-lg font-semibold text-violet-500">
                            {learningProgress.overall_theta?.toFixed(2) || '0.00'}
                        </span>
                    </div>
                </div>
            </div>

            {/* Concepts */}
            <h3 className="text-xl font-bold text-theme-text mb-4">Concepts</h3>
            
            {learningProgress.concepts?.map((concept, idx) => (
                <div key={idx} className="bg-surface rounded-theme-xl shadow-theme border border-theme-border p-6 mb-4">
                    <div className="flex justify-between items-center mb-4">
                        <h4 className="text-lg font-semibold text-theme-text">{concept.name}</h4>
                        <span className="text-sm text-theme-text-muted">
                            {concept.mastered_count}/{concept.total_count} mastered
                        </span>
                    </div>

                    <div className="space-y-3">
                        {concept.atoms.map((atom, atomIdx) => (
                            <div key={atomIdx} className="flex items-center justify-between p-3 bg-theme-bg rounded-theme">
                                <div className="flex items-center">
                                    <span className="text-xl mr-3">{getPhaseIcon(atom.phase)}</span>
                                    <div>
                                        <p className="font-medium text-theme-text">{atom.name}</p>
                                        <p className="text-xs text-theme-text-muted">
                                            Mastery: {Math.round(atom.mastery * 100)}%
                                            {atom.streak > 0 && ` • Streak: ${atom.streak}`}
                                        </p>
                                    </div>
                                </div>
                                <span className={`text-sm font-medium ${getPhaseColor(atom.phase)}`}>
                                    {atom.phase === 'complete' ? 'Mastered' : 
                                     atom.phase === 'teaching' ? 'Learning' :
                                     atom.phase === 'diagnostic' ? 'In Progress' : 'Not Started'}
                                </span>
                            </div>
                        ))}
                    </div>
                </div>
            ))}

            <div className="flex justify-center mt-8">
                <button
                    onClick={onContinue}
                    className="gradient-primary text-white px-8 py-3 rounded-theme-lg font-semibold hover:shadow-theme-lg transition-all duration-200"
                >
                    Continue Learning
                </button>
            </div>
        </div>
    );
};

export default LearningProgress;


================================================
FILE: frontend/src/components/Learning/LearningRoute.jsx
================================================
import React from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { LearningProvider } from '../../context/LearningContext';
import TeachingFirstFlow from './TeachingFirstFlow';

const LearningRoute = () => {
    const { conceptId } = useParams();
    const navigate = useNavigate();
    
    if (!conceptId) {
        return (
            <div className="min-h-screen bg-theme-bg flex items-center justify-center">
                <div className="text-center">
                    <p className="text-error mb-4">No concept selected.</p>
                    <button 
                        onClick={() => navigate('/dashboard')}
                        className="px-5 py-2.5 gradient-primary text-white rounded-theme font-semibold hover:opacity-90 transition-opacity"
                    >
                        Go to Dashboard
                    </button>
                </div>
            </div>
        );
    }

    return (
        <LearningProvider>
            <TeachingFirstFlow conceptId={parseInt(conceptId)} />
        </LearningProvider>
    );
};

export default LearningRoute;


================================================
FILE: frontend/src/components/Learning/LearningVelocityGraph.jsx
================================================
import React, { useEffect, useMemo } from 'react';
import { useLearning } from '../../context/LearningContext';

/**
 * Lightweight inline velocity sparkline + engagement badge.
 * Uses raw canvas-free SVG so no chart library dependency.
 */
export default function LearningVelocityGraph({ sessionId }) {
  const { velocityData, engagementScore, fetchVelocityGraph } = useLearning();

  useEffect(() => {
    if (sessionId) fetchVelocityGraph(sessionId);
  }, [sessionId, fetchVelocityGraph]);

  // Build points for SVG sparkline from velocity snapshots
  const { points, masteryPoints, maxQ } = useMemo(() => {
    if (!velocityData || velocityData.length === 0) return { points: '', masteryPoints: '', maxQ: 0 };

    const maxQ = velocityData.length;
    const W = 240;
    const H = 60;
    const pad = 4;

    // accuracy line
    const accPts = velocityData.map((v, i) => {
      const x = pad + (i / Math.max(maxQ - 1, 1)) * (W - 2 * pad);
      const acc = v.rolling_accuracy ?? v.accuracy ?? 0;
      const y = H - pad - acc * (H - 2 * pad);
      return `${x},${y}`;
    });

    // mastery line
    const mPts = velocityData.map((v, i) => {
      const x = pad + (i / Math.max(maxQ - 1, 1)) * (W - 2 * pad);
      const m = v.mastery ?? 0;
      const y = H - pad - m * (H - 2 * pad);
      return `${x},${y}`;
    });

    return { points: accPts.join(' '), masteryPoints: mPts.join(' '), maxQ };
  }, [velocityData]);

  // Engagement color
  const engColor = engagementScore >= 0.7 ? 'text-emerald-500' : engagementScore >= 0.4 ? 'text-amber-500' : 'text-error';

  if (!velocityData || velocityData.length < 2) {
    return (
      <div className="text-xs text-theme-text-muted italic">
        Answer a few questions to see your learning velocityâ€¦
      </div>
    );
  }

  return (
    <div className="bg-surface/80 rounded-theme-lg p-3 border border-theme-border">
      <div className="flex items-center justify-between mb-1">
        <span className="text-xs font-semibold text-theme-text-secondary">Learning Velocity</span>
        <span className={`text-xs font-bold ${engColor}`}>
          Engagement {Math.round(engagementScore * 100)}%
        </span>
      </div>

      <svg viewBox="0 0 240 60" className="w-full h-14" preserveAspectRatio="none">
        {/* gridlines */}
        <line x1="4" y1="30" x2="236" y2="30" stroke="#e5e7eb" strokeWidth="0.5" strokeDasharray="3,3" />
        <line x1="4" y1="56" x2="236" y2="56" stroke="#e5e7eb" strokeWidth="0.5" />

        {/* mastery line */}
        <polyline
          fill="none"
          stroke="#a78bfa"
          strokeWidth="1.5"
          strokeLinecap="round"
          strokeLinejoin="round"
          points={masteryPoints}
        />

        {/* accuracy line */}
        <polyline
          fill="none"
          stroke="#6366f1"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          points={points}
        />
      </svg>

      <div className="flex items-center gap-4 mt-1 text-[10px] text-theme-text-muted">
        <span className="flex items-center gap-1">
          <span className="inline-block w-3 h-0.5 bg-indigo-500 rounded" /> Accuracy
        </span>
        <span className="flex items-center gap-1">
          <span className="inline-block w-3 h-0.5 bg-purple-400 rounded" /> Mastery
        </span>
        <span className="ml-auto">{maxQ} questions</span>
      </div>
    </div>
  );
}



================================================
FILE: frontend/src/components/Learning/QuestionsFromTeaching.jsx
================================================
Error reading file with 'cp1252': 'charmap' codec can't decode byte 0x9d in position 2678: character maps to <undefined>


================================================
FILE: frontend/src/components/Learning/StartAnyConceptSession.jsx
================================================
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { useLearning } from '../../context/LearningContext';
const StartAnyConceptSession = () => {
    const [formData, setFormData] = useState({
        subject: '',
        concept: '',
        knowledge_level: 'intermediate'
    });
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState('');
    const [generatedAtoms, setGeneratedAtoms] = useState(null);
    
    const navigate = useNavigate();
    const { generateConcept } = useLearning();

    const handleChange = (e) => {
        setFormData({
            ...formData,
            [e.target.name]: e.target.value
        });
    };

    const handleSubmit = async (e) => {
        e.preventDefault();
        setError('');
        setLoading(true);

        const result = await generateConcept(
            formData.subject,
            formData.concept,
            formData.knowledge_level
        );

        if (result.success) {
            setGeneratedAtoms(result.data);
        } else {
            setError(result.error || 'Failed to generate concept');
        }

        setLoading(false);
    };

    const handleStartLearning = () => {
        if (generatedAtoms) {
            navigate(`/learn/${generatedAtoms.concept_id}`);
        }
    };

    const knowledgeLevels = [
        { value: 'zero', label: 'Zero Knowledge (Complete Beginner)' },
        { value: 'beginner', label: 'Beginner (Some basic understanding)' },
        { value: 'intermediate', label: 'Intermediate (Comfortable with basics)' },
        { value: 'advanced', label: 'Advanced (Strong understanding)' }
    ];

    return (
        <div className="min-h-screen bg-theme-bg py-12">
            <div className="max-w-2xl mx-auto px-4">
                <div className="bg-surface rounded-theme-xl shadow-theme-lg border border-theme-border p-8 animate-fade-in-up">
                    <h1 className="text-2xl font-bold text-theme-text mb-6">
                        Start New Learning Session
                    </h1>

                    {!generatedAtoms ? (
                        <form onSubmit={handleSubmit} className="space-y-6">
                            {/* Subject */}
                            <div>
                                <label className="block text-sm font-medium text-theme-text-secondary mb-2">
                                    Subject *
                                </label>
                                <input
                                    type="text"
                                    name="subject"
                                    value={formData.subject}
                                    onChange={handleChange}
                                    required
                                    placeholder="e.g., Microprocessor, Mathematics, Physics"
                                    className="w-full px-4 py-2 bg-theme-bg border border-theme-border rounded-theme-lg focus:ring-2 focus:ring-primary/50 focus:border-primary text-theme-text placeholder:text-theme-text-muted transition-colors"
                                />
                            </div>

                            {/* Concept */}
                            <div>
                                <label className="block text-sm font-medium text-theme-text-secondary mb-2">
                                    Concept *
                                </label>
                                <input
                                    type="text"
                                    name="concept"
                                    value={formData.concept}
                                    onChange={handleChange}
                                    required
                                    placeholder="e.g., Memory Organization, Calculus, Quantum Mechanics"
                                    className="w-full px-4 py-2 bg-theme-bg border border-theme-border rounded-theme-lg focus:ring-2 focus:ring-primary/50 focus:border-primary text-theme-text placeholder:text-theme-text-muted transition-colors"
                                />
                            </div>

                            {/* Knowledge Level */}
                            <div>
                                <label className="block text-sm font-medium text-theme-text-secondary mb-2">
                                    Your Knowledge Level *
                                </label>
                                <select
                                    name="knowledge_level"
                                    value={formData.knowledge_level}
                                    onChange={handleChange}
                                    className="w-full px-4 py-2 bg-theme-bg border border-theme-border rounded-theme-lg focus:ring-2 focus:ring-primary/50 focus:border-primary text-theme-text transition-colors"
                                >
                                    {knowledgeLevels.map(level => (
                                        <option key={level.value} value={level.value}>
                                            {level.label}
                                        </option>
                                    ))}
                                </select>
                            </div>

                            {error && (
                                <div className="bg-error/10 border border-error/30 text-error px-4 py-3 rounded-theme-lg">
                                    {error}
                                </div>
                            )}

                            <button
                                type="submit"
                                disabled={loading}
                                className="w-full gradient-primary text-white font-bold py-3 px-4 rounded-theme-lg hover:shadow-theme-lg transition-all disabled:opacity-50 disabled:cursor-not-allowed"
                            >
                                {loading ? 'Generating atoms...' : 'Generate Learning Path'}
                            </button>

                            <button
                                type="button"
                                onClick={() => navigate('/dashboard')}
                                className="w-full bg-theme-bg hover:bg-theme-border text-theme-text-secondary font-bold py-3 px-4 rounded-theme-lg transition-colors"
                            >
                                Back to Dashboard
                            </button>
                        </form>
                    ) : (
                        <div className="space-y-6">
                            {/* Success message */}
                            <div className="bg-emerald-500/10 border border-emerald-500/30 rounded-theme-lg p-6">
                                <h3 className="text-lg font-semibold text-emerald-600 dark:text-emerald-400 mb-2">
                                    âœ“ Learning Path Generated!
                                </h3>
                                <p className="text-emerald-600 dark:text-emerald-400">
                                    We've created {generatedAtoms.atoms.length} atomic concepts for "{generatedAtoms.concept_name}".
                                </p>
                            </div>

                            {/* Atoms list */}
                            <div>
                                <h4 className="font-medium text-theme-text-secondary mb-3">Atomic Concepts:</h4>
                                <div className="space-y-2">
                                    {generatedAtoms.atoms.map((atom, index) => (
                                        <div 
                                            key={atom.id}
                                            className="flex items-center p-3 bg-theme-bg rounded-theme-lg"
                                        >
                                            <span className="w-8 h-8 bg-primary/10 text-primary rounded-full flex items-center justify-center font-bold mr-3">
                                                {index + 1}
                                            </span>
                                            <span className="text-theme-text">{atom.name}</span>
                                        </div>
                                    ))}
                                </div>
                            </div>

                            {/* Start learning button */}
                            <button
                                onClick={handleStartLearning}
                                className="w-full bg-emerald-500 hover:bg-emerald-600 text-white font-bold py-3 px-4 rounded-theme-lg transition-colors"
                            >
                                Start Learning Now
                            </button>

                            {/* Note */}
                            <p className="text-sm text-theme-text-muted text-center">
                                You'll learn each concept one by one, with teaching followed by assessment.
                            </p>
                        </div>
                    )}
                </div>
            </div>
            
        </div>
    );
};

export default StartAnyConceptSession;


================================================
FILE: frontend/src/components/Learning/StartAnyConceptSessionRoute.jsx
================================================
import React from 'react';
import { LearningProvider } from '../../context/LearningContext';
import StartAnyConceptSession from './StartAnyConceptSession';

const StartAnyConceptSessionRoute = () => {
    return (
        <LearningProvider>
            <StartAnyConceptSession />
        </LearningProvider>
    );
};

export default StartAnyConceptSessionRoute;


================================================
FILE: frontend/src/components/Learning/TeachingFirstFlow.jsx
================================================
<<<<<<< HEAD
Error reading file with 'cp1252': 'charmap' codec can't decode byte 0x8d in position 23321: character maps to <undefined>
=======
Error reading file with 'cp1252': 'charmap' codec can't decode byte 0x8d in position 24381: character maps to <undefined>
>>>>>>> 27ca5f792972d0c6644ef01c0171d1c6ce25ce32


================================================
FILE: frontend/src/components/Learning/TeachingModule.jsx
================================================
<<<<<<< HEAD
Error reading file with 'cp1252': 'charmap' codec can't decode byte 0x90 in position 3575: character maps to <undefined>


================================================
FILE: frontend/src/components/Learning/WeakTopicDetector.jsx
================================================
// frontend/src/components/Learning/WeakTopicDetector.jsx
import React, { useState, useEffect } from 'react';
import { AlertCircle, Target, TrendingUp, BookOpen, RefreshCw } from 'lucide-react';
import { useLearning } from '../../context/LearningContext';

const WeakTopicDetector = ({ conceptData, sessionId, onReviewStart }) => {
  const [showDetails, setShowDetails] = useState(false);
  const [analyzing, setAnalyzing] = useState(false);
  const { fetchWeakTopics, weakTopics, loading } = useLearning();

  // Get color based on mastery score
  const getMasteryColor = (score) => {
    if (score >= 0.7) return 'text-emerald-500';
    if (score >= 0.5) return 'text-yellow-500';
    if (score >= 0.3) return 'text-orange-500';
    return 'text-error';
  };

  // Get background color based on mastery score
  const getMasteryBgColor = (score) => {
    if (score >= 0.7) return 'bg-emerald-500/10';
    if (score >= 0.5) return 'bg-yellow-500/10';
    if (score >= 0.3) return 'bg-orange-500/10';
    return 'bg-error/10';
  };

  // Get progress bar color
  const getProgressColor = (score) => {
    if (score >= 0.7) return 'bg-emerald-500';
    if (score >= 0.5) return 'bg-yellow-500';
    if (score >= 0.3) return 'bg-orange-500';
    return 'bg-error';
  };

  // If no concept data or no weakest atom, don't render
  if (!conceptData || !conceptData.weakest_atom) {
    return null;
  }

  const { weakest_atom, lowest_mastery, final_mastery, accuracy, passed } = conceptData;

  return (
    <div className="bg-surface rounded-theme-xl shadow-theme-lg border border-theme-border overflow-hidden animate-fade-in-up">
      {/* Header */}
      <div className="gradient-primary px-6 py-4 text-white flex items-center justify-between">
        <div className="flex items-center gap-3">
          <Target className="w-6 h-6" />
          <div>
            <h3 className="font-semibold text-lg">Topic Mastery Analysis</h3>
            <p className="text-sm text-white/80">Personalized learning insights</p>
          </div>
        </div>
        <button
          onClick={() => setShowDetails(!showDetails)}
          className="px-3 py-1 bg-white/20 rounded-theme-lg text-sm font-medium hover:bg-white/30 transition-colors"
        >
          {showDetails ? 'Hide Details' : 'View Details'}
        </button>
      </div>

      {/* Main Content */}
      <div className="p-6">
        {/* Overall Performance */}
        <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
          <div className="bg-surface-alt rounded-theme-lg p-4">
            <p className="text-sm text-theme-text-muted mb-1">Final Mastery</p>
            <p className="text-2xl font-bold text-theme-text">
              {Math.round(final_mastery * 100)}%
            </p>
            <div className="w-full h-2 bg-theme-border rounded-full mt-2">
              <div
                className="h-full bg-primary rounded-full transition-all duration-500"
                style={{ width: `${final_mastery * 100}%` }}
              />
            </div>
          </div>

          <div className="bg-surface-alt rounded-theme-lg p-4">
            <p className="text-sm text-theme-text-muted mb-1">Challenge Accuracy</p>
            <p className="text-2xl font-bold text-theme-text">
              {Math.round(accuracy * 100)}%
            </p>
            <div className="flex items-center gap-2 mt-2">
              <span className={`text-sm font-medium ${passed ? 'text-emerald-500' : 'text-error'}`}>
                {passed ? 'âœ“ Passed' : 'âœ— Needs Work'}
              </span>
            </div>
          </div>

          <div className="bg-surface-alt rounded-theme-lg p-4">
            <p className="text-sm text-theme-text-muted mb-1">Concept Mastery</p>
            <p className="text-2xl font-bold text-theme-text">
              {Math.round(conceptData.concept_mastery * 100)}%
            </p>
            <p className="text-xs text-theme-text-muted mt-2">
              Average of all atoms
            </p>
          </div>
        </div>

        {/* Weakest Topic Alert */}
        <div className={`${getMasteryBgColor(lowest_mastery)} rounded-theme-lg p-5 border ${getMasteryColor(lowest_mastery).replace('text', 'border')}/20`}>
          <div className="flex items-start gap-4">
            <div className={`p-3 rounded-full ${getMasteryBgColor(lowest_mastery)}`}>
              <AlertCircle className={`w-6 h-6 ${getMasteryColor(lowest_mastery)}`} />
            </div>
            
            <div className="flex-1">
              <div className="flex items-center justify-between mb-2">
                <h4 className="font-semibold text-theme-text">Weakest Topic Identified</h4>
                <span className={`px-3 py-1 rounded-full text-xs font-medium ${getMasteryBgColor(lowest_mastery)} ${getMasteryColor(lowest_mastery)}`}>
                  Priority Review
                </span>
              </div>
              
              <p className="text-lg font-bold text-theme-text mb-2">
                {weakest_atom}
              </p>
              
              <div className="flex items-center gap-4 mb-3">
                <div className="flex-1">
                  <div className="flex justify-between text-sm mb-1">
                    <span className="text-theme-text-muted">Current Mastery</span>
                    <span className={`font-medium ${getMasteryColor(lowest_mastery)}`}>
                      {Math.round(lowest_mastery * 100)}%
                    </span>
                  </div>
                  <div className="w-full h-2 bg-theme-border rounded-full overflow-hidden">
                    <div
                      className={`h-full ${getProgressColor(lowest_mastery)} transition-all duration-500`}
                      style={{ width: `${lowest_mastery * 100}%` }}
                    />
                  </div>
                </div>
                
                <button
                  onClick={() => onReviewStart?.(weakest_atom)}
                  className="px-4 py-2 gradient-primary text-white rounded-theme-lg text-sm font-medium hover:opacity-90 transition-opacity flex items-center gap-2"
                >
                  <RefreshCw className="w-4 h-4" />
                  Review Now
                </button>
              </div>

              {/* Recommendation */}
              <div className="mt-4 p-3 bg-theme-bg rounded-theme-lg border border-theme-border">
                <p className="text-sm text-theme-text">
                  {conceptData.recommendation}
                </p>
              </div>
            </div>
          </div>
        </div>

        {/* Detailed Analysis (Conditional) */}
        {showDetails && (
          <div className="mt-6 animate-fade-in">
            <h4 className="font-semibold text-theme-text mb-3 flex items-center gap-2">
              <BookOpen className="w-4 h-4 text-primary" />
              Learning Recommendations
            </h4>
            
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div className="bg-surface-alt rounded-theme-lg p-4">
                <h5 className="font-medium text-theme-text mb-2">Focus Areas</h5>
                <ul className="space-y-2">
                  <li className="flex items-start gap-2 text-sm text-theme-text-secondary">
                    <span className="text-primary mt-1">â€¢</span>
                    <span>Review fundamental concepts of "{weakest_atom}"</span>
                  </li>
                  <li className="flex items-start gap-2 text-sm text-theme-text-secondary">
                    <span className="text-primary mt-1">â€¢</span>
                    <span>Practice with targeted exercises</span>
                  </li>
                  <li className="flex items-start gap-2 text-sm text-theme-text-secondary">
                    <span className="text-primary mt-1">â€¢</span>
                    <span>Watch video explanations for better understanding</span>
                  </li>
                </ul>
              </div>

              <div className="bg-surface-alt rounded-theme-lg p-4">
                <h5 className="font-medium text-theme-text mb-2">Mastery Gap</h5>
                <div className="space-y-3">
                  <div>
                    <div className="flex justify-between text-sm mb-1">
                      <span className="text-theme-text-muted">Current</span>
                      <span className="text-orange-500">{Math.round(lowest_mastery * 100)}%</span>
                    </div>
                    <div className="w-full h-2 bg-theme-border rounded-full overflow-hidden">
                      <div className="h-full bg-orange-500" style={{ width: `${lowest_mastery * 100}%` }} />
                    </div>
                  </div>
                  <div>
                    <div className="flex justify-between text-sm mb-1">
                      <span className="text-theme-text-muted">Target</span>
                      <span className="text-emerald-500">70%</span>
                    </div>
                    <div className="w-full h-2 bg-theme-border rounded-full overflow-hidden">
                      <div className="h-full bg-emerald-500" style={{ width: '70%' }} />
                    </div>
                  </div>
                  <p className="text-xs text-theme-text-muted mt-2">
                    Need to improve by {Math.max(0, 70 - lowest_mastery * 100).toFixed(0)}% to reach mastery
                  </p>
                </div>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

export default WeakTopicDetector;
=======
Error reading file with 'cp1252': 'charmap' codec can't decode byte 0x90 in position 1488: character maps to <undefined>
>>>>>>> 27ca5f792972d0c6644ef01c0171d1c6ce25ce32


================================================
FILE: frontend/src/context/AuthContext.jsx
================================================
import React, { createContext, useState, useContext, useEffect } from 'react';
import axios from '../axiosConfig';
import { useNavigate } from 'react-router-dom';

const AuthContext = createContext(null);

export const AuthProvider = ({ children }) => {
    const [user, setUser] = useState(null);
    const [loading, setLoading] = useState(true);
    const navigate = useNavigate();

    // Check for existing token on mount
    useEffect(() => {
        const token = localStorage.getItem('access_token');
        if (token) {
            fetchUser();
        } else {
            setLoading(false);
        }
    }, []);

    const fetchUser = async () => {
        try {
            const response = await axios.get('/auth/api/dashboard/');
            setUser(response.data.user);
        } catch (error) {
            console.error("Failed to fetch user:", error);
            localStorage.removeItem('access_token');
            localStorage.removeItem('refresh_token');
        } finally {
            setLoading(false);
        }
    };

    const login = async (username, password) => {
        try {
            const response = await axios.post('/auth/api/login/', {
                username,
                password
            });
            
            const { access, refresh, user } = response.data;
            
            localStorage.setItem('access_token', access);
            localStorage.setItem('refresh_token', refresh);
            setUser(user);
            
            return { success: true };
        } catch (error) {
            return { 
                success: false, 
                error: error.response?.data?.error || 'Login failed' 
            };
        }
    };

    const register = async (userData) => {
        try {
            const response = await axios.post('/auth/api/register/', userData);
            return { success: true, data: response.data };
        } catch (error) {
            return { 
                success: false, 
                error: error.response?.data || 'Registration failed' 
            };
        }
    };

    const logout = () => {
        localStorage.removeItem('access_token');
        localStorage.removeItem('refresh_token');
        setUser(null);
        navigate('/login');
    };

    const value = {
        user,
        login,
        register,
        logout,
        loading
    };

    return (
        <AuthContext.Provider value={value}>
            {children}
        </AuthContext.Provider>
    );
};

export const useAuth = () => {
    const context = useContext(AuthContext);
    if (!context) {
        throw new Error('useAuth must be used within an AuthProvider');
    }
    return context;
};


================================================
FILE: frontend/src/context/LearningContext.jsx
================================================
// frontend/src/context/LearningContext.jsx - Enhanced version

import React, { createContext, useCallback, useMemo, useState, useContext, useRef } from 'react';
import axios from '../axiosConfig';

const LearningContext = createContext(null);

export const LearningProvider = ({ children }) => {
    const [currentSession, setCurrentSession] = useState(null);
    const [currentAtom, setCurrentAtom] = useState(null);
    const [learningProgress, setLearningProgress] = useState(null);
    const [loading, setLoading] = useState(false);
    const [knowledgeLevel, setKnowledgeLevel] = useState('intermediate');
    
    // Real-time tracking
    const [currentQuestions, setCurrentQuestions] = useState([]);
    const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
    const [answers, setAnswers] = useState([]);
    const [atomMastery, setAtomMastery] = useState(0.3);
    const [currentTheta, setCurrentTheta] = useState(0.0);
    const [pacingDecision, setPacingDecision] = useState('stay');
    const [nextAction, setNextAction] = useState('continue_practice');
    const [showTeaching, setShowTeaching] = useState(false);
    const [teachingContent, setTeachingContent] = useState(null);
    const [metrics, setMetrics] = useState({});

    // Enhanced pacing engine state
    const [fatigueLevel, setFatigueLevel] = useState('fresh');
    const [velocityData, setVelocityData] = useState([]);
    const [retentionAction, setRetentionAction] = useState(null);
    const [hintWarning, setHintWarning] = useState(null);
    const [engagementScore, setEngagementScore] = useState(0.7);
    const [masteryVerdict, setMasteryVerdict] = useState(null);
    const [showBreakModal, setShowBreakModal] = useState(false);
    
    // Timers
    const questionStartTime = useRef(null);
    const [timeSpent, setTimeSpent] = useState(0);

    // Race-condition guard: track latest generation request
    const latestQuestionGenId = useRef(0);

    // Generate atoms for a concept (no questions)
    const generateConcept = useCallback(async (subject, concept, knowledgeLevel = 'intermediate') => {
        setLoading(true);
        try {
            const response = await axios.post('/auth/api/generate-concept/', {
                subject: subject,
                concept: concept,
                knowledge_level: knowledgeLevel
            });
            return { success: true, data: response.data };
        } catch (error) {
            return {
                success: false,
                error: error.response?.data?.error || 'Failed to generate concept'
            };
        } finally {
            setLoading(false);
        }
    }, []);

    // Start teaching session for a concept
    const startTeachingSession = useCallback(async (conceptId, level = 'intermediate') => {
        setLoading(true);
        setKnowledgeLevel(level);
        setAnswers([]);
        setAtomMastery(0.3);
        setPacingDecision('stay');
        
        try {
            const response = await axios.post('/auth/api/start-teaching-session/', {
                concept_id: conceptId,
                knowledge_level: level
            });
            
            setCurrentSession(response.data);
            
            // If there's a current atom, set it
            if (response.data.current_atom) {
                setCurrentAtom(response.data.current_atom);
            }
            
            return { success: true, data: response.data };
        } catch (error) {
            return {
                success: false,
                error: error.response?.data?.error || 'Failed to start session'
            };
        } finally {
            setLoading(false);
        }
    }, []);

    // Get teaching content for an atom
    const getTeachingContent = useCallback(async ({ session_id, atom_id }) => {
        setLoading(true);
        setShowTeaching(true);
        try {
            const response = await axios.post('/auth/api/teaching-content/', {
                session_id: session_id,
                atom_id: atom_id
            });

            // Normalize payload: backend may nest under teaching_content
            const raw = response.data?.teaching_content || response.data || {};
            const examples = Array.isArray(raw.examples) ? raw.examples : [];

            const normalized = {
                explanation: raw.explanation || '',
                example: raw.example || examples[0] || '',
                analogy: raw.analogy || '',
                misconception: raw.misconception || examples[2] || '',
                practical_application: raw.practical_application || examples[1] || '',
                examples: examples,
                videos: Array.isArray(response.data?.videos) ? response.data.videos : [],
                images: Array.isArray(response.data?.images) ? response.data.images : [],
            };

            setTeachingContent(normalized);
            setCurrentAtom({
                id: atom_id,
                name: response.data?.atom_name || response.data?.name || raw.atom_name || raw.name,
            });
            
            return { success: true, data: response.data };
        } catch (error) {
            return {
                success: false,
                error: error.response?.data?.error || 'Failed to get teaching content'
            };
        } finally {
            setLoading(false);
        }
    }, []);

    // Generate questions based on teaching content
    const generateQuestionsFromTeaching = useCallback(async ({ session_id, atom_id, force_new = false }) => {
        setLoading(true);
        const requestId = ++latestQuestionGenId.current;
        try {
            const response = await axios.post('/auth/api/generate-questions-from-teaching/', {
                session_id: session_id,
                atom_id: atom_id,
                force_new: force_new
            });
            
            // Only apply state if this is still the latest request (prevents race condition)
            if (requestId === latestQuestionGenId.current) {
                setCurrentQuestions(response.data.questions || []);
                setCurrentQuestionIndex(0);
                
                // Start timer for first question
                questionStartTime.current = Date.now();
            }
            
            return { success: true, data: response.data };
        } catch (error) {
            return {
                success: false,
                error: error.response?.data?.error || 'Failed to generate questions'
            };
        } finally {
            if (requestId === latestQuestionGenId.current) {
                setLoading(false);
            }
        }
    }, []);

    // Generate initial diagnostic quiz
    const generateInitialQuiz = useCallback(async ({ session_id }) => {
        setLoading(true);
        try {
            const response = await axios.post('/auth/api/initial-quiz/', {
                session_id: session_id
            });
            return { success: true, data: response.data };
        } catch (error) {
            return {
                success: false,
                error: error.response?.data?.error || 'Failed to generate initial quiz'
            };
        } finally {
            setLoading(false);
        }
    }, []);

    const submitInitialQuizAnswer = useCallback(async ({ session_id, question_index, selected, time_taken }) => {
        try {
            const response = await axios.post('/auth/api/submit-initial-quiz-answer/', {
                session_id,
                question_index,
                selected,
                time_taken
            });

            const data = response.data;

            // Real-time mastery & theta update from initial quiz
            if (data.updated_mastery !== undefined) {
                setAtomMastery(data.updated_mastery);
            }
            if (data.updated_theta !== undefined) {
                setCurrentTheta(data.updated_theta);
            }

            return { success: true, data };
        } catch (error) {
            return {
                success: false,
                error: error.response?.data?.error || 'Failed to submit initial quiz answer'
            };
        }
    }, []);

    const completeInitialQuiz = useCallback(async ({ session_id }) => {
        try {
            const response = await axios.post('/auth/api/complete-initial-quiz/', {
                session_id
            });
            return { success: true, data: response.data };
        } catch (error) {
            return {
                success: false,
                error: error.response?.data?.error || 'Failed to complete initial quiz'
            };
        }
    }, []);

    const generateFinalChallenge = useCallback(async ({ session_id, atom_id }) => {
        setLoading(true);
        const requestId = ++latestQuestionGenId.current;
        try {
            const response = await axios.post('/auth/api/final-challenge/', {
                session_id,
                atom_id
            });
            if (requestId === latestQuestionGenId.current) {
                setCurrentQuestions(response.data.questions || []);
                setCurrentQuestionIndex(0);
                questionStartTime.current = Date.now();
            }
            return { success: true, data: response.data };
        } catch (error) {
            return {
                success: false,
                error: error.response?.data?.error || 'Failed to generate final challenge'
            };
        } finally {
            if (requestId === latestQuestionGenId.current) {
                setLoading(false);
            }
        }
    }, []);

    const completeFinalChallenge = useCallback(async ({ session_id, atom_id }) => {
        try {
            const response = await axios.post('/auth/api/complete-final-challenge/', {
                session_id,
                atom_id
            });
            return { success: true, data: response.data };
        } catch (error) {
            return {
                success: false,
                error: error.response?.data?.error || 'Failed to complete final challenge'
            };
        }
    }, []);

    // â”€â”€ Concept Final Challenge â”€â”€

    const generateConceptFinalChallenge = useCallback(async ({ session_id, concept_id }) => {
        setLoading(true);
        const requestId = ++latestQuestionGenId.current;
        try {
            const response = await axios.post('/auth/api/concept-final-challenge/', {
                session_id,
                concept_id
            });
            if (requestId === latestQuestionGenId.current) {
                setCurrentQuestions(response.data.questions || []);
                setCurrentQuestionIndex(0);
                questionStartTime.current = Date.now();
            }
            return { success: true, data: response.data };
        } catch (error) {
            return {
                success: false,
                error: error.response?.data?.error || 'Failed to generate concept final challenge'
            };
        } finally {
            if (requestId === latestQuestionGenId.current) {
                setLoading(false);
            }
        }
    }, []);

    const submitConceptFinalAnswer = useCallback(async ({ session_id, question_index, selected, time_taken }) => {
        let timeTaken = time_taken;
        if (timeTaken === undefined && questionStartTime.current) {
            timeTaken = Math.round((Date.now() - questionStartTime.current) / 1000);
        } else if (timeTaken === undefined) {
            timeTaken = 30;
        }
        try {
            const response = await axios.post('/auth/api/submit-concept-final-answer/', {
                session_id,
                question_index,
                selected,
                time_taken: timeTaken
            });
            const data = response.data;
            const newAnswer = {
                question_index,
                selected,
                correct: data.correct,
                time_taken: timeTaken,
            };
            setAnswers(prev => [...prev, newAnswer]);
            return { success: true, data };
        } catch (error) {
            return {
                success: false,
                error: error.response?.data?.error || 'Failed to submit concept final answer'
            };
        }
    }, []);

    const completeConceptFinalChallenge = useCallback(async ({ session_id, concept_id }) => {
        try {
            const response = await axios.post('/auth/api/complete-concept-final-challenge/', {
                session_id,
                concept_id
            });
            return { success: true, data: response.data };
        } catch (error) {
            return {
                success: false,
                error: error.response?.data?.error || 'Failed to complete concept final challenge'
            };
        }
    }, []);

    // Submit answer for an atom question with REAL-TIME updates
    const submitAtomAnswer = useCallback(async ({ 
        session_id, 
        atom_id, 
        question_index, 
        selected,
        forceTimeTaken = null,
        question_set = 'teaching'
    }) => {
        // Calculate time taken if not provided
        let time_taken = forceTimeTaken;
        if (time_taken === null && questionStartTime.current) {
            time_taken = Math.round((Date.now() - questionStartTime.current) / 1000);
        } else if (time_taken === null) {
            time_taken = 30; // Default fallback
        }
        
        try {
            const response = await axios.post('/auth/api/submit-atom-answer/', {
                session_id: session_id,
                atom_id: atom_id,
                question_index: question_index,
                selected: selected,
                time_taken: time_taken,
                question_set: question_set
            });
            
            const data = response.data;
            
            // REAL-TIME UI UPDATES based on response
            setAtomMastery(data.updated_mastery);
            setCurrentTheta(data.updated_theta);
            setPacingDecision(data.pacing_decision);
            setNextAction(data.next_action);
            setMetrics(data.metrics || {});

            // Enhanced pacing engine updates
            if (data.fatigue) setFatigueLevel(data.fatigue);
            if (data.retention_action) setRetentionAction(data.retention_action);
            if (data.hint_warning) setHintWarning(data.hint_warning);
            if (data.engagement_adjustment) setEngagementScore(data.engagement_adjustment.score ?? engagementScore);
            if (data.mastery_verdict) setMasteryVerdict(data.mastery_verdict);
            if (data.velocity_snapshot) setVelocityData(prev => [...prev, data.velocity_snapshot]);

            // Auto-show break modal on high fatigue
            if (data.fatigue === 'high' || data.fatigue === 'critical') {
                setShowBreakModal(true);
            }
            
            // Store answer
            const newAnswer = {
                question_index,
                selected,
                correct: data.correct,
                error_type: data.error_type,
                time_taken,
                mastery_after: data.updated_mastery,
                pacing_decision: data.pacing_decision
            };
            
            setAnswers(prev => [...prev, newAnswer]);
            
            // Check if atom is complete
            if (data.atom_complete) {
                // Move to next atom or show completion
                if (data.next_atom) {
                    setCurrentAtom(prev => ({
                        ...prev,
                        next_atom: data.next_atom
                    }));
                }
            }
            
            // Update session data with pacing info
            setCurrentSession(prev => {
                if (!prev) return prev;
                return {
                    ...prev,
                    last_pacing: data.pacing_decision,
                    current_mastery: data.updated_mastery,
                    current_theta: data.updated_theta
                };
            });
            
            return { success: true, data };
        } catch (error) {
            return {
                success: false,
                error: error.response?.data?.error || 'Failed to submit answer'
            };
        }
    }, []);

    // Start next question with timer
    const nextQuestion = useCallback(() => {
        if (currentQuestionIndex < currentQuestions.length - 1) {
            setCurrentQuestionIndex(prev => prev + 1);
            questionStartTime.current = Date.now();
        }
    }, [currentQuestionIndex, currentQuestions.length]);

    // Complete atom and determine next action
    const completeAtom = useCallback(async ({ session_id, atom_id, continue_learning }) => {
        try {
            const response = await axios.post('/auth/api/complete-atom/', {
                session_id: session_id,
                atom_id: atom_id,
                continue_learning: continue_learning
            });
            
            const data = response.data;
            
            // Handle next steps based on pacing
            if (data.next_action === 'next_atom' && data.next_atom) {
                setCurrentAtom(data.next_atom);
                setShowTeaching(true); // Show teaching for next atom
                setCurrentQuestions([]);
                setAnswers([]);
            } else if (data.concept_complete) {
                // All atoms complete
                setCurrentAtom(null);
                setCurrentSession(null);
            }
            
            return { success: true, data };
        } catch (error) {
            return {
                success: false,
                error: error.response?.data?.error || 'Failed to complete atom'
            };
        }
    }, []);

    // Load learning progress
    const loadLearningProgress = useCallback(async () => {
        setLoading(true);
        try {
            const response = await axios.get('/auth/api/progress/');
            setLearningProgress(response.data);
            return { success: true, data: response.data };
        } catch (error) {
            return {
                success: false,
                error: error.response?.data?.error || 'Failed to load progress'
            };
        } finally {
            setLoading(false);
        }
    }, []);

    // â”€â”€ Enhanced pacing engine API methods â”€â”€

    const fetchVelocityGraph = useCallback(async (sessionId) => {
        try {
            const response = await axios.get('/auth/api/velocity-graph/', {
                params: { session_id: sessionId }
            });
            setVelocityData(response.data.session_velocity || []);
            setEngagementScore(response.data.engagement_score ?? 0.7);
            return { success: true, data: response.data };
        } catch (error) {
            return { success: false, error: error.response?.data?.error || 'Failed to fetch velocity' };
        }
    }, []);

    const fetchFatigueStatus = useCallback(async (sessionId) => {
        try {
            const response = await axios.get('/auth/api/fatigue-status/', {
                params: { session_id: sessionId }
            });
            setFatigueLevel(response.data.fatigue_level || 'fresh');
            return { success: true, data: response.data };
        } catch (error) {
            return { success: false, error: error.response?.data?.error || 'Failed to fetch fatigue' };
        }
    }, []);

    const recordBreak = useCallback(async (sessionId) => {
        try {
            const response = await axios.post('/auth/api/record-break/', {
                session_id: sessionId
            });
            setFatigueLevel('fresh');
            setShowBreakModal(false);
            return { success: true, data: response.data };
        } catch (error) {
            return { success: false, error: error.response?.data?.error || 'Failed to record break' };
        }
    }, []);

    const checkRetention = useCallback(async ({ session_id, atom_id, passed = null }) => {
        try {
            const response = await axios.post('/auth/api/retention-check/', {
                session_id, atom_id, passed
            });
            if (passed !== null) {
                setRetentionAction(null); // Clear after recording
            }
            return { success: true, data: response.data };
        } catch (error) {
            return { success: false, error: error.response?.data?.error || 'Failed retention check' };
        }
    }, []);

    const recordHint = useCallback(async ({ atom_id, hint_level = 1 }) => {
        try {
            const response = await axios.post('/auth/api/record-hint/', {
                atom_id, hint_level
            });
            setHintWarning(response.data.hint_warning);
            return { success: true, data: response.data };
        } catch (error) {
            return { success: false, error: error.response?.data?.error || 'Failed to record hint' };
        }
    }, []);

    // Reset for new atom
    const resetForNewAtom = useCallback(() => {
        setCurrentQuestions([]);
        setCurrentQuestionIndex(0);
        setAnswers([]);
        setShowTeaching(true);
        setPacingDecision('stay');
        questionStartTime.current = null;
    }, []);

    const value = useMemo(() => ({
        // State
        currentSession,
        currentAtom,
        learningProgress,
        loading,
        knowledgeLevel,
        
        // Real-time tracking
        currentQuestions,
        currentQuestionIndex,
        answers,
        atomMastery,
        currentTheta,
        pacingDecision,
        nextAction,
        showTeaching,
        teachingContent,
        metrics,
        timeSpent,

        // Enhanced pacing engine state
        fatigueLevel,
        velocityData,
        retentionAction,
        hintWarning,
        engagementScore,
        masteryVerdict,
        showBreakModal,
        
        // Setters
        setKnowledgeLevel,
        setShowTeaching,
        setShowBreakModal,
        
        // Core methods
        generateConcept,
        startTeachingSession,
        getTeachingContent,
        generateQuestionsFromTeaching,
        generateInitialQuiz,
        submitInitialQuizAnswer,
        completeInitialQuiz,
        generateFinalChallenge,
        completeFinalChallenge,
        submitAtomAnswer,
        completeAtom,
        loadLearningProgress,
        nextQuestion,
        resetForNewAtom,

        // Enhanced pacing engine methods
        fetchVelocityGraph,
        fetchFatigueStatus,
        recordBreak,
        checkRetention,
        recordHint,

        // Concept final challenge methods
        generateConceptFinalChallenge,
        submitConceptFinalAnswer,
        completeConceptFinalChallenge,
        
    }), [
        currentSession,
        currentAtom,
        learningProgress,
        loading,
        knowledgeLevel,
        currentQuestions,
        currentQuestionIndex,
        answers,
        atomMastery,
        currentTheta,
        pacingDecision,
        nextAction,
        showTeaching,
        teachingContent,
        metrics,
        timeSpent,
        fatigueLevel,
        velocityData,
        retentionAction,
        hintWarning,
        engagementScore,
        masteryVerdict,
        showBreakModal,
        generateConcept,
        startTeachingSession,
        getTeachingContent,
        generateQuestionsFromTeaching,
        generateInitialQuiz,
        submitInitialQuizAnswer,
        completeInitialQuiz,
        generateFinalChallenge,
        completeFinalChallenge,
        submitAtomAnswer,
        completeAtom,
        loadLearningProgress,
        nextQuestion,
        resetForNewAtom,
        fetchVelocityGraph,
        fetchFatigueStatus,
        recordBreak,
        checkRetention,
        recordHint,
        generateConceptFinalChallenge,
        submitConceptFinalAnswer,
        completeConceptFinalChallenge,
    ]);

    return (
        <LearningContext.Provider value={value}>
            {children}
        </LearningContext.Provider>
    );
};

export const useLearning = () => {
    const context = useContext(LearningContext);
    if (!context) {
        throw new Error('useLearning must be used within a LearningProvider');
    }
    return context;
};


================================================
FILE: frontend/src/context/ThemeContext.jsx
================================================
import React, { createContext, useContext, useEffect, useState } from 'react';

const ThemeContext = createContext(null);

export const ThemeProvider = ({ children }) => {
    const [theme, setTheme] = useState(() => {
        if (typeof window !== 'undefined') {
            const stored = localStorage.getItem('theme');
            if (stored) return stored;
            return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
        }
        return 'light';
    });

    useEffect(() => {
        const root = document.documentElement;
        if (theme === 'dark') {
            root.classList.add('dark');
        } else {
            root.classList.remove('dark');
        }
        localStorage.setItem('theme', theme);
    }, [theme]);

    const toggleTheme = () => setTheme(prev => (prev === 'dark' ? 'light' : 'dark'));

    return (
        <ThemeContext.Provider value={{ theme, toggleTheme }}>
            {children}
        </ThemeContext.Provider>
    );
};

export const useTheme = () => {
    const ctx = useContext(ThemeContext);
    if (!ctx) throw new Error('useTheme must be used within ThemeProvider');
    return ctx;
};


<<<<<<< HEAD

================================================
FILE: frontend/src/pages/AIAssistantPage.jsx
================================================
Error reading file with 'cp1252': 'charmap' codec can't decode byte 0x8f in position 7561: character maps to <undefined>

=======
>>>>>>> 27ca5f792972d0c6644ef01c0171d1c6ce25ce32
